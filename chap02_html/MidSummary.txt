

인터넷 vs WWW
	: 인터넷 >> 전 세계의 컴퓨터가 연결된 "네트워크"
	: WWW >> 인터넷 이라는 네트워크를 사용하는 애플리케이션 중 하나
		: 기존 인터넷과의 차이점 : 단순 "문자" 를 넘어 "하이퍼텍스트" , 그림 등을 통해 서비스를 이용할 수 있게 한 것.
 
WWW 의 3가지 기본 기술
	1. HTML 
	2. URL 
	3. HTTP 



URL :  인터넷에 있는 자원(resource)의 위치를 나타내기 위한 "규약"
	: URL 에 % 가 들어가는 이유  >> 특정 문자는 "%숫자"의 형태로 변환하는 URL인코딩 방식 때문
		:URL 은 특정 charset 만을 허용하기 때문에, url 에 포함될  수 없는 문자들은 특별한 방식으로 인코딩 되어야하는데, "%기호 + 숫자" 의 형태로 해당 문자를 인코딩 하여 포함하게 된다
			: ex ) 띄어쓰기 는 그 자체로 못 쓰이고 %20 으로 쓰인다
			: 브라우져의 url창에는 이쁘게 표시되지만, f12를 통해 실제로 request 된 url 을 보면 url 이 그대로 전송되는게 아니라 인코딩 되어 request 되었음을 알 수 있따.

	: 쿼리스트링(쿼리파라미터)의 구성 >> ? 로 시작하고 key와 value 가 각각 등호기호 로 짝지어져있고, , 각각의 쌍은 & 로 구분된다
		: != path variable >> 쿼리스트링 그런것 없이 단순 아이디 값만 붙여서 리소스를 식별하는데 쓰임

	: URL, URN , URI  >> URL, URN ⊂URI	
		: URI Uniform Resource Identifier >> 리소스를 나타내는 고유 식별자.
		: URN Uniform Resource Name >> 리소스의 이름을 통해 식별하는 식별자
		: URL Uniform Resource Location >> 리소스의 경로를 위치를 통해 식별하는 식별자.
	


프로토콜 : 규칙.

W3C World Wide Web Consosium
	: 웹 표준 개발 (프로토콜 , 가이드 라인 등)하는 국제 기관(컨소시움)
		: 웹 표준 
			: 웹에서 표준적으로 사용되는 기술이나 규칙. W3C 에서 권고한 표준안
			: 목적 >> 웹 호환성과 웹 접근성
				: 웹 호환성 >> 모든 브라우져에서 동일한 정보 표시
				: 웹 접근성 >> 어떤 상황에서든 쉽게 웹 사이트 활용

프록시 서버 Proxy Server
	: 대리 서버. 
	: 클라이언트와 서버 사이에서 데이터를 전달해준다. 매개체 같은거다.
	: 프록시 서버의 초기 목적 __ 인터넷 속도의 향상.

ip : 네트워크 상의 서버의 위치
port : ip 내에서 "프로세스" 구분을 위해 사용하는 번호

HTTP : 하이퍼텍스트 전송 프로토콜.
	: 클라이언트와 서버 간의 통신 규약으로, html 같은 리소스를 서버로부터 클라이언트가 받을 수 있게 해준다
		: 주의 ) 서버에서 클라이언트 쪽으로만 http 프로토콜이 적용되는게 아니라 클라이언트가 서버 쪽으로 요청할떄도 http 프로토콜 적용되는거

	: 텍스트의 형식으로 정보를 주고 받는다
		: 왜 바이너리가 아닌 텍스트 형식을 사용하는가? OS 마다 바이너리 파일의 처리가 다르기 떄문이다

	: 문서가 한꺼번에 request 되는게 아니라 텍스트, 이미지, 비디오 등이 개별적으로 요청되고, 이들이 모여서 완전한 문서가 재구성되는거다

	: 종류
		HTTP request >> 클라이언트가 서버 쪽으로 보내는 패킷. 메세지
		HTTP response >> 서버가 클라이언트 쪽으로 보내는 패킷. 메세지

request , response : 주의 ! 클라이언트가 서버에게 데이터를 보내는 것은 죄다 request 라고 한다. 그러니까 form 제출하는 것도 request 이다. 


HTTP 메시지의 구성
	: https://hazel-developer.tistory.com/145
	: https://velog.io/@teddybearjung/HTTP-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-%ED%95%B5%EC%8B%AC-%EC%9A%94%EC%86%8C
	1. HTTP헤더 : 본문(body)에 대한 부가적인 정보(메타 데이터)를 담는다
		: 주의 ) body 가 항상 있는건 아니다.
		: 내부 구성
			(1) general header 
				: 요청 및 응답 메시지 모두에서 사용 가능한 일반적인.공통적인 헤더 항목  . HTTP 통신에 대한 일반적인 정보를 포함(본문 컨텐츠와 딱히 관련은 x).
				: 포함하는 대표적인 정보들
					1. Content-type : "본문"의 MIME 타입을 나타냄
					2. Connection : 클라이언트와 서버의 연결 방식 설정. 
						: keep-alive 가 기본 값이다
					
			(2) request header 혹은 response header 
				: request header >> 웹 브라우저가 웹서버에 요청하는 것을 텍스트로 변환한 메세지들 
					: 포함하는 대표적인 정보들
						1. request line : request header의 첫줄을 의미한다.
							: "메서드 URI HTTP버전" 의 형식이다
								: 메서드는 get post 같은
								: URI는 /index.html 같은. 만약 get 방식으로 데이터가 보내진다면 이 부분에 실려서 보내지게 된다.
								: HTTP 버전은 HTTP/1.1 같은
							
						2. host : 요청하려는  서버도메인.포트번호
						3. accept : 클라이언트가 처리 가능한 MIME 타입 종류

				: response header >> 웹 서버가 클라이언트에게 응답하는 컨텐츠가 들어있는 메세지
					: 포함되는 대표적인 정보들.
						1. response line : response header의 첫줄을 의미한다.
							: "HTTP버전 상태코드" 의 형식이다
								: 상태코드
									"200 ok" : 요청 성공적 처리
									"400 Not found" : 요청 파일 존재 안함
									"400 Bad request " : 요청방식 잘못됨


			(3) entity header : 본문에 대한 중요한 정보를 포함한다

 
	2. HTTP 바디 : 해당 요청 대한 실제 메시지/내용 (html 코드. 이미지 등)
		: 항상 있는건 아니다. body 에 담을 내용이 있어야 존재한다.


Payload 페이로드	
	: https://velog.io/@robinyoondev/Request-Payload%EC%97%90-%EC%A0%95%EB%B3%B4%EA%B0%80-%EA%B7%B8%EB%8C%80%EB%A1%9C-%EB%85%B8%EC%B6%9C%EB%90%98%EC%96%B4%EB%8F%84-%EB%AC%B8%EC%A0%9C%EA%B0%80-%EC%97%86%EC%9D%84%EA%B9%8C
	: 전송하고자하는 본질적인 데이터 "자체" 를 의미한다
	: 주의 ) 	
		1. 전송의 목적이 되는 데이터의 일부분으로 함께 전송되는 헤더와 메타데이터와 같은 데이터는 페이로드와 별개이다. 이러한 것들은 택배 보낼떄 상품과 함께 보내는 뾱뾱이 같은거다
		2. 페이로드는 Http header 나 body 처럼 특정 영역이 아니라, "데이터"를 의미하는것이다
			: get 방식의 경우 payload 는 header 부분에 포함되어 오는거다. post 방식의 경우 body 에 담겨지겠지.


MIME Multipurpose Internet "Mail" Extensions 
	: 텍스트 기반 프로토콜에 바이너리 데이터를 전송할 수 있도록 (텍스트로) 인코딩하는 방식
	: 미디어 타입 이라고도 한다.
	: 초기 목적 ) "이메일" 시스템이서 다양한 형식의 데이터를 전송하기 위해 도입
	: 요즘 ) 클라이언트와 서버가 표준화된 방식으로 데이터 교환하게 하기 위해 사용
		:  HTTP 와 함꼐 "웹" 상에서 다양한 형식의 데이터를 전송하는데 사용됨	
		:  서버가 MIME 방식으로 패킷을 전송할때, 해당 데이터와 함께 "HTTP 헤더"에 content-type "헤더"가 포함되어 전송되고,  클라이언트(브라우저)는 이 content-type 을 확인하여 해당 파일의 처리 방법을 결정하게 된다. 
			: content-type : MIME 의 유형을 나타내는 정보
				: 형식) "큰카테고리/세부종류 " << 암기 tip : Text Html ONG
					ex :  text/html , image/png, audio/mp3,  
			: HTTP request, response 헤더 둘다에 포함되는 거다


request, response
	: 웹 브라우저 <-- WAS( webserver +webcontatiner ) ---> DB



웹브라우저
	: 목적 >> "웹 서버"에서 "HTML 문서"를 읽어서 화면에 "웹 페이지"로 표시하는 것
	: 현재는 "표준화" 가 많이 진행되었다


Hyper Text  : 순차적이냐 관계 없이 다른 문서로 이동 시켜주는 텍스트

Markup Language
	: 문서의 논리적 구조와 배치 양식에 대한 정보를 표현하는언어 (텍스트에 태그를 붙여서 텍스트가 문서의 어디에 해당하는지 기술한 것)
	: https://m.blog.naver.com/ycpiglet/222106807034

마크업 언어의 역사: SGML --> HTML -->XML 
	: HTML 보다 XML 이 더 나중인거 주의
	: json 은 마크업 언어랑 약간 다른 결이다


XML eXtensible Markup Language
	1. 데이터를 편리하게 주고 받기 위해 해당 데이터의 구조를 나타내는 양식
	2. 다른 마크업 언어를 만드는데 사용되는 다목적 마크업 언어. 사용자가 직접 태그를 정의할 수 있다

	: 주의) HTML 처럼 데이터를 보여주는 목적으로 사용되는게 아니라. 데이터를 저장하고 전달할 목적으로만 사용된다.
	: 태그 라는 형식을 사용한다


JSON : 얘도 XML 과 마찬가지로 데이터를 편리하게 주고 받기 위해 해당 데이터의 구조를 나타내는 양식이다. 그런데 얘는 js 기반이고, 태그를 상용하지 않는다


DTD Data Type Definition 문서형 정의
	: (SGML 계열의 마크업 언어에서) 해당 문서가 어떤 형식인지 정의하는데 사용된다
	: HTML 의 경우 <!DOCTYPE html> 이 이에 해당한다


DOM Document Object Model 문서 객체 모델
	: https://geniee.tistory.com/32	
	: "HTML" 을 브라우져가 이해할 수 있도록 만든 Tree 자료구조. "HTML" 문서에 대한 인터페이스.
		: DOM 은 HTML 이 아니다. DOM 은 HTML 문서를 구조화한 표현이다.

	: "JavaScript"를 통하여 DOM 을 "동적"으로 수정할 수 있다.

	: 브라우저의 렌더링 과정 ) 
		: 렌더링 >> html , css , js 로 작성된 문서를 "파싱"하여 브라우저에 시각적으로 "출력"하는 것
			

Token 토큰 >> 의미가 있는 어휘 분석의 단위
Parse Tree >> 토큰으로 이루어진 트리
Parsing 파싱 >> 문자열을 "토큰"으로 분해하고, 그들 사이의 관계를 분석하여 parse tree 를 생성하는 과정.
Parser >> 인터프리터나 컴파일러의 구성 요소 중 하나로, 소스코드를 읽어들여 파싱을 수행하는 프로그램.



컴파일러 : 하나의 언어를 다른 언어로 번역하는 번역기
	: https://untitledtblog.tistory.com/9
	: https://seungjoon.tistory.com/20
	: 구성 요소
		1.  분석기 --> 프론트엔드
			(1) 어휘 분석기 Lexical Analyzer>>  소스 코드를 regular expression 따라 문법적으로 의미있는 부분을 token 화 하는 분석기.
				: 얘가 syntax error 잡아낸다

			(2) 구문 분석기 Syntax Analyzer >> 어휘 분석기에서 생성한 토큰을 구문 트리(Syntax Tree 혹은 Abstract Syntax Tree)로 만듬( == 파싱)  . 토큰 간의 관계를 검사.
				: 구문 트리 >> 토큰들을 노드로 갖는 트리. 토큰"간"의 관계를 나타낸다
				
			(3) 의미 분석기 Semantic Analyzer >> 구문 트리 와 심볼 테이블을 활용하여 중간 표현.중간형식(IR Intermediate Representation)을 생성. 의미적으로 올바른지 검사.
				: https://darrengwon.tistory.com/776
				: IR 중간표현. 중간형식 != 중간 언어
					: 중간 표현 >> 프로그래밍 언어를 어셈블리어로 변환하기 위한 표현
						:컴파일러 내부적인 중간 언어라고 보면 된다	 
					:  중간 언어 >> 프로그래밍 언어를 기계어로 변환하기 위한 표현. 어셈블리어.
					: 그러니까 프로그래밍언어 -->ir --> 어셈블리어--> 기계어

		2. 코드 생성기 --> 백엔드
			: 생성된 중간 표현을 어셈블리어(중간언어) 혹은 기계어로 변환.



Regular Expression 정규표현식
	: https://hamait.tistory.com/342
	: https://velog.io/@rosa_5eau/TIL-Day27%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D
	: 패턴을 정의하는 수식
	: 장점 ) 복잡한 코드를 간략하게 작성 가능하다
	: 자바 스크립트에서 정규 표현식은 / 로 시작하고 끝난다.
	: 메타문자 >> 정규 표현식 내에서 특별한 용도로 사용되는 문자
		: 암기 tip : ^ 제외 메타 문자들은 해당 표현의 뒤에 명시한다. (^ 만 특별히 예외적인건 시작을 의미하는 ^ 로 시작하는게 더 가독성이 좋을거니까)
		: 주의 >> 한 문자 혹은 그룹에 대하여 동시에 2개의 연산자가 적용할 수도 있다
			ex) /^a+/ 는 a 로 시작하면서도 1개 이상의 a를 허용한다.
		1. [ ] 관련 : 대괄호 내부의 한 문자(OR)
			: 단어 단위로 or 연산 적용할 떄는 [ ] 가 아닌 ( 하하|허허 |ㅎ호 ) 를 적용해야하는거 주의  
			[xyz] : x y z 중 문자 하나
			[0-9] : 0 ~ 9 의 숫자 문자 중 하나
			[a-z] : 알파벳 소문자중 하나
			[A-Z] : 알파벳 대문자 중 하나
			[a-zA-Z] : 알파벳 중 하나 << 소문자가 먼저임을 주의
		
		2.[^ ]관련 : 대괄호 내부에 있는 문자들을 제외한 모든 문자
			: ^ 뒤에 올 수 있는건 1 과 같다.
			: ex) [^0-9] 는 숫자를 제외하고 모든게 다 가능하단 말.

		3. { } 관련 : 문자의 반복
			x{n} : x 문자가 n 번 반복
			x{n,} : x 문자가 n 번 이"상" 반복
			x{n,m} : x 문자가 n 번 이상, m 번 이하 반복됨

		4. n 번 이상 반복 관련
			x* : x가 0번 이상 반복
				주의 ) "어쩌구*저쩌구" 쓴다고 "어쩌구fsdfdsfew저쩌구" 가 가능한게 아니다. 앞에 n 번이상 반복 가능하게 할 문자를 명시해야한다. 이런 경우 '.*' 이 유용하겠지.

			x+ : x가 1번 이상 반복
				주의
					1. 특정 문자가 1 번이상 반복된다는 뜻으로 쓰이는거지, 문자와 문자를 잇기 위해 쓰는게 아니다.
					2. (어쩌구)+의 경우 어쩌구 "패턴"이 n 번 "연속으로" 반복되는 부분을 인식하겠단 소리지, 어쩌구가 한번 이상 나오고, 그 뒤에 암거나 붙어도 된다는 말이 아니다.
						ex) /(apple)+/ 일떄 appleappleapple 은 그 자체로 인식이 잘 되지만, appleeeee 에서는 앞의 apple 부분만 인식된다.

		5. 시작과 끝 관련 << 정규 표현식 자체의 시작과 끝이 아니라 검사 당하는 대상의 시작과 끝을 의미하는거임 주의
			^x :문자열이 x로 "시작"한다
				:[ ] 의 내부에서 쓰이는 ^ 와는 다른 의미이다.
			x$ : 문자열이 x로 "끝"난다

		6. 그룹화	
			: https://velog.io/@gil0127/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D-Regular-expression
			(  )  : 그룹화 및 "캡쳐"
				: 작동방식
					1. 일단 ( ) 내부의 표현식 마다 복사본같은걸 떠둔다
					2. 별일없었던것처럼 , ( ) 표현을 포함하여 , 검사한다.
					3. 검사를 마친후, "추가적"으로 아까 떠놨던 복사본들을 기준으로 각각 다시 검사를 한다. 
						ex)  /(\d+)(\w)/ 로 '123abc' 를 검사한다고 하자
							(1) "\d+" , "\w" 표현식 각각에 대한 캡쳐본을 떠둔다.
							(2) 별일 없었던것처럼 검사를 한다. 123의 경우 1개 이상의 문자이니 여기까지는 (\d+) 에 대응되고, a 의 경우 (\w) 에 대응되니 123a 가 결과값이 된다.
							(3) "\d+" , "\w" 표현식 각각에 대하여 검사를 한다.  "\d+" 에 대응되는 123 이 결과로, "\w" 에 대응되는 a 가 결과값이 된다.


							
 
			(?:패턴) : 그룹화만. 
				: 캡쳐기능으로 인한 부수적인 결과값을 얻고 싶지 않은경우사용한다.

			패턴A(?=패턴B) : 페턴B의 바로 앞에 패턴A 가 있을때 패턴"A"를 반환한다.

			(?<=패턴A)패턴B : 패턴A의 바로 뒤에 패턴 B가 있을때 패턴"B"를 반환한다. 

			(패턴1|패턴2|패턴3 .. ) 
				: 해당 패턴 중 암거나 하나

		7. 이스케이프 문자 갬성
			\d : 숫자. (digit) 
			\D : 숫자가 아닌것. (non digit)
			\s : 공백문자 (space)
			\S : 공백문자가 아닌것( non space )
			\w : 문자 하나( _ a-Z 혹은 0-9 ) (word character)
			\W : 문자가 아닌것. (non word)
			\b :  경계 boundary
				: 정규 표현식에서 경계란? >> \w 와 \W의 경계. 그러니까 [ _a-zA-Z0-9] 와 [^_a-zA-Z0-9]  가 만나는 지점. 
			\B : \b 가 아닌 상황
			\t : 탭 
			\n : 줄바꿈		
			\특정특수기호 : 메타문자로 쓰이는 ^ $ * + ? { } [] \ | ( ) 에 대해선 \ 쓰고 써야된다.
				: 주의 ) 쌩 정규표현식 표면에서와 ( ) 내부 에서는 이스케이프 문자처럼사용해야하지만, [ ]  내부에선 해당 특수문자 그대로 사용할 수 있다
					: 또 주의 ) 하지만 ^ 의 경우 [^ ] 처럼 맨 앞에 오면 특수한 의미를 띄게 됨으로 이스케이프 문자 없이 쓰고 싶으면 중간에 끼워넣어야된다. 

		8. 기타
			.  : 아무 문자나 딱 1개
				: 주의
					1. 줄바꿈은 문자로 취급 안한다!
					2. 공백은 문자로 취급된다 !
			

			x? : x가 최대 1개( 그러니까 1개 혹은 0개 )
				: ( ) 내부에서 쓰이는 " ?: " 와는 다른 의미이다.
			x|y  : x or y
				: 보통 ( ) 의 내부에서 쓰이는 편

	: flag : 옵션으로, 정규식 표현 끝( "/어쩌구/" 의 바로 다음에 ) 에 명시한다
		0. 아무것도 명시 안함 >> 입력으로 주어진 문자열에서 정규식으로 최초로 일치하는 부분만 찾음 && 엔터를 기준으로 각 행을 처음과 끝으로 인식하는 그런거 없고, 걍 전체에서의 처음과 끝을 처음과 끝으로 인식함
		1. g : Global >> 문자열에서 일치하는 부분을 모두 찾음	
			ex)  /./g 인경우 입력으로 주어진 모든 문자가 선택된다. 
	
		2. i : ignore case >> 영어 대소문자 구별하지 않고 일치
		3. m : multi line >> 다중행모드를 활성화 한다. 엔터를 기준으로 각 행 단위로 시작과 끝을 인식한다.

	: 수량한정자 >> 메타 문자 중에서 수량을 한정하는데 쓰이는 메타문자를 의미
	: 뇌피셜인데 
		>> .* == 가능한 최대치로 get.
		>> (?=.*패턴) 
			: 문자열이 패턴을 포함하는지만 true, false 로 검색해낸다.
				: 그러니까 (?=.*패턴1).* 의 경우 패턴1을 포함하는경우 문자열 전체를 표시하게 되고, 패턴1을 포함하지 않는다면 문자열 전체가 표시되지 않는다.
			:  원리를 모르겠다.
		>> .* 썼을때 /n  == '' 에 대응되는 것 같다.

	: 대표적인 정규표현식
		: https://hitomis.tistory.com/68
 		1. 전화번호 검증 :  /^\d{2,3}-\d{3,4}-\d{4}$/
		2. 이메일 검증
			(1) /\S+@\S+\.\S+/
				: 끝에 + 안빼먹게 주의
				: 소문자 s 가 아니라 대문자 S 임을 주의
				: 그냥 . 이 아니라 \. 임을 주의

			(2) /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/

		3. 비밀번호 검증
			: https://velog.io/@gil0127/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D-Regular-expression
			: https://kin.naver.com/qna/detail.naver?d1id=1&dirId=1040202&docId=468186271&scrollTo=answer1#
			(1) 특수문자, 문자, 숫자 포함 형태의 8 자리 이상의 암호 
				^(?=.*[a-zA-Z])(?=.*[!@#$%^*+=-])(?=.*[0-9]).{8,15}$
					: (?= ) 의 앞에 아무 문자 없는데 잘 적용되고,  
BNF Backus-Naur Form 
	: 컴퓨터 언어의 문법을 수학적인 "수식"으로 나타낼 때 사용하는 언어(도구) 




Lex 와 YACC
	: https://blog.naver.com/oidoman/220930978312
	: https://nlp.jbnu.ac.kr/CD/ch13.pdf
	:  번역기 제작 시스템(translator writing system)	>> (어휘 분석, 구문 분석, 코드 생성 등) 컴파일러의 "한" 단계(phase)를 자동으로 생성해주는 시스템
		: 컴파일러 생성기 혹은 컴파일러 자동화 도구는 아니다 ! (컴파일러 자체를 생성해주는 프로그램)과는 다른거다

	: Lex는 Scanner 역할을 하여 입력 문자열에 대한 일차적인 검색을 하고, Yacc 가 Parser 역할을 하여 실제적인 분석을 하게 된다.

	Lex : 어휘 분석기 "생성기" . scanner generator.
		: 입력에 대해 정규 표현식에 해당하는 부분을 토큰화 하는 역할을 한다
			: 이 정규 표현식은 유저에 의해 명시된다.
		: 컴파일러의 구성에서 Lexical  analyzer 에 대응한다고 봄 된다

	YACC Yet Another Compiler Compiler 구문 분석기 "생성기". parser generator
		: 토큰 간의 관계를 분석해  parser 를 생성하고, parse tree 를 만든다.
		: 컴파일러의 구성에서 Syntax  analyzer 에 대응한다고 봄 된다


컴퓨터 언어를 개발하는 법
	step1. 문법을 BNF 로 수식화 한다
	step2. 생성된 수식을 바탕으로 Lex 와 YACC 를 사용하여 자동생성한다


웹 앱 vs 네이티브 앱
	: 웹 앱>> 하나의 버전으로 모든 플랫폼에서 실행가능하게 한 앱. 
		: 버전 업데이트는 빠르고, 실행 속도는 느림
	: Native app >> 플랫폼 맞춤으로 제작한 앱. 
		: 버전 업데이트는 느리고, 실행 속도는 빠름
		: 앱 마켓 통한 배포 필요




HTML Hyper Text Markup Language
	: 하이퍼 텍스트 마크업 언어
	: 웹 페이지를 기술하기 위한 마크업 언어
	: 여러 버전이 있지만 그중 HTML4 (==XHTML)가 굉장히 중요
		: XHTML 의 실패 원인: 너무 복잡함

	: HTML5
		: HTML5 의 주요 개발 원칙
			1. 외부 플러그인 최소화 << 보안 차원
			2. 오류 표시 기능 향상
			3. 장치 독립적 설계(다양한 기기 지원)
			4. 투명한 개발과정 공개
			5. HTML, CSS, DOM, JavaScript 기술에 기반을 둔다.

		: HTML5 신기능
			1. 오프라인에서도 가능 >> 게임 오프라인에서도 가능
			2. 위치정보제공 
			3. 웹소켓 api >> 양방향 통신
			4. 드래그앤 드롭

	: tag ,  element , attribute 란?
		: 태그 : <p> , </p> 같은거
			: html 에서 태그명 쓸때 대소문자 모두 쓸 수 있지만,  대부분 소문자로 표기한다. 
			: 자식 태그, 부모 태그를 가질 수 있다
			: 시작, 닫는 태그 사이의 연속된 공백은 하나의 공백으로 취급한다
				: 그러니까 스페이스 연속 두번 == 스페이스 한번 친거
			: !! 닫는 태그가 없는 경우도 있다 !!
				<br> , <img> , .. .


		: 요소 element )  태그로 이루어진 html 문서의 구성 요소	
			: 종류 >> 어떠한 display값을 가지냐 따라 요소의 종류가 갈린다
				: https://www.daleseo.com/css-display-inline-block/
				1. block element >> 한 줄을 다 차지(줄바꿈 일어남) . display 값이 block 이다.
					: width, height,margin, padding 모든 방향 설정 가능
						: line-height 는 사용 불가

				2. inline element >> 한 줄에 차례대로 표시(줄바꿈 없음). display 값이 inline.
					: 특징 >> 인라인 박스의 높이 자체는 직접 설정 불가하다
						: 생각해보면 좀 그런게 한  줄이 들쭉날쭉 하면 좀 그렇자너
						: 주의 ) 그 인라인 박스 내부에서 텍스트 등의 컨텐츠 높이는 설정할 수 있다
						
						(1) "width", height 속성은 아예 무시된다

						(2) margin , padding 속성은 좌우 에 한해 반영 "가능하다"
							: 상하는 반영 안되는거 주의

						(3) line-height 속성 
							: 인라인 속성 버전의 margin-top , margin-bottom 같은 느낌이다.
								: 실제로 margin-top, margin-bottom 값을 변경시키는건 아니고, 인라인 박스의 위 아래 영역인 "leading" 영역을 line-height 만큼 증/감시키기에  그런 효과가 나는 것처럼 보여지는거다.
							: 주의 ) line-height 값은 leading 영역 높이+텍스트 높이다. 그러니까 line-height 높이 = 50px ,텍스트 높이 = 10px 라고 했을떄 half-leading 이 25px 가 되는게 아니라, 10px 를 제한 20px 가 된다는 얘기다.
							: line-height 값을 해당 인라인 요소를 포함하는 외부 컨테이너의 height 와 같게하면 해당 인라인 요소는 해당 외부 컨테이너의 세로 정중앙 정렬이 된다



						(4) border 속성 : 이건 상하좌우 다 가능
	
				3. inline-block >> 외부적으로는 inline 의 속성을 따르면서 내부적으로는 block 의 속성을 따름
					: 순서(block-inline 이 아님) 암기 TIP >> Im the Boss
					: 한 줄을 다 차지하지 않으면서도  width, height,margin, padding 모든 방향 설정 가능
					: 대표 >> button, input, select


				
		: 속성 attribute
			: 요소에 대한 추가적 정보를 제공한다
			: 값으론 작은 따옴표 뿐 아니라 큰 따옴표도 사용 가능하다. 근데 작은 따옴표 쓰는걸 추천한다
			: style 속성에 할당하는 값의 형식(":")과 속성 자체에 할당하는 값의 형식("=") 헷갈리지 x
				<li style="list-style-type:none;"> 이라고 해서 <li class:"c1"> 인게 아니다
			: 전역 속성 ) 대부분의 태그가 가지고 있는 속성
				1. class >> 요소에 클래스 부여 
				2. id >> 요소에 고유식별자 부여 
					: id 속성 자체는 그 요소에 고유 식별자를 부여하기 위한 속성이고, 이렇게 생성된 고유식별자로 그 태그를 활용할때는 id 속성이 아닌 다른 속성(href 같은)을 사용한다.
					: id 속성값이 "#아이디명" 이 아니라 단순 "아이디명" 임 주의

				3. style >> 인라인 스타일 적용
				4. title >> 추가 정보 혹은 툴팁(==보조설명. 말풍선)으로 사용


	: 레이아웃 관련한 속성
		border 경계관련
			border : "스타일"을 한꺼번에 설정
				: 할당하는 값 >> '굵기 모양 색상'
				: collapse 여부까지는 지정 못함 주의

		padding
		margin



: 시맨틱 웹 semantic web
	: "의미"론적인 웹. 컴퓨터가 사람처럼 웹페이지를 이해하고 가공할 수 있게 만든 웹. 웹 3.0
	: 목표 >> 컴퓨터가 사람처럼 웹페이지를 이해하고 가공할 수 있도록 하는 것.
	: 시맨틱 웹은 "문서의 구조" 를 알고 있다

: 시맨틱 요소
	: "의미"가 부여된 요소
	: 웹 표준에서 사용을 적극 권고함
	: 사용이유
		1. 검색엔진 최적화 << 개발자의 의도대로 해당 문서를 검색엔진이 해석한다
		2. 웹 접근성 <<시각 장애인의 스크린 리더기가 더 정확하게 읽는다
		3. 유지보수 << 각 영역의 의미 파악이 쉬워 수정이 쉽다
	: 대표 종류
	<header> 머릿말
	<nav> 네비게이션 링크
	<aside> 사이드 바와 같이 옆에 위치하는 내용
	<footer> 문서 꼬릿말
	<section> 문서의 섹션
	<article> 문서의 내용이나 블로그의 포스트

	
: 시멘틱 요소 잘 안쓰는 이유
	: https://kin.naver.com/qna/detail.naver?d1id=1&dirId=1040205&docId=251162248&enc=utf8&kinsrch_src=pc_tab_kin&qb=7Iuc66eo7YuxICDslYjsk7DripQ%3D&rank=13&search_sort=0&section=kin.qna_ency_cafe&spq=0
	1. 기존 개발자들이 시멘틱 요소보다 div , span 과 같이 익숙한 태그를 더 많이 사용함
		: 대한민국은 한떄 웹 표준을 준수하지 않은 IE 를 대부분 썼고, 이를 기반으로 포털사이트 들이 개발되었기 때문에 이를 모두 수정하기는 어려워 기존에 쓰던 div 와 같은 태그를 쓴다.
	2. 시멘틱 요소를 써도 아직 검색 엔진 상에서 그 의미가 반영되지 않음

: non-semetic 요소
	: 컨테이너 태그 >>  페이지를 "논리적인" 섹션으로 분리하는데 사용되는 태그
		<div>  블록 레벨 컨테이너 태그 . 
			: 블록 레벨의 태그라는거지, 내부적으로 블록 레벨 요소만 포함 가능하단 말이 아님을 주의

		<span> 인라인 레벨 컨테이너 태그 . 



	: 초 기본 태그
		1. <!DOCTYPE html>
			: DTD Data Type Definition 을 html5 로 정의 
			: <html> 밖에 작성
		2. <!-- -->
				: 주석

			: <html>
				: html 파일의 문서 전체(시작~ 끝)을 나타냄
				: 크게 내부 영역은 크게 <head>  와 <body> 로 구분됨

			: <head> :  html 문서 대한 정보를 정의한다 (= meta 데이터 담는 컨테이너)
			: <body> : html 문서의 본문 정의
			: <meta charset="utf-8"> : 브라우져에게 현재 html 문서의 인코딩 방식을 알려준다
				: UTF-8 >> 유니코드의 일종으로 가변길이 문자 인코딩 방식이다.
					: 가변길이 >> 글자마다 바이트 크기가 일정하지 않고 1, 3 바이트 왔다갔다
 				: head 에 담긴다






	: html에서 특수 문자 사용하기
		: 주의) 그냥  < , > , " , & 만 써도 출력 자체는 잘 된다
		&nbsp; : 공백문자 , None Breaking SPace.
		&lt; : 왼쪽 꺽쇄(<) , LefT
		&gt; : 오른쪽 꺽쇄(>),  riGhT
		&quot; : " , QUOTation
		&amp : & ,  AMPersand


	: 화면에 텍스트를 표시
		1. 그냥 태그없이 씀 
			: 출력 잘 되는데 html 코드 상으로 엔터를 입력했다고 해서 웹 브라우져 상에 줄바꿈으로 표시되지 않는다
			: html 은 구문 오류 검사가 미흡하다 . 심지어 html 의 바깥에 쓴 텍스트도 출력 잘 된다

		2. 태그 사용
			(1) <p> : paragraph .
				: 단락(=문단)의 "전" "후"에 빈줄이 추가된다

			(2) <br> : line break 
				: "강제' 줄바꿈 태그  

			(3) <pre> : Preformatted text
				: 프로그래머가 입력한 그대로 화면에 표시+ p 태그 처럼 해당 콘텐츠의 전 후에 빈 줄이 추가된다

	: 제목 <hn>
		: heading . 머릿기사. 제목
		: n == 1 ~ 6
		: 기본적으로 굵게 표시된다

	: 수평선 <hr>
		: horizontal.
		: 주의 ) <hr> , </hr> 쌍으로 쓰이는게 아니다. 
			: <hr> 어쩌구 </hr> 쓴다고 해서 에러가 나는건 아닌데 이런다고 해서 어쩌구의 위 아래로 수평선이 생기는게 아니라 어쩌구 <hr> 부분만 수평선이 생긴다
			: 대부분 <hr/> 의 형태로 사용하긴 한다

	: 텍스트 서식 + 의미 강조
		1. <b> bold : 글자를 단순 굵게 표시
		2. <strong> : 글자를 굵게 표시 + 강조의 의미 >> 브라우져가 해당 부분을 중요한 부분으로 인식한다
			: <st>  뭐 이런게 아니라 찐으로 <strong> 임을 주의
		3. <i> : 이텔릭체. 해당 글자를 단순 기울여서 표시
		4. <em> : emphasize.그러니까 의미 강조인데 기울임을 곁들인.
		5. <code> : 해당 컨텐츠가 컴퓨터 코드의 일부분임을 나타낸다
		6. <sub> : 아랫첨자를 표시한다
		7. <sup> : 윗 첨자를 나태난다



	: 리스트 관련
		리스트:  항목들을 나열하는데 사용

		자주 안쓰는 부모 태그와 그의 자식 태그
			부모 <dl> : description List:  용어와 그에 대한 설명을 정의하는 리스트.
			자식 <dt> , <dd> : 둘다 앞에 불릿은 안붙음 && dd 의 경우 인덴테이션은 들어감
				<dt> Description Term : 용어 혹은 key 를 정의
				<dd> Descprion Data : 용어에 대한 설명 혹은 Value를 정의
			
			: ex) 
				<dl>
					<dt>너의 직업</dt>
					<dd>백수</dd>
				</dl>

		자주 쓰는 부모 태그 :
			<ol> : Ordered List. 번호 있는 리스트
			<ul> : Unordered List. 번호 없는 리스트. 순서가 중요하지 않은.
			
		<ol> , <ul>의 자식 태그 <li> : 리스트의 각 항목을 나타냄
			: 주의 ) <dl> 의 각 항목을 나타내는 자식 태그는 <li> 가 아니다

		불릿 : "ul" 로 정의했을때 생기는 똥글뱅이 같은 글머리 "기호".

		: 불릿 스타일 변경 방법 >> list-style-type 속성을 활용
			: 아래 ul, ol 태그 별로 정리했고 그게 권고 사항인 것 같지만 직접 해보면 ul 이든 ol 이든 구분없이 잘 적용된다
				: 어쩄뜬 li 태그에 적용하는건 아님을 주의

			: ul 태그의 list-style-type 속성에 할당 가능한 값
				1. none : 불릿을 없앤다
				2. circle : ○ (속이 빈 원)
				3. disc : ● (속이 꽉 찬 원)  << 디폴트
					: disk 가 아니라 dis"C" 임 주의
				4. square : ■ (꽉 찬 사각형) 
	
			: ol 태그의 list-style-type 속성에 할당 가능한 값
				1. lower-roman 혹은 upper-roman : 소문자 혹은 대문자 로마자
				2. lower-alpha 혹은 upper-alpha : 소문자 혹은 대문자 알파벳
				3. decimal : 1 부터 시작하는 십진수 << 디폴트
				4. decimal-leading-zero : 앞에 0을 붙이는 십진수 (0부터 시작한다는게 아니라 01 02 , .. 이런식이란 거임)


		: 불릿을 이미지로 대체 >> list-style-image 속성 활용
			: url("경로")를 할당
				: ex) <ol style="list-style-image;url( '경로' );">
				: 주의 ) " " 내부에 " " 또 못쓴다. ' ' 를 써야된다.  or ' ' 내부에 "  " 를 써야된다
 
		: 리스트에서 들여쓰기 없애는 법 >> list-style-position 속성을 활용
			: ul, ol 공통. 할당 가능한 값
				1. outside << 들여쓰기 없앰
				2. inside << default

	: 이미지 삽입 태그 <img>
		: 닫는 태그가 없다 !!!
		: 속성
			src : 해당 파일의 경로 지정
			width , height : 크기 지정
			alt : 이미지가 표시되지 못한 경우에 표시할 대체 택스트


		
이미지의 종류
	JPEG . JPG Joint Photographic Experts Group 합동 사진 전문가 단체 ... ㅋ
		: 손실 압축 방식
		: 투명 배경 미지원
		: 많은 색상으로 이뤄진 이미지에 적합
		: JPEG vs JPG >> 같은 파일 형식인데, 확장자만 다른거다. 옛날엔 파일 확장자가 3 문자 제한 있었어서 JPEG 대신 JPG 를 썼던거다

	PNG 
		: 무손실 압축 방식
		: 투명 배경 지원
		: 적은 수의 색상으로 이뤄진 이미지에 적합

	GIF
		: 색상 ㅈㄴ 적게 지원
		: 움직일 수 있다
		: !! 투명 배경 미지원

icon 아이콘
	: 형식 >> 1. font 2. SVG 3. PNG
		: jpeg 형식은 없다 ! >> 생각해보면 jpeg 는 투명 배경을 지원안하니까
		: font >> 텍스트 취급되서 흐릿하거나 깨져 보일 수  있다
		: SVG Scalable Vector Graphics >> 꺠지지 않는다.



경로(주소) 의 표시 방법
	1. 절대 경로 : 다른 웹 페이지의 풀 경로
		: https:// .. 
		: / 로 시작하는 내 폴더 경로

	2. 상대경로 : 현제 웹 페이지 기준 다른 웹 페이지의 경로
		: / 로 안시작 하는 내 폴더 경로

	3. 내부 경로 : 현제 페이지 "안"의 다른 위치
		: https://jaejong.tistory.com/80
		: 형식 >> #네임명 , #아이디명 . #
			: #은 현재 페이지의 맨 위로 이동

	
	iframe
		: 현재 페이지에 프레임을 만들고 .거기에 다른 웹 페이지를 include 하는 태그
		: 특징
			1. 신뢰성 부족한 외부 URL 의 사용은 추천되지 않는다. (보안 문제)
			2. iframe 은 구식이고, 요즘에는 AJAX 로 기능이 상당부분 대체되고 있다
		: 속성
			src : inlcude 할 파일 경로
			width, height : 프레임의 크기 설정
	
		: Inline FRAME


	: 링크 태그 <a> Anchor
		: 다른 페이지로 링크를 생성할 때 사용한다
			: (하이퍼)링크 == 디른 문서로 점프할  수 있는 "이미지'  혹은 단어
				: 텍스트만 하이퍼 링크가 되는게 아니다
		: 속성
			href : 페이지 경로 지정
				: a 태그의 href 로 줄 수 있는 특별한 값
					1. 이메일 주소와 연결 >> 'mailto:이메일주소'
					2. 전화번호와 연결 >> 'tel:010-2555-4444' 혹은  'tel:01025554444'
					3. 문자보내기와 연결 >> 'sms:01025554444'

			target : 어느 위치에서 링크된 페이지를 열건지 지정
				: https://m.blog.naver.com/mathesis_time/222039284932
				: 할당 가능한 값
					1. _blank : 새로운 윈도우. 탭 에서 오픈
						: 암기 tip >> BLAck piNK
					2. _self : 현재 프레임에서 오픈. << 디폴트
					3. _parent : 현재 프레임의 부모 프레임에서 링크 페이지가 열림 
						: 부모 프레임 >> 다른 페이지의 iframe 을 통해 include 당하는 페이지는, 그 페이지의 해당 프레임을 부모 프레임으로 한다. 
							: 웹페이지A가 a 태그로 하이퍼링크를 생성하고, target 속성이 _parent 라고 하자 . 그리고 웹페이지B의 소스 코드 상의 한 iframe 의 src 값이 웹페이지 A 라고 하자. 단순히 웹페이지A를 실행시켰을때는 target 속성이 _parent 인것을 실감할 수 없다. 그냥 웹페이지A의 전체화면에서 열린다. 이는 당연한 것이 부모 자식이라 할 것이 없기 때문이다. 반면 웹페이지 B를 실행시키고, 웹페이지A 가 나타나는 프레임을 보자. 그냥 봤을떈 일반적인 다른 파일을 include 한 것과 다를게 없어보인다. 하지만 그 프레임에서 target 속성을 _parent 로 지정했던 하이퍼링크를 클릭하면, 새로운 페이지나 웹페이지B전체화면에서 오픈되는 것이 아니라, 해당 프레임 내부에서 링크된 페이지가 오픈되는 것을 확인할 수 있다. 

					4. _top : 최상위 프레임에서 열림. 그러니까 현재 페이지의 모든 프레임이 사라지고, 현제 페이지의 전체화면에서 링크 페이지가 열림
						: 최상위프레임 ) 현재 페이지의 전체 화면.

					5. 프레임명 : 해당 name 을 가진 프레임(iframe)에서 오픈.

		: 밑줄 스타일 설정 
			: text-decoration 속성은 텍스트 자체가 아닌 밑줄의 스타일만 설정하는 것임 주의

			한꺼번에 설정 >> text-decoration 속성
				: 할당 값 >> ' 선위치 선색깔 선모양 선굵기 '

			개별적 설정 
				***text-decoration-line : 선위치설정
					(1) none : 줄을 없앰
					(2) line-though : 가로지르는 줄 . 취소선.
					(3) underline : 밑줄 << 디폴트값
					(4) overline : 윗줄 
				text-decoration-color : 선색깔 설정
				text-decoration-style: 선의 모양 결정
					(1) dotted : 점선 
					(2) solid : 기본값
					(3) wavy : 구불구불
					(4) double : 이중선 
				text-decoration-thickness: 줄 굵기				
	
	: 테이블 관련 
		: 태그에 따라서 쓸 수 있는 속성이 다른거 주의
		: https://m.blog.naver.com/kimnr123/221871986499
		부모 태그 <table> : 테이블을 정의한다
			:  속성 >> border : 테이블 "전반적"으로 경계를 표시할지 결정한다. 1 혹은 0 만 할당 가능하다.
				
			; 적용 가능한 스타일 속성
				1. border : 테이블 "자체"만의 경계를 설정한다. 
					: table 속성이 border="1" 인 경우 셀들에 경계모양, 경계굵기 까지는 적용되지 않지만, 경계색상은 스타일 속성 border 를 따르게된다.

				2. boder-collapse : 테이블의 테두리와 셀의 테두리 사이의 간격을 어떻게 처리할건지 결정
					: 할당가능값
						(1) collpase : 셀과 테이블 사이의 간격을 없앰. 겹치는 부분은 한 줄로 나타냄
							: 그러니까 border-spacing:0px 와 같은 효과이다. 
						(2) seperate : 셀, 테이블 사이에 간격을 둠 << 디폴트값
						(3) initial : 기본값으로 설정
						(4) inherit : 부모 속성값을 상속 받음

				3. border-spacing : 테이블의 테두리와 셀 테두리 사이의 간격을 얼마나 할건지 결정
					: "border-collapse:seperate" 일때만 사용 가능함 주의
					: 테이블 "셀"들의 margin 역할을 하게 된다
						: 테이블 자체에는 margin 줄 수 있다

				4. width, height : 크기 지정
				5. margin , padding : 마진과 패딩 지정


		자식태그 <tr> <th> <tr>, <caption>
			<tr> : 테이블의 row 를 정의한다
				적용 "불"가능한 스타일 속성 >> width 
				적용 가능한 스타일 속성 >> height : 해당 라인 셀들의 높이를 설정
					: 이외의 일반적인 속성 (color, border 등) 도 적용 잘 된다

			<th>,<td> : 테이블의 헤더 셀, 일반셀을 정의한다
				: 주의 ) 
					1. 모든 셀마다 제각각 width, rowspan, colspan 를 설정 가능한게 아니다. 해당 "column" 에서 가장 상위에 위치한 셀의 width 값이 채택된다
					2. 테이블 셀은 margin 설정이 안된다 (table 태그에서 border-spacing 으로 대신 설정 가능)
					3. 테이블 셀은 padding 설정은 된다
						: 뭐 어차피 셀 내부인데 그것까지 간섭하긴 좀 그렇잖아

				속성 << 스타일 속성 아님을 주의 !! 
					: 다른 칸을 잡아먹는게 아니라 해당 칸이 그만큼 자리를 차지하는 거다. (다음칸은 단순히 뒤로 밀려나간다). 그러니까 칸이 생성되었다고 생각함 편하다
					2. rowspan : 아랫 행 방향으로 몇칸 차지할건지 결정
					3. colspan : 오른쪽 열 방향으로 몇칸 차지할건지 결정

				스타일 속성
					적용 "불"가능한 스타일 속성 >> height
					적용 가능한 스타일 속성 >> width : 크기 지정
						: 이외의 일반적인 속성 (color, border 등) 도 적용 잘 된다

			<caption> : 테이블의 제목을 나타낸다
			<thead> , <tbody> , <tfoot> : 테이블 내에서 사용 가능한 시멘틱 태그


웹브라우져와 멀티미디어
	: HTML5 이전
		1. <embed> , <object> 태그를 사용하여 외부 어플리케이션( 오디오, 비디오)를 추가했다
		2. 외부 어플리케이션을 재생하기 위해선 별도의 플러그인이 필요했다

	: HTML5 이후
		1.  <video> , <audio>로 오디오,  비디오 파일을 삽입한다. 
			: 이제  <embed> , <object> 태그는 다른 html 을 포함하거나 플러그인을 설칳하는 용도로만 사용된다
		2. 플러그인 설치 불필요

	: <video> , <audio>
		: width, height 속성 제외 모두 일치한다 << 스타일 속성이 아니라 찐 속성이다
			(1) src : 파일의 경로
			(2) autoplay : 자동재생
			(3) loop : 반복 재생
			(4) muted : 음소거 << 영원히 음소거 인건 아니고, 기본적으로 음소거 된 상태로 표시해주는거지, 플레이어를 통하여 소리 나게 할 수 있다
			(5) controls : 플레이어를 화면에 표시한다
			(6) width, height :  비디오 플레이어의 크기 설정 << video 태그에 한해서 가능하다
			(7) preload : 사용자가 실제로 사용하지 않더라도 비디오를 미리 다운로드 한다
	
		: 자식 태그로 source 를 사용할 수 있다
			: 굳이 사용하는 이유 >> 호환성을 높이기 위하여
			: 사용 방법 >> 부모태그(video, audio) 에 src 를 명시하지 않고, source 태그의 속성 src 로 명시하고, 추가적으로 해당 파일의  content-type 을 type 속성으로 명시한다
				: type 속성은 video, audio 태그에 없었던거다!
				: ex ) 
				<audio controls autoplay muted>
					<source src="movie.ogg" type="audio/ogg">
					<source src="movie.mp3" type="audio/mp3">
    					    Your browser does not support the audio element.
				</audio> 			
			: 끝 태그는 따로 없는 것 같다


비디오 파일의 형식
	1. mp4 << 젤 많이사용하고, 대부분 브라우져에서 지원
	2. Ogg << 대부분 브라우져서 미지원
	3. webm << 나쁘진 않은데 일부 브라우져에서 미지원


스크립트 언어 
	: 소스를 컴파일하지 않고도 실행할 수 있는 프로그래밍 언어
	: 장점 >> 빠르다
	: 웹 개발에 주로 쓰인다
		: python, php, jsp, javascript 등
		: 종류 
			1. 서버 (사이드) 스크립트 : 서버 쪽에서 실행되는 스크립트
			2. 클라이언트 (사이드) 스크립트 : 클ㄹㅏ이언트에 의해 실행되는 스크립트 

입력 양식 == 폼
	: 작동 과정
		0. 클라이언트가 서버에게 입력 양식 요청
		1. 서버가 클라이언트에게 폼 반환
		2. 사용자가 폼에 데이터를 입력하고 서버에 제출(요청)
		3. 서버 가 해당 데이터로 "서버 스크립트"를 통하여 처리
		4. 처리 결과를 반영한 응답페이지 생성ㅇ
		5. 해당 응답 페이지 반환
 
	: 입력 데이터가 서버로 보내지는 방법 >> 요즘엔 restAPI 를 사용한다
		1. get << 확인 필요
			: HTTP request header 부분의 url 뒤에 " ?파라미터1=값1&파라미터2=값2.... " 의 형식으로 붙어서 전송된다. 
				: 그러니까 request header 부분의 request line 의 uri 부분에 포함되어 보내진다.
			: 장점 >> 빠르다
			: 단점 >> 
				1. 용량 제한 
				2. 보안 취약
				3. 바이너리 파일 전송 불가 
					: get 방식의 경우 각 파라미터를 & 연산자를 사용해서 구별하는데 , 바이너리데이터는 이를 데이터로 취급할수 있다. 그러니까 서로 다른 데이터의 구분이 불가능해진다. 
					: https://simsimjae.tistory.com/218

		2. post  << 확인 필요
			: HTTP body 에 담겨서 전송된다. 
	 		: 단점 >> 느리다. body 부분에 데이터를 담아야되서.
			: 장점
				1.길이 제한이 "없다"
				2. 보안이 좋다
				3. 바이너리 파일을 전송할 수 있다.
					: 브라우저가 알아서 서로 다른 데이터 간의 구분을 알아서 해준다.

	<form> :사용자가 입력한 내용을 서버로 보내기 위한 폼을 정의한다
		: 주의) file 을 보내는 form 의 경우 enctype="multipart/form-data" 까지 명시해야된다.			: 			: enctype == 인코딩타입. 폼으로 입력 받은 데이터를 어떤 방식으로 인코딩하여 전송할지 결정한다.	
			: "multipart/form-data" 는 "바이너리 파일"을 보낼때사용한다
				: 이또한 MIME type 이다. martipart 가 큰 카테고리인 것이다.
					: http 헤더의 content-type은 body 에 담겨 보내지는 문서의 타입을 명시하는거고, 지금 form 에서 MIME 타입을 명시하는것은 , 서버로 데이터를 보낼 때 그러한 인코딩방식을 채택하여 보내게하겠다는거다.
			: 기본ㄴ적으로 form 데이터를 보내는데 사용되는 타입은 application/x-www-form-urlenceded  이다. 이 타입은 특정 문자 외에는 %로 인코딩을 하기 때문에 이진 파일을 보내는데 적절하지 않다.
		: action 으로 경로를, method 로 전달 방식을 결정한다. 

	<fieldset>: form 내부 데이터를 그룹핑한다
	<legend> :fieldset 에 이름을 붙인다. (fieldset 의 자식 요소이다)
	<label> : 입략 필드에 레이블을 붙이는 태그
		사용법1. 그냥 해당 태그의 부모태그의 꼴로 사용
		사용법2. 해당 태그와 분리해서 쓰는데, "for" 로 해당 입력 태그의 id 를 명시함 

	<button> : 클릭 가능한 버튼을 생성할 때 사용
		:  type  속성
			(1) sumbit : form 내용 submit << 디폴트이다
				: 이 값이 디폴트라서 form 태그 내부에, type 이 지정되지 않은 button 태그로 정의된 버튼 누르면 submit 되게 된다.
			(2) button : 단순 button 역할
			(3) reset : form 내부 내용 리셋

		: 주의 ) button 에 표시할 내용은 value 속성이 아닌(vlaue 속성이 없다) , 시작 태그 끝 태그 사이에 적어준다
		: https://nykim.work/96

	: 입력 필드를 정의하는 태그
		1. <input> 
		: 인라인 태그인거 +  종료태그 없는거 주의
		: 속성
			1. name : 필드에 담길 값과 바인딩될 파라미터명 결정
			2. placeholder :필드에 미리 "보여질" 값 설정
			3. value : 필드에 값이 담기지 않을 시 기본으로 보내질 값 결정
			4. checked : type="radio||checkbox" 일 경우 사용 가능
				: radio 의 경우 하나의 태그에만 체크 가능한거 주의
			5. accept : type="file"일 경우 사용가능
				:"특정MIME타입1 , 특정MIME타입2 ... " 의 형식으로 작성 가능
				: 어떤 타입의 파일에 한하여 허용할건지 결정한다.
			6. autocomplete
				: 자동 완성 기능 사용 여부 설정 .
				: 할당 갑ㅄ
					"off" : 자동완성 기능 사용 안함
					"on" << 디폴트값

			7. required	: 필수적으로 채워져야함
			8. readonly : 읽기 전용 필드
			9. pattern : 허용하는 입력 형태를 정규식으로 지정
			6. type :
			: 기존부터 있었던 . 중요한 
				(-1) button >> 버튼 정의
				*****: 주의 ) input 태그로 생성된 button 자체는 submit 능력이 없다
				(0) hidden >> 사용자에게 보이지 않게 서버로 전송
				*****: 언제 쓰는가 : 사용자가 수정하면 안되거나. 입력할 필요 없거나 한 데이터를 "폼"과 "함께" 전송해야하는 경우 사용한다
				(1) text >> 텍스트 입력 가능한 한줄짜리 필드 생성
				(2) password >> 비밀번호 입력할 수 있는 한줄짜리 필드 생성. 텍스트가 ● 로 표시됨
				(3) radio >> 라디오 버튼 생성
					: 라디오 버튼 --> 한 카테고리에서 딱 한 항목만 선택 가능
				(4) checkbox >> 체크박스 생성
					: 체크 박스 --> 한 카테고리에서 여러 항목 선택 가능
				(5) file >> 입력할 파일을 선택하는 필드 생성
					: ex) 
					<form enctype="multipart/form-data">
					    <input type="file" accept="image/jpg,image/gif">
					</form>
			********(6) image >> 이미지로 표시되는 "제출"버튼 생성 
					: src 속성으로 표시되는 이미지경로 명시
				(7) submit >> 텍스트로 표시되는 제출버튼 생성
					: value 속성으로 표시되는 텍스트 명시
				(8) reset >> 해당 form 의 모든 입력 필드를 초기화 시키는 버튼 생성.
					: value 속성으로 표시되는 텍스트 명시


			:그다지 필수적이진 않은
				(1) 날짜. 시간 관련
					date : 날짜만 입력 받는 필드
						: value , min , max 를, "XXXX-XX-XX"의 형식으로 줄 수 있다
					datetime-local : 현지 날짜, 시간 
						: value , min , max 를, "XXXX-XX-XXTxx:xx" 의  형식으로 줄 수 있다
					month : 년과 월만 설정할수있는 필드
					week : 년과 월과 주만 설정할 수 있는 필드
 					time : 시간만 설정할 수 있는 태그
						: value , min , max 를, "xx:xx" 의  형식으로 줄 수 있다

				(2) 색깔
					color: 색상코드를 입력 가능
				(3) 특수한 목적의 텍스트
					email : 이메일 주소 필드
					tel : 전화번호를 입력 필드
					search : 검색어 입력 필드
					url : url 입력 필드
				(4)숫자
					range : 슬라이더 컨트롤로 숫자 선택 가능
					number: 숫자 선택 가능
						: max, min , step 속성을 사용해 최댓값 최솟값 단곗값 설정 가능

		2. <textarea> : 다중 라인 입력 필드 
			: 주의 ) 
				1. placeholder 속성 없고, 미리보여줄 문구는 시작 태그와 끝 태그 사이에 적는다.
				2. height, width 속성 없고 세로, 가로 높이 설정하는 건  row"s",col"s" 로 설정한다.

				
		3. <select> : 드롭다운 리스트를 "정의"한다
			: 내부적으로 <option> 자식 태그를 사용하여 드롭다운 리스트의 항목을 만든다.
			: 속성
				1. name >> select 태그에
				2. value >> 각 option 태그에 
				3. multiple >> select 태그에 
			

--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------




	: 태그 총 정리
		(-1) 기본적인
			: <!DOCTYPE html>
				: DTD Data Type Definition 을 html5 로 정의 
				: <html> 밖에 작성
			: <!-- -->
				: 주석

			: <html>
				: html 파일의 문서 전체(시작~ 끝)을 나타냄
				: 크게 내부 영역은 크게 <head>  와 <body> 로 구분됨

			: <head> :  html 문서 대한 정보를 정의한다 (= meta 데이터 담는 컨테이너)
			: <body> : html 문서의 본문 정의
			: <meta charset="utf-8"> : 브라우져에게 현재 html 문서의 인코딩 방식을 알려준다
				: UTF-8 >> 유니코드의 일종으로 가변길이 문자 인코딩 방식이다.
					: 가변길이 >> 글자마다 바이트 크기가 일정하지 않고 1, 3 바이트 왔다갔다
 				: head 에 담긴다

		(0) non-sementic tag
			: 단순히 웹 사이트의 구조를 설계하는데 사용하는 태그
			: 스타일 지정이나 스크립팅 목적으로 필요한 경우를 제외하고는 non-sementic tag 가 아닌 sementic tag 를 사용하도록 하자.

			<div>
				: 대표적인 Block element 이다
				: DIVision 부서. 분할

			<span>	
				:대표적인 Inline element 이다
				: span == 표괄하다.

		(1) sementic tag 
			: https://seo.tbwakorea.com/blog/what-is-semantic-tag/
			: 태그명을 통한 역할 파악이 쉬우면서 <div>, <span>과 같이 웹 사이트의 구조를 설계하는데 쓰이는 태그
				: sementic == 의미론적인. 
				: 스타일 지정이나 스크립팅 목적으로 필요한 경우를 제외하고는 <div>와 같은 의미가 없는 요소나 속성을 사용하지 않아야 한다

			: 이점 
				1. 웹 사이트 검색할떄 필요한 내용을 정확하게 찾을 수 있게 함
					:ex) 본문 내용은 <header>,<footer> 태그가 아닌 <main> 태그 내에서 찾음

				2. 개발자의 코드 이해도가 높아짐
				3. 스크린 리더기가 정확히 읽음

			: 브라우져에 표시할 내용을 구분짓는 역할 하는거라 모두 body 내부에서 쓰인다. 

			< header >
				:헤더 영역(사이트 위에 있는 검색 창이나 메뉴바 같은거 있는곳), 그러니까 일종의 개요를 나타냄.
				: head 랑 다른 테그임 주의
					: head 는 메타 데이터를 대상으로 감싸는 태그고 , 필수적이며,  body 내부에 종속되어있지 않는다.

 
			< nav >  
				: 링크 거는 구간을 나타내기 위해 사용
					: <a>태그 같은거를 포함하게 된다.
				: NAVigation 의 약자

			<main> 
				: 핵심 콘텐츠(내용)이 들어있는 태그.
				: 웹 페ㅔ이지마다 똑같이 들어가는 정보가 아닌 웹 문서마다 다른 내용으로 구성이 된다
				: 한 문서에서 한번만 사용 가능

			<aside>
				:  사이드바 영역(왼 오 아래 바) 표기

			<footer>
				: 웹 문서 맨 아래쪽 콘텐츠 영역 표기

			 
			<article> 
				: 독립적인 콘텐츠를 표시하기 위해 사용하는 태그. 
					: 그러니까 뉴스 사이트에서 특정 기사 하나. 유튜브에서 특정 영상 하나 느낌
				: section 으로 대체 가능하긴 함( 컨텐츠 구분용으로 쓸 수 있긴 함)


			<section>
				: 서로 관계있는 콘텐츠를 분리해 표시하기 위해 사용하는 태그
					: 그러니까 서론 본문 결론 같은거 혹은 1장 2장 3장 같은거. 컨텐츠 목차 느낌.
				: article 으로 대체 가능하긴 함(콘텐ㅊ, 구분용으로)
				: article 로 각각의 컨텐츠를 구분짓고, 이 article 을 각각 section 으로 감싸서 article 간의 목차(?) 그런 느낌으로 관계를 나타낼 수 있다. 

	
		


		(2) 줄바꿈 관련
			<p>	
				: 문단을 표시하기 위해 사용.
				: 기본적으로 앞뒤 줄바꿈이 일어난다
				: Paragraph. 

			<pre>
				: html 파일에 입력한 그대로(== 엔터친거. 스페이스바 여러번 친것까지 반영해서!! ), 화면에 표시하는 태그
				: PREformatted text

			<br>
				: 강제 줄바꿈.
				: 딱히 끝 태그 없음
				: line BReak

		(3) 제목 관련
			<hn>
				: n = 1~ 6 까지의 숫자고( 작을수록 더 큼), 제목 표현 위해 쓰임
				: 기본적으로 앞뒤 줄바꿈 && 굵은 글자
				: Heading.

		(4) 텍스트 서식
			<b>
				: 볼드체
				: Bold
	
			<strong>
				: 강조 +볼드체
					: 강조의 의미가 추가되면
						1. 검색 엔진이 해당 부분을 중요한 부분으로 인식
						2. 스크린 리더기가 해당 부분을 강조하여 읽음 

			<i>
				: 이탤릭체
				: Italic

			<em>
				: 강조 + 이탤릭체
				: EMphasis

			<code>
				: 해당 부분이 소스코드임을 표시

	
			<sup> , <sub>
				: 위 첨자 아래첨자 표시

		(5) 수평선
			<hr>
				: 선 표시
				: Horizontal Rule

		(6) 리스트 : 항목을 나열하는데 사용
			<ol>
				: 순서있는 리스트 정의
				: 속성
					1. style ) 
						: list-style-type 속성에 다양한 값을 할당해 숫자 뿐 아니라 로마자 같은걸 기준으로 설정 가능
							: 그러니까 	<ol style="list-style-type:upper-alpha"> 같은거 가능하단거

						: list-style-type 속성에 할당 가능한 값
							1. upper-alpha >> 대문자 알파벳
							2. upper-roman >> 대문자 로마자
							3. decimal >> 정수

					2. start ) 시작 기준 설정 가능
						: style 이 숫자건 알파벳이건 로마자건 , start 는 숫자로 표현하는거 주의(1부터 시작)
						ex) 	<ol style="list-style-type:decimal" start="10">

				: Ordered List

			<ul>
				: 순서 없는 리스트 정의
				: Unordered List

			<li>
				: 리스트의 원소 정의
					: 순서 있건 없건 상관 없음

		(7) 이미지관련
			<img>
				: 속성
					1. src 
						:자원의 경로 할당

					2. alt
						: 사진 깨질 시 표시할 문구
						: ALTernate text

					3. width, height
						: 너비와 높이 지정
						: width 만 지정하면, 알아서 비율 맟춰주기 때문에 width 만 설정해주는게 좋다
						: px 값, % 값 모두 기준으로 할 수 있다
							: px >> 고정적
							: % 값 >> 브라우져 창 크기따라 가변적


		(8) 링크
			<a>
				: 하이퍼 링크 생성할 때 사용
				: 속성
					1.href 
						: 웹 페이지 경로 나타낸다
						: 경로 tip >> html 에서 경로 잡을 때 상대경로와 절대경로 2가지 모두 이용할 수 있다.
							: 절대 경로 >> 젤 앞에 "/"를 쓴다
 							: 상대경로 >> 젤 앞에 "/"를 안쓴다


					2. target
						: 새로운 페이지가 어떠한 방식으로 열릴지 지정
						: 할당 가능한 값
							1. "_blank"  : 새로운 탭에서 페이지를 연다
							2. "_self" : 현재 탭에서 페이지를 연다 (디폴트)

				: Anchor

		(9) 일반적인 표 관련 태그

			<table>
				: 표 table 정의
					: 표 >> row(=행=가로찍), column (=열=세로쿵) , cell(=셀=한칸) 으로 이루어진다

				: 예시
<a href="https://img.kr.news.samsung.com/kr/wp-content/uploads/2021/07/2021_2%EB%B6%84%EA%B8%B0_%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90_%EC%8B%A4%EC%A0%81_%ED%91%9C-1000.jpg" alt="삼성전자 표"><h2>표2</h2></a>
	<table border="1">
		<caption>2021_2분기_삼성전자_실적_표</caption>
		
		<thead>
			<tr>
				<th rowspan="2" colspan="2">구분</th>
				
				<th colspan="5">2018년</th>
				<th colspan="5">2019년</th>
				<th colspan="5">2018년</th>
				
			</tr>
		
			<tr>
				<th>1Q</th>
				<th>2Q</th>
				<th>3Q</th>
				<th>4Q</th>
				<th>전체</th>
			
				<th>1Q</th>
				<th>2Q</th>
				<th>3Q</th>
				<th>4Q</th>
				<th>전체</th>
			
				<th>1Q</th>
				<th>2Q</th>
				<th>3Q</th>
				<th>4Q</th>
				<th>전체</th>
			</tr>
		</thead>
		<tbody>	
			<tr>
				<td rowspan="7">매출</td>
				<td>계</td>
				<td>60.56</td>
				<td>58.48</td>
				<td>65.46</td>
				<td>59.27</td>
				<td><%= 60.56 + 58.48+65.46+59.27%></td>
				
			</tr>
			
			<tr>
				<td>CE부분</td>
				<td>9.74</td>
				<td>10.4</td>
				<td>10.18</td>
				<td>11.79</td>
				<td><%= 9.74 + 10.4 +10.18+11.79%></td>
				
			</tr>
			
		</tbody>	
	</table>


			<caption>
				: table 의 제목을 나타냄
				: 얘도 table 태그의 내부에 쓰는거 주의

			<tr>
				: table 의 행을 나타냄
				: 행 단위로 셀을 나타내는 태그들을 감싼다
					: 그러니까 td 뿐 아니라 th 도 감싼다
				: Table Row

			<th>
				: table 의 제목"셀"을 나타냄 
					: 그러니까 해당 열의 제목 같은거 들어가고 실제 데이터는 안들어가는 셀들
					: 그러니까 셀이라도 제목 셀이면. <td> 안쓰고, <th> 만 쓰는거.
					: 단순히 젤 윗행의 셀들만 가리는게 아니라 세로 셀도 그런 (?) 제목 셀인 경우 해당 셀은 th 로 생성한다( https://kin.naver.com/qna/detail.naver?d1id=1&dirId=1040205&docId=464133709&scrollTo=answer1# )
					: 기본적으로 텍스트 가운데 정렬 && 굵은 글자 표시된다
				: 속성
					: 사용 tip >> 합치기로 한 부분이면 합침 당하는 셀은 이미 표시한걸로 치는거다.( 그러니까 rowspan="2" 했으면 바로 아랫행의 해당 셀은 생략하고 나머지 셀만 정의하는거고 colspan="2" 했으면 해당 행의 바로 옆 셀은 생략하고 그 뒷 셀만 정의하는거다)
					1. rowspan
						: 행 합치기 (== 아래 방향셀이랑 합치기)
						: 값으로는 몇개의 셀과 합칠것인지 숫자를 (문자열의 꼴로) 할당
						: span ) 가로지르다. 포괄하다 << 합치다 라는 느낌
 
					2. colspan
						: 열 합치기 (== 오른쪽 방향 셀이랑 합치기)
						: 값으로는 몇개의 셀과 합칠것인지 숫자를 (문자열의 꼴로) 할당		
				: Table Head

			<td>
				: table 의 셀을 나타냄
					: 실제로 유의미한 데이터를 나타내는 셀들
				: 속성
					: th 의 속성과 사용방법이 같음
					1. rowspan
						: 행 합치기 (== 아래 방향셀이랑 합치기)
					2. colspan
						: 열 합치기 (== 오른쪽 방향 셀이랑 합치기)
				: Table Data


		


		(6) col
			: (기본) 열 1개 단위로 열의 스타일을 결정
			: void element 라서 닫는 태그 없음 주의
			: 반드시  colgroup 내부에 써야됨
			: 쓸꺼면 모든 열에 대해 col 태그를 명시해야됨
				: 별도로 색깔 너비 같은거 정할 필요없는 열엔 <col> 적는다

			: 반드시 표의 내용이 시작하기 전에 써야됨(== caption 태그가 있다면 caption 태그 바로 다음에 써야됨 )

			: 합침당한열의 경우 해당 열의 젤 앞 셀의 특성을 따른다
			: 속성
				1. style
					:tip >> 문자열 내부의 끝에 모두 세미콜론을 붙인다
					(1) 배경색깔 지정>> "background-color:#색상;" 
						: 색상은 16 진수 형태의 rgb 값을 써야된다.
					(2) 열의 너비 지정>> "width:원하는크기px;"

				2. span
					:  똑같은 스타일을 적용시키고 싶은 열들(바로 뒷 열들의-그러니까 띠엄띠엄 함 안됨)의 갯수 적음
					: ex ) <col><col> == <col span="2">

		(7) colgroup
			: 한테이블의 col 태그를 묶음
			: 반드시 표의 내용이 시작하기 전에 써야됨(== caption 태그가 있다면 caption 태그 바로 다음에 써야됨 )


		(10)표의 구조를 나타내는 sementic 태그
			(1) thead
				: 제목셀 행 전체를 나타냄
					: th 태그들을 감싸는 tr 태그(들)을 thead 가 감싸는꼴
				: Table HEAD

			(2) tbody
				: 데이터셀 행 전체를 나타냄
					: td 태그들을 감싸는 tr 태그들을 tbody 가 감싸는 꼴
				: Table BODY

			(3) tfoot
				: 해당 table 을 요약하는 맨 마지막 행을 나타냄	
					: 그러니까 th 태그들이 아닌 td 태그들을 감싸는 tr 태그 중 가장 마지막 tr 태그(들)을 tfoot 기 감싸는 꼴
					: 전체 데이터 셀 합계 평균 뭐 그런거 나타내는 맨 마지막 행
					: 근데 이런 역할이 없으면 tfoot 시멘틱 태그는 안쓰는거다. 없는데 맨 마지막 행이라고걍 가져다 붙이는게 아니다
			: Table FOOT
		


이미지의 종류
- JPEG
    - 실사사진과 같이 복잡하고 많은 색상으로 이루어진 이미지에 적합
    - 손실 압축 방식을 사용한다.

- PNG
    - 무손실 압축 방식
    - 투명 배경을 지원해서 디자인이나 로고 파일로 많이 사용됨

- GIF
    - 256 색상만을 지원
    - 투명 배경과 애니메이션을 지원한다.




----------------------------------------------------------------------------------------------------------------------------



https://otiklo.tistory.com/16

1. border: border-width  border-style  border-color 
	: table, th , td 에 모두 적용 가능
		: tr 에는 적용 불가함 주의
	: border-width ) px 단위
	: border-style 
		(1) solid : 다 채움
		(2)
	: border-color ) 색상 지정

2. border-collapse: 테이블의 테두리와 셀의 테두리 사이의 간격을 어떻게 할지 지정
	:  table 단위로 적용해야된다
		: td, th , tr 에 적용 불가
	: separate ,collapse , initial , inherit 중에 하나 적용
		separate : 테이블의 테두리와 셀의 테두리 사이에 간격을 둡니다. << 디폴트값
		collapse : 테이블의 테두리와 셀의 테두리 사이의 간격을 없앱니다. 겹친다면 한 줄로 나타낸다.


3. border-spacing : 테이블의 테두리와 셀의 테두리 사이의 간격 지정
	: border-collapse: seperate 여야 적용 가능하다
	: length(직접 숫자 적는것) , initail , inherit 중 하나 택
		

4. empty-cells : 빈 셀 처리
	: show, hide, initial , inherit 중 하나 택

5. padding : 셀 내부의 여백 설정
	: initial (px 단위 , % 단위 모두 사용 가능) , inferit, inital 값 가능
	: 아래의 세분화된 속성도 이용 가능하다
		padding-top
		padding-bottom
		padding-left
		padding-right



6. width , height : 
	: td, th 를 대상으로 적용 가능 
	: px 값, % 값 모두 가능

7. background-color :
	: table, tr, th , td  모두에 적용 가능

8. margin-left , margin-right : 테이블 "자체" (셀 내부가 아님)를 정렬
	: table 을 대상을 ㅗ사용 사능
	: 할당가능한 값
		(1) auto :  가운데
		(2) 숫자 : 0 이면 완전 딱 붙여서

9. text-align : 셀 안의 내용을 "가로" 정렬
	: td, th 대상으로 적용 가능
	: 할당 가능한 값
		(1) left
		(2) right
		(3) center

10. vertical-align : 셀 안의 내용을 "세로" 정렬
	: td, th 대상으로 적용 가능
	: 할당 가능한 값
		(1) top
		(2) bottom
		(3) middle


출처: https://otiklo.tistory.com/16 [중요한 건 꺾이지 않는 마음:티스토리]

---------------------------------------------------------------------

이미지의 종류
- JPEG
    - 실사사진과 같이 복잡하고 많은 색상으로 이루어진 이미지에 적합
    - 손실 압축 방식을 사용한다.

- PNG
    - 무손실 압축 방식
    - 투명 배경을 지원해서 디자인이나 로고 파일로 많이 사용됨

- GIF
    - 256 색상만을 지원
    - 투명 배경과 애니메이션을 지원한다.




----------------------------------------------------------------------------------------------------------------------------
Hyper Text 
	: 순차적이냐 관계 없이 다른 문서로 이동 시켜주는 텍스트

Markup Language
	: 뭐가 뭔지 표시하는 용도로 쓰이는 언어

HTML Hyper Text Markup Language
	: 하이퍼 텍스트 마크업 언어
	: 여러 버전이 있지만 그중 HTML4 (==XHTML)가 굉장히 중요
		: xml 을 도입하였지만, 너무 복잡해서 실패함 >> 현재의 HTML5 가 나옴.
	: HTML5
		: HTML5 의 주요 개발 원칙
			1. 외부 플러그인 최소화 << 보안 차원
			2. 오류 표시 기능 향상
			3. 장치 독립적 설계(다양한 기기 지원)
			4. 투명한 개발과정 공개
			5. HTML, CSS, DOM, JavaScript 기술에 기반을 둔다.

		: HTML5 신기능
			1. 오프라인에서도 가능 >> 게임 오프라인에서도 가능
			2. 위치정보제공 
			3. 웹소켓 api >> 양방향 통신

	: html 태그는 그 요소의 의미를 markup하기 위해 적는거지, 그 태그의 표현 스타일을 이용하기 위해 적는게 아니다(그런건 css 이다)( 그러니까 표현 스타일 이용하겠다고 의미에 맞지 않는 태그 쓰면 안된다.)

	: 태그 ,  element 요소 , 속성 attribute
		: 태그 
			: <p> , </p> 같은거
			: html 에서 태그명 쓸때 대소문자 구분은 안해도,  대부분 소문자로 표기한다. 
			: 자식 태그, 부모 태그를 가질 수 있다
			: 시작, 종료 태그 사이의 연속된 공백은 하나의 공백으로 취급한다
				: 그러니까 스페이스 두번 쳐도 , 스페이스 한번 친걸로 취급된다
			: 속성 (attribute) 를  가질 수 있다
			: 태그 종류는 아래 본격적으로 정리함

		: 요소 element ) 태그 한 세트. 태그를 "활용"한 것.
			: 종류
				(1) block / inline 여부
					1. block element >> 한 줄을 다 차지(줄바꿈 일어남)
					2. inline element >> 그냥 낑김

				(2)  끝 태그 여부
					void element >> 끝 태그 없는 태그
				
		: 속성 attribute
			: 요소에 대한 추가적 정보를 제공한다
			: 값은 " " 로 대부분 할당한다 
				: ' ' 로도 묶어도 되고, 아예 안묶어도 되긴 한다

			: 대부분의 태그가 가지고 있는 속성

			:  속성의 종류
				(1). 열거 속성 Enumerated attribute : 할당할 수 있는 값이 정해진 속성
				(2). 불리언 속성 Boolean attributes : true, false 값만 할당 가능한 속성
				(3) 전역 속성 Global Attributes : 거의 모든 태그에서 사용 가능한 속성
					1. class >> 요소에 클래스 부여 
					2. id >> 요소에 아이디 부여 
					3. style >> 인라인 스타일 적용
					4. title >> 추가 정보 혹은 툴팁(==보조설명. 말풍선)으로 사용

	: 특수 문자
		&nbsp;
			: 공백문자
			: None Breaking SPace.

		&lt;
			: 왼쪽 꺽쇄(<) 
			: LefT

		&gt;
			: 오른쪽 꺽쇄(>)
			: riGhT

		&quot;
			: " 
			: QUOTation

		&amp
			: &
			: AMPersand

	: 태그 종류

		(-1) 기본적인
			: <!DOCTYPE html>
				: DTD Data Type Definition 을 html5 로 정의 
				: <html> 밖에 작성
			: <!-- -->
				: 주석

			: <html>
				: html 파일의 문서 전체(시작~ 끝)을 나타냄
				: 크게 내부 영역은 크게 <head>  와 <body> 로 구분됨

			: <head>
				:  html 문서 대한 정보를 정의한다 (= meta 데이터 담는 컨테이너)
				: 내부적으로 포함하는 태그들 << 이거 ㅇ이외엔 거의 다 <body> 태그의 ㅈ자식 태그로 쓰임
					1. <meta charset="utf-8">
						: 현재 html 파일의 인코딩 방식을 utf-8 로 정의한다
 					2. <title>
						: 탭에 표시할 문구 지정

			: <body>
				: html 문서의 본문 정의

		(0) non-sementic tag
			: 단순히 웹 사이트의 구조를 설계하는데 사용하는 태그
			: 스타일 지정이나 스크립팅 목적으로 필요한 경우를 제외하고는 non-sementic tag 가 아닌 sementic tag 를 사용하도록 하자.

			<div>
				: 대표적인 Block element 이다
				: DIVision 부서. 분할

			<span>	
				:대표적인 Inline element 이다
				: span == 표괄하다.

		(1) sementic tag 
			: https://seo.tbwakorea.com/blog/what-is-semantic-tag/
			: 태그명을 통한 역할 파악이 쉬우면서 <div>, <span>과 같이 웹 사이트의 구조를 설계하는데 쓰이는 태그
				: sementic == 의미론적인. 
				: 스타일 지정이나 스크립팅 목적으로 필요한 경우를 제외하고는 <div>와 같은 의미가 없는 요소나 속성을 사용하지 않아야 한다

			: 이점 
				1. 웹 사이트 검색할떄 필요한 내용을 정확하게 찾을 수 있게 함
					:ex) 본문 내용은 <header>,<footer> 태그가 아닌 <main> 태그 내에서 찾음

				2. 개발자의 코드 이해도가 높아짐
				3. 스크린 리더기가 정확히 읽음

			: 브라우져에 표시할 내용을 구분짓는 역할 하는거라 모두 body 내부에서 쓰인다. 

			< header >
				:헤더 영역(사이트 위에 있는 검색 창이나 메뉴바 같은거 있는곳), 그러니까 일종의 개요를 나타냄.
				: head 랑 다른 테그임 주의
					: head 는 메타 데이터를 대상으로 감싸는 태그고 , 필수적이며,  body 내부에 종속되어있지 않는다.

 
			< nav >  
				: 링크 거는 구간을 나타내기 위해 사용
					: <a>태그 같은거를 포함하게 된다.
				: NAVigation 의 약자

			<main> 
				: 핵심 콘텐츠(내용)이 들어있는 태그.
				: 웹 페ㅔ이지마다 똑같이 들어가는 정보가 아닌 웹 문서마다 다른 내용으로 구성이 된다
				: 한 문서에서 한번만 사용 가능

			<aside>
				:  사이드바 영역(왼 오 아래 바) 표기

			<footer>
				: 웹 문서 맨 아래쪽 콘텐츠 영역 표기

			 
			<article> 
				: 독립적인 콘텐츠를 표시하기 위해 사용하는 태그. 
					: 그러니까 뉴스 사이트에서 특정 기사 하나. 유튜브에서 특정 영상 하나 느낌
				: section 으로 대체 가능하긴 함( 컨텐츠 구분용으로 쓸 수 있긴 함)


			<section>
				: 서로 관계있는 콘텐츠를 분리해 표시하기 위해 사용하는 태그
					: 그러니까 서론 본문 결론 같은거 혹은 1장 2장 3장 같은거. 컨텐츠 목차 느낌.
				: article 으로 대체 가능하긴 함(콘텐ㅊ, 구분용으로)
				: article 로 각각의 컨텐츠를 구분짓고, 이 article 을 각각 section 으로 감싸서 article 간의 목차(?) 그런 느낌으로 관계를 나타낼 수 있다. 

	
		


		(2) 줄바꿈 관련
			<p>	
				: 문단을 표시하기 위해 사용.
				: 기본적으로 앞뒤 줄바꿈이 일어난다
				: Paragraph. 

			<pre>
				: html 파일에 입력한 그대로(== 엔터친거. 스페이스바 여러번 친것까지 반영해서!! ), 화면에 표시하는 태그
				: PREformatted text

			<br>
				: 강제 줄바꿈.
				: 딱히 끝 태그 없음
				: line BReak

		(3) 제목 관련
			<hn>
				: n = 1~ 6 까지의 숫자고( 작을수록 더 큼), 제목 표현 위해 쓰임
				: 기본적으로 앞뒤 줄바꿈 && 굵은 글자
				: Heading.

		(4) 텍스트 서식
			<b>
				: 볼드체
				: Bold
	
			<strong>
				: 강조 +볼드체
					: 강조의 의미가 추가되면
						1. 검색 엔진이 해당 부분을 중요한 부분으로 인식
						2. 스크린 리더기가 해당 부분을 강조하여 읽음 

			<i>
				: 이탤릭체
				: Italic

			<em>
				: 강조 + 이탤릭체
				: EMphasis

			<code>
				: 해당 부분이 소스코드임을 표시

	
			<sup> , <sub>
				: 위 첨자 아래첨자 표시

		(5) 수평선
			<hr>
				: 선 표시
				: Horizontal Rule

		(6) 리스트 : 항목을 나열하는데 사용
			<ol>
				: 순서있는 리스트 정의
				: 속성
					1. style ) 
						: list-style-type 속성에 다양한 값을 할당해 숫자 뿐 아니라 로마자 같은걸 기준으로 설정 가능
							: 그러니까 	<ol style="list-style-type:upper-alpha"> 같은거 가능하단거

						: list-style-type 속성에 할당 가능한 값
							1. upper-alpha >> 대문자 알파벳
							2. upper-roman >> 대문자 로마자
							3. decimal >> 정수

					2. start ) 시작 기준 설정 가능
						: style 이 숫자건 알파벳이건 로마자건 , start 는 숫자로 표현하는거 주의(1부터 시작)
						ex) 	<ol style="list-style-type:decimal" start="10">

				: Ordered List

			<ul>
				: 순서 없는 리스트 정의
				: Unordered List

			<li>
				: 리스트의 원소 정의
					: 순서 있건 없건 상관 없음

		(7) 이미지관련
			<img>
				: 속성
					1. src 
						:자원의 경로 할당

					2. alt
						: 사진 깨질 시 표시할 문구
						: ALTernate text

					3. width, height
						: 너비와 높이 지정
						: width 만 지정하면, 알아서 비율 맟춰주기 때문에 width 만 설정해주는게 좋다
						: px 값, % 값 모두 기준으로 할 수 있다
							: px >> 고정적
							: % 값 >> 브라우져 창 크기따라 가변적


		(8) 링크
			<a>
				: 하이퍼 링크 생성할 때 사용
				: 속성
					1.href 
						: 웹 페이지 경로 나타낸다
						: 경로 tip >> html 에서 경로 잡을 때 상대경로와 절대경로 2가지 모두 이용할 수 있다.
							: 절대 경로 >> 젤 앞에 "/"를 쓴다
 							: 상대경로 >> 젤 앞에 "/"를 안쓴다


					2. target
						: 새로운 페이지가 어떠한 방식으로 열릴지 지정
						: 할당 가능한 값
							1. "_blank"  : 새로운 탭에서 페이지를 연다
							2. "_self" : 현재 탭에서 페이지를 연다 (디폴트)
				: a 태그의 시작과 끝 태그 사이에 글자 쓰면 그 글자 클릭했을떄 이둉하게 할 수 있따
					: 사이에 img 태그 적으면 img 클릭했을떄 이동하게 ㅎ할 수 있따
				: Anchor

		(9) 일반적인 표 관련 태그

			<table>
				: 표 table 정의
					: 표 >> row(=행=가로찍), column (=열=세로쿵) , cell(=셀=한칸) 으로 이루어진다

				: 예시
<a href="https://img.kr.news.samsung.com/kr/wp-content/uploads/2021/07/2021_2%EB%B6%84%EA%B8%B0_%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90_%EC%8B%A4%EC%A0%81_%ED%91%9C-1000.jpg" alt="삼성전자 표"><h2>표2</h2></a>
	<table border="1">
		<caption>2021_2분기_삼성전자_실적_표</caption>
		
		<thead>
			<tr>
				<th rowspan="2" colspan="2">구분</th>
				
				<th colspan="5">2018년</th>
				<th colspan="5">2019년</th>
				<th colspan="5">2018년</th>
				
			</tr>
		
			<tr>
				<th>1Q</th>
				<th>2Q</th>
				<th>3Q</th>
				<th>4Q</th>
				<th>전체</th>
			
				<th>1Q</th>
				<th>2Q</th>
				<th>3Q</th>
				<th>4Q</th>
				<th>전체</th>
			
				<th>1Q</th>
				<th>2Q</th>
				<th>3Q</th>
				<th>4Q</th>
				<th>전체</th>
			</tr>
		</thead>
		<tbody>	
			<tr>
				<td rowspan="7">매출</td>
				<td>계</td>
				<td>60.56</td>
				<td>58.48</td>
				<td>65.46</td>
				<td>59.27</td>
				<td><%= 60.56 + 58.48+65.46+59.27%></td>
				
			</tr>
			
			<tr>
				<td>CE부분</td>
				<td>9.74</td>
				<td>10.4</td>
				<td>10.18</td>
				<td>11.79</td>
				<td><%= 9.74 + 10.4 +10.18+11.79%></td>
				
			</tr>
			
		</tbody>	
	</table>


			<caption>
				: table 의 제목을 나타냄
				: 얘도 table 태그의 내부에 쓰는거 주의

			<tr>
				: table 의 행을 나타냄
				: 행 단위로 셀을 나타내는 태그들을 감싼다
					: 그러니까 td 뿐 아니라 th 도 감싼다
				: Table Row

			<th>
				: table 의 제목"셀"을 나타냄 
					: 그러니까 해당 열의 제목 같은거 들어가고 실제 데이터는 안들어가는 셀들
					: 그러니까 셀이라도 제목 셀이면. <td> 안쓰고, <th> 만 쓰는거.
					: 단순히 젤 윗행의 셀들만 가리는게 아니라 세로 셀도 그런 (?) 제목 셀인 경우 해당 셀은 th 로 생성한다( https://kin.naver.com/qna/detail.naver?d1id=1&dirId=1040205&docId=464133709&scrollTo=answer1# )
					: 기본적으로 텍스트 가운데 정렬 && 굵은 글자 표시된다
				: 속성
					: 사용 tip >> 합치기로 한 부분이면 합침 당하는 셀은 이미 표시한걸로 치는거다.( 그러니까 rowspan="2" 했으면 바로 아랫행의 해당 셀은 생략하고 나머지 셀만 정의하는거고 colspan="2" 했으면 해당 행의 바로 옆 셀은 생략하고 그 뒷 셀만 정의하는거다)
					1. rowspan
						: 행 합치기 (== 아래 방향셀이랑 합치기)
						: 값으로는 몇개의 셀과 합칠것인지 숫자를 (문자열의 꼴로) 할당
						: span ) 가로지르다. 포괄하다 << 합치다 라는 느낌
 
					2. colspan
						: 열 합치기 (== 오른쪽 방향 셀이랑 합치기)
						: 값으로는 몇개의 셀과 합칠것인지 숫자를 (문자열의 꼴로) 할당		
				: Table Head

			<td>
				: table 의 셀을 나타냄
					: 실제로 유의미한 데이터를 나타내는 셀들
				: 속성
					: th 의 속성과 사용방법이 같음
					1. rowspan
						: 행 합치기 (== 아래 방향셀이랑 합치기)
					2. colspan
						: 열 합치기 (== 오른쪽 방향 셀이랑 합치기)
				: Table Data


		


		(6) col
			: (기본) 열 1개 단위로 열의 스타일을 결정
			: void element 라서 닫는 태그 없음 주의
			: 반드시  colgroup 내부에 써야됨
			: 쓸꺼면 모든 열에 대해 col 태그를 명시해야됨
				: 별도로 색깔 너비 같은거 정할 필요없는 열엔 <col> 적는다

			: 반드시 표의 내용이 시작하기 전에 써야됨(== caption 태그가 있다면 caption 태그 바로 다음에 써야됨 )

			: 합침당한열의 경우 해당 열의 젤 앞 셀의 특성을 따른다
			: 속성
				1. style
					:tip >> 문자열 내부의 끝에 모두 세미콜론을 붙인다
					(1) 배경색깔 지정>> "background-color:#색상;" 
						: 색상은 16 진수 형태의 rgb 값을 써야된다.
					(2) 열의 너비 지정>> "width:원하는크기px;"

				2. span
					:  똑같은 스타일을 적용시키고 싶은 열들(바로 뒷 열들의-그러니까 띠엄띠엄 함 안됨)의 갯수 적음
					: ex ) <col><col> == <col span="2">

		(7) colgroup
			: 한테이블의 col 태 그를 묶음
			: 반드시 표의 내용이 시작하기 전에 써야됨(== caption 태그가 있다면 caption 태그 바로 다음에 써야됨 )


		(10)표의 구조를 나타내는 sementic 태그
			(1) thead
				: 제목셀 행 전체를 나타냄
					: th 태그들을 감싸는 tr 태그(들)을 thead 가 감싸는꼴
				: Table HEAD

			(2) tbody
				: 데이터셀 행 전체를 나타냄
					: td 태그들을 감싸는 tr 태그들을 tbody 가 감싸는 꼴
				: Table BODY

			(3) tfoot
				: 해당 table 을 요약하는 맨 마지막 행을 나타냄	
					: 그러니까 th 태그들이 아닌 td 태그들을 감싸는 tr 태그 중 가장 마지막 tr 태그(들)을 tfoot 기 감싸는 꼴
					: 전체 데이터 셀 합계 평균 뭐 그런거 나타내는 맨 마지막 행
					: 근데 이런 역할이 없으면 tfoot 시멘틱 태그는 안쓰는거다. 없는데 맨 마지막 행이라고걍 가져다 붙이는게 아니다
			: Table FOOT
		
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

하나의 명령하는데 3개의 클럭이 쓰인다고 가정하면
	: 명령어 로딩 - 명령어 실행 - 실행 결과 저장
	: 어쩄뜬 1초에 100 억개 이상을 수행 가능 >> 프로그램 작성할때 딱히 속도 신경쓸 필요는 없다. 가독성만 신경쓰면 된다
	

id 속성
    <a href="#section1">참고 사항으로 가려면 여기를 클릭하세요.</a>
    <a id="section1">참고 사항</a>

이메일 링크

 html로 문자를 전송하려면? >> 
	문자 SMS Show Message Service

테이블은 표를 만들때 뿐 아니라 배치를 하는데도 사용된다


# 테이블 데코레이션..


padding 속성 >> 셀 경계와 셀 내용 사이의 공간
	: 세분화 
		padding-top
		padding-bottom
		padding-left
		padding-right

border-spacing  >> 셀과 셀 사이의 빈 공간ㄴ




웹브라우저와 멀티미디어
- 예전 방법:
    - HTML 안에서는 <embed>나 <object> 태그를 사용하여야 했고
    - 웹브라우저에는 플래시나 ActiveX를 설치 >> (설치해야되고) 보안에 문제가 되니까 별로다
- HTML5: <audio>와 <video> 태그가 추가

: 비디오의 형식에 따라 특정 환경에서 플레이 될수도 안될수도 있따

: 개꿀팁 >> 유튜브에서 공유하기 버튼에서 , 태그처럼 생긴 퍼가기 버튼 누르면 html 코드 나오는데, 그걸 걍 복붙하면 ㅈㄴ 쉽게 붙여진다 

: 지원 안되는걸 더 위에 쓰면 밑에 제대로 되있는것까지 인식 안된다

; mp4 쓰자 << 표준을 꼭 따르진 않는다. ogg 같은건 안된다


MIME ㅌ타입.
	: 마임 타입
	: 바이너리 파일을 인코딩 하는 방법
- MIME은 Multipurpose Internet Mail Extensions의 약자
    - 이메일 시스템에서 다양한 형식의 데이터를 전송하기 위해 처음으로 도입
    - 그러나 이후 HTTP와 함께 웹에서도 널리 사용
- MIME은 각 데이터 조각의 유형을 식별하기 위해 사용
    - 이를 통해 브라우저는 받은 데이터를 올바르게 해석하고 적절한 방식으로 표시
    - HTTP 헤더에는 MIME 유형을 나타내는 Content-Type 헤더가 포함
    - 이 헤더는 웹 서버가 클라이언트에게 전송하는 데이터의 유형을 알려줌
    - 예를 들어, "Content-Type: text/html"은 HTML 문서를 전송한다는 것을 의미
	예를 들어 video/mp4 는 동영상을 전송ㅎㄴ다는걸 의미
- MIME은 HTTP에서 데이터를 보내는 데 중요한 역할
    - 이를 통해 서버와 클라이언트 간에 표준화된 방법으로 데이터를 교환


기존에 잘 돌아가는 걸 가져다 쓰는거, 새로 만들어 쓰는거

# URL에 %가 들어가는 이유..

- URL이 특정 문자를 포함할 때 인코딩(encoding)되어야 하기 때문
    - URL은 특정한 문자 집합만을 허용하기 때문에, URL에 포함될 수 없는 문자들은 특별한 방식으로 인코딩되어야 함
- % 기호는 URL 인코딩에서 사용되는 특수한 접두사
    - 예를 들어, 공백(space)은 URL에서 허용되지 않는 문자 중 하나
    - 따라서 공백을 URL에 포함시키려면 %20으로 인코딩
    - 이는 공백을 나타내는 ASCII 문자의 16진수 값이기 때문
- 이것은 복잡하지만 명확한 작업이므로 주로 라이브러리를 사용하여 실행

'



# **iframe**

- iframe은 웹 페이지 안에서 프레임을 만들고 여기에 다른 웹 페이지를 표시하고자 할 때 사용한다.
- iframe은 “inline frame”의 약자이다.
- html 내부에 또 html 띄우게 하는거
- 보안 문제 >> 로컬 쪽에 저장된 다른 영역을 침법할 수 있따

	: inlude 지시자와 존똑
	: 내부에 삽입시켜주는거임

redirect >> response 를보냄
forward , include >> 내부에서 이동




부모창 >> include 시킨 부분
top >> 최상ㅇ위


시멘틱 웹
문법 syntax <--> 의미 sematic
	: 의미를 담자.

: 쓰길 권장하는데 왜 안쓸까? ??  >> 
	1. 귀찮아서... 
	2. 해도 남는것도 없어서. .
	3.  개발자는 디자인을 못하니까, css 프레임 을 쓰는데 그게 다 div 태그로 되어있다
		: 가져다 쓴다 해도 이해는 해야되기 때문에 css 배워야된다


데이터를 입력할떄는 테이블 형식이 좋고, 그냥 보여줄땐 흐름대로 해주는게 좋다

같은 웹 페이지 내에서 이동>> id 를 사용
        <ul>
            <li><a href=#html> HTML5 </a></li>
            <li><a href=#css> CSS3 </a></li>
            <li><a href=#js> JAVASCRIPT </a></li>
        </ul>
    </nav>
    <section>
        <article id="html">
            <h2>HTML5</h2>
            <p>HTML을 이용하여 문서의 구조와 내용을 기술합니다. </p>
        </article>
        <article id="css">
            <h2>CSS3</h2>
            <p>CSS을 이용하여 문서의 스타일을 기술합니다. </p>
        </article>
        <article id="js">
            <h2>JAVASCRIPT</h2>
            <p>JAVASCRIPT을 이용하여 문서의 동작을 기술합니다. </p>
        </article>


입력 양식 >> 폼.
	: 

최근에는 get. post 방식도 안쓰고 REST 방식 쓴다

payload




-------------------------------------------------------------


<input type="number" name="number" min="1" max="10" step="2"/><br />
같은 경우 범위 넘어가는 값입력하면 전송 안된다고 한다

radio >> 하나만 택 가능
checkbox >> 다중선택 가능
	: 쿼리스트링 어떻게 나오는지 나중에 봐야된다 
hidden >> 
	: 요즘엔 안쓴다
	: statleless 하기 때문에 썼었던 방식이다


stateless 하다

세션 >> 한번 request, response 받는거

state >> 정보. 정보 유지 안한다


요청된 패킷 보는 방법..
	: f12 - 네트웤 - payload
	: 페이로드 --> 데이터.
		: 헤더와 , 메타데이터 같은거 말고 실제로 클라이언트에게 입력받는 뭐 그런 데이터


이미지로 버튼을 쓰는 법 >> 버튼 만들고 그 내부에 이미지를 둠



<label for="male">남성</label>
    <input type="radio" name="gender" id="male" value="male"><br>

: id 로 바인딩함



가능하면 (간단한 입력형식 검사 같은 경우) 걍 클라이언트 차원에서 끝내는게 좋다
	: 안그럼 서버서 다 처리해야되니까


- DTD Document Type Definition 를 왜 사용하는가?
    - 문서의 형식을 수식으로 정의
        - 정확하게 정의 가능
    - 이를 사용하면 문법 검사 기능, 분석 기능 등을 자동적으로 생성 가능
        - 코드 자동 생성으로 오류가 많은 막코딩 방지하여 개발 생산성 향상


컴터언어만드는법>> 방법2. 문법을 수식(BNF) 으로 표현하고 자동 생성(YACC)
	: 직접 만들필욘 없지만 원리는 이해해야..


--------------------------------------------------------------------

BNF 언어 만드는 것	
	: https://jacquev6.github.io/DrawGrammar/
expr = term, { ( '+' | '-' ) , term };
term = { factor, ( '*' | '/' ) }, factor;
factor = integer | '(', expr, ')';
integer = [ '-' ], digit, { digit };
digit = '0' | '1' | '...' | '9';

	: 우선순위가 더 높은걸 먼저 쓴다
	: rail way chart . 기찻길 그림

컴파일러 : 특정언어를 다른 언어로 변환
	소스코드 >> 어셈블리어 >> 바이너리
	단계 << 이 3가지만 만ㄴ들면 컴파일러 만들 수 있다
		: : 이거 만드는게 개어려운데 요즘엔 편리한 툴이 많다
		: https://tomyself148.tistory.com/37
		lexical analyzer >> 어휘 분석기
			: Identifier(식별자 = 변수)를 인식하는 역할을 한다. A = B + C 라는 코드에서 A, B, C가 Identifer이다.
			: Lex 를 이용해 쉽게 만들 수 있다
		syntaz analyzer >>구문 분석기
			: 파싱이라고도 한다
			: 어휘를 분석했으니 어휘들의 집합인 구문을 분석한다.
			: YACC 를 이용해 쉽게 만들 수 있따
		code generator : 코드 생성기
			: 1~4까지는 기계 독립성을 띠고 코드 생성기만 기계 의존성을 띤다. 무슨 말이냐 하면 기계 독립성은 어떤 기계든 간에 상관없이 언어를 분석하는 것이다. 의존성은 최종 이식될 기계에 적합한 방식대로 변경된다는 뜻이다. 즉, 모토로라, 인텔에 따라서 다르게 적용되는 것이 코드 생성기 부분이다.



-----------------------------------------------------------------------------------------------------------------

Regular Expression 정규식 >> 패턴을 정의하는 수식
	: 텍스트 패턴 매칭은 ㅈㄴ 많이 쓰이고, 하드코딩하기 ㅈㄴ 어렵우므로 정규식 추천하자.
		: HTML 도 텍스트 주고받는거다. 웹에서도 텍스트의 개념이 중요하다
		: 자바 스크립트는 택스트 처리에 ㅈㄴ 좋다

	: 모든 language 에서 다 정규식 지원한다

* == 
? == 0개 혹은 1개 있다
+ == 앞의 단어가 1개 이상 있다
* == 앞의 단어가 0개 이상 있다
{n} == 딱 n번 반복된다
{n,m} == 앞의 단어가 n번 이상, m번이하 반복되어야한다
{n,} == 앞의 단어가  n번이상 반복되어야한다
( ) == 단어를 묶는다
[a-zA-Z] == 소문자 a - z 중 한문자
[0-9] == 0 - 9 중 한문자 == \d
[a-Z] == 소문자, 대문자 중 한문자.

^ == 시작
$ == 끝
	: 시작과 끝이 없으면 그거 포함되있기만 하면 다 되는거고 , 시작과 끝을 나타내면

\어쩌구 == 이스케이프시퀀스


전체에서 해당하는게 있기만하면 된다


FaQ : Frequently asked question 

막코딩 == 하드코딩 <---> 정공법 == 제대로 하는거


좀더 다양한 패턴을 받을수 있게 전화번호 검증 코드를 수정해야된다

input 태그의 required 속성을 명시하면 반드시 채워있어야하는 걸로 인식시킨다
	: 근데 모든 input 태그에 적용되는건 아니다	
	: 명시만 해도 작용하는건 required 속성이 boolean 속성이기 떄문에 명시만 하면 자동으로 true 된다

	: pattern 속성은 HTML5에서 추가된 속성으로, input 요소의 값을 검증하는데 사용된다. 정규표현식 패턴을 입력받아 해당 패턴에 맞는 문자열만 입력 가능하도록 제한하는 속성이다.

-----------------------------------------------------------




 float
	: https://inpa.tistory.com/entry/CSS-%F0%9F%93%9A-float
	:  해당 요소를 다음 요소 위에 떠 있게 한다. 
		: 떠있다 == 요소가 기본 레이아웃 흐름에서 벗어나 요소의 모서리가 페이지의 왼쪽이나 오른쪽에 이동

	: 원래 이미지와 텍스트 배치 용도로 등장했지만, 요즘에는 레이아웃용으로 많이 사용하고 있습니다.
	: 할당 가능한 값 >> 해당 위치에 떠있게 한다
		none (기본값) : 정렬하지 않는다.
		left : 다음 요소의 왼쪽에 떠있게 한다
		right: 다음 요소의 오른쪽에 떠있게 한다


	: 해당 블럭 다음에 오는 요소를 어케 표시할지 결정

	: block element에만 적용할 수 있다.
		: display 속성과 함께 쓰면 display 속성은 무시된다.
		: 엥 근데 img 에는 왜 되는건데

	: width, height 설정이 가능하다


clear
	: float 속성을 중단할 때 사용한다
	: 할당 가능한 값 ) 주로 both 를 쓴다
		none (기본값) >> clear 을 설정하지 않는다
		right >> float:right 를 취소 시킨다(== 요소가 왼쪽에 부유한 다음 요소에 위치하게 한다)
		left >> float:left 를 취소 시킨다
		both >> float: right, float:left 를 둘 다 취소 시킨다(== 요소가 왼쪽과 오른쪽에 부유한 요소 다음에 위치하도록 한다. )

	

	: float 속성이 적용된 요소가 다음 요소들과 겹치는 현상을 방지하기 위해 사용된다
 		: 요소에 float 속성이 적용되면 그 이후에 등장하는 모든 요소들은 정확한 위치를 설정하기 힘들어 지게 되는데, 따라서 clear 속성을 사용하여, 이후의 요소들이 더는 float 속성에 영향을 받지 않도록 설정해주어 요소들이 float 속성이 적용된 요소 "아래"에 위치하도록 한다.
	: float 프로퍼티를 사용할 때 요소의 위치를 고정시키는 position 프로퍼티의 absolute를 사용하면 안된다. float 속성이 relative한 위치 지정을 하기 때문에 position: absolute 속성이 적용되지 않기 때문이다.
또한 float 속성을 사용하면 해당 요소는 일반적인 흐름에서 벗어나게 되어 요소의 부모 요소는 해당 요소의 높이를 인식하지 못하게 되는데, 이 경우 부모 요소에 overflow: hidden 속성을 추가하여 해결할 수 있다.


 .clearfix : 영역을 잡아주기 위한 css 속성.
	: float으로 컨텐츠를 띄울 시 다음 내용은 빈자리를 채우려 올라오게 된다.이러한 현상은 브라우저의 오류로 생겨난 것이고,이를 해결하는 clearfix는 위의 오류를 해결하기 위한 일종의 버그 해결 방법이다.



#333 >> 검은색은 아닌데 어두운 색. 0 에 가까울 수록 밝은 색깔인거임

list-style-type: bulltet 을 조정
text-decoration: 언더라인 여부 조정
overflow: hidden;


모듈화를 하자. 그러니까 부품으로 세분화 해서 필요에 따라 조립해서 쓰자



# **z-index**
- 요소의 스택 순서를 지정
	: 숫자가 작을 수록 더 바닥에 출력된다
	: 숫자를 음수로 줄 수도 있다

Overflow
	: overflow 속성은 자식 요소가 부모 요소의 범위를 벗어났을 때, 어떻게 처리할 것인지를 지정한다.
	: 값
		1. hidden : 넘치는건 안보이게 한다
		2. scroll : 넘치는건 스크롤해서 볼 수 있게 한다

테이블은 리사이즈 하면 반응하기 좀 어렵다
	: ㅈㄴ 옛날 방식

linear : 선형적 >> 동일한
ease : 빨라졌다가 느려짐 ?
ease in  : 늦었다가 빨라짐 ?
ease-out ?


@keyframes


태그에서 " " 쓰면 안된다 ! ' ' 써야된다


**Mini Project: 쇼핑몰 웹사이트 제작**
1. 계획 >> 타당성 분석
2. 설계 >> 어케 구현할지 계획짠다. 스케치


--------------------------------------------------------------------------------------------------------------

자바 스크립트
	: 자바랑은 다른거다. 걍 홍보 차원에서 이름만 빌려다 쓴거다
		: 자바 >> 컴파일(한꺼번에)
			: jvm 에서 실행된다
			: 변수의 타입을 선언해야된다

		: 자바스크립트 >> 인터프리터(한줄마다)
			: 브라우져 위에서 실행된다
			: 변수의 타입을 선언하지 않아도 된다
			: 객체지향처럼 흉내내지만 객체 지향이 아닌거 주의
			: Impure programming >> 순수하지 않다. 프로그램이 실행되는 중간에 프로그램을 바꿀 수 있다
				: 시험 문제 안낸다

		: 구조적 프로그래밍 : {  }쓸 수 이ㅣㅆ는거.
			: 자바, 자바스크립트 모두 구조벅 프로그래밍 언어

		: 람다 함수
			: firstclass object ) a = 1 + 2

" : 더블 쿼테이션
' : 싱글 쿼테이션


자바 스크립트의 용도
	: HTML 콘텐츠를 "동적"으로 변경할 수 있다.
 	: 사용자가 입력한 값들을 검증하는 것도 가능
	: 게임이나 애니메이션과 같은 상호대화적인 콘텐츠를 구현할 수 있다
		: 빠르다

	: this == 이벤트를 받은 객체

jsp == java 가 microsoft 배껴서 만든거
Node.js ==  자바스크립트를 서버 프로그래밍 언어로 변환시킨거



string 이 html 로 오면 그걸 분석한다. 그러니까 그걸 파싱해서 객체 구조로 만든다. 
document 는 그 객체 구조의 root를 의미한다. 그러니까 해당 웹 페이지 전체를 나타내는 객체이다.

!! DOM Document Obejct Model: HTML 문서를 객체화한 것
	: HTML이 파싱을 거치면 DOM tree,

React, Flutter → VDOM(Virtual DOM)


자바스트립트 위치: <head>와 <body>의 차이점.. 
	: 작은건 <head> 에다 넣어도 좋지만, <body>의 끝에 넣는걸 추천한다
	: 조금조금씩 내용을 보여줄 수 있고, 좀 기다리되 빡 보여주는 방법이 있다

- HTML 문서에서 자바스크립트 코드를 <head>에 넣으면
    - 웹 페이지가 완전히 로드되기 전에 스크립트가 먼저 로드되고 실행
    - 웹 페이지의 다른 내용이 나타나기 전에 스크립트 처리가 완료되어야 하므로 페이지 로딩이 느려질 수 있음
- 작동 원리
    - HTML 내부에 복잡한 라이브러리나 사진 또는 동영상이 포함되는 경우, 모두 다운로드 받은 후에 보여주면, 반응 속도가 늦어진다.
    - 따라서, 다운로드 도중에도 처리를 하여 반응 속도를 향상시킨다.
- 자바스크립트 코드를 <body> 태그의 끝부분에 넣으면
    - 페이지의 HTML 내용이 먼저 로드되고 사용자에게 표시된 후에 스크립트가 로드되고 실행
    - 이 방식은 사용자가 페이지의 내용을 거의 바로 볼 수 있게 해주므로, 사용자 경험을 개선합니다.
- 간단히 말해, <head>에 스크립트를 넣으면 반응 속도가 느려질 수 있고, <body> 끝에 넣으면 사용자가 내용을 더 빨리 볼 수 있음.


내부 자바 스크립트
	:  <script> 문 내부에 직접 실행 내용을 적음

외부 자바스크립트
	: <script> 문 내부에 js 파일을 링크 시킴

인라인 자바스크립트
	: element 태그 에 직접 적음

기본 문법 : 
	' ; ' : 안찍어 줘도 된다(그래도 문장으로 인식된다). 그래도 관습상 찍어주자
		: 근데 막상 ctrl+s 하면 ';' 생략된 형태로 저장된다고 한다

	변수 
