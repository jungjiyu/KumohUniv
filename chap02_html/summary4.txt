BNF 언어 만드는 것	
	: https://jacquev6.github.io/DrawGrammar/
expr = term, { ( '+' | '-' ) , term };
term = { factor, ( '*' | '/' ) }, factor;
factor = integer | '(', expr, ')';
integer = [ '-' ], digit, { digit };
digit = '0' | '1' | '...' | '9';

	: 우선순위가 더 높은걸 먼저 쓴다
	: rail way chart . 기찻길 그림

컴파일러 : 특정언어를 다른 언어로 변환
	소스코드 >> 어셈블리어 >> 바이너리
	단계 << 이 3가지만 만ㄴ들면 컴파일러 만들 수 있다
		: : 이거 만드는게 개어려운데 요즘엔 편리한 툴이 많다
		: https://tomyself148.tistory.com/37
		lexical analyzer >> 어휘 분석기
			: Identifier(식별자 = 변수)를 인식하는 역할을 한다. A = B + C 라는 코드에서 A, B, C가 Identifer이다.
			: Lex 를 이용해 쉽게 만들 수 있다
		syntaz analyzer >>구문 분석기
			: 파싱이라고도 한다
			: 어휘를 분석했으니 어휘들의 집합인 구문을 분석한다.
			: YACC 를 이용해 쉽게 만들 수 있따
		code generator : 코드 생성기
			: 1~4까지는 기계 독립성을 띠고 코드 생성기만 기계 의존성을 띤다. 무슨 말이냐 하면 기계 독립성은 어떤 기계든 간에 상관없이 언어를 분석하는 것이다. 의존성은 최종 이식될 기계에 적합한 방식대로 변경된다는 뜻이다. 즉, 모토로라, 인텔에 따라서 다르게 적용되는 것이 코드 생성기 부분이다.



-----------------------------------------------------------------------------------------------------------------

Regular Expression 정규식 >> 패턴을 정의하는 수식
	: 텍스트 패턴 매칭은 ㅈㄴ 많이 쓰이고, 하드코딩하기 ㅈㄴ 어렵우므로 정규식 추천하자.
		: HTML 도 텍스트 주고받는거다. 웹에서도 텍스트의 개념이 중요하다
		: 자바 스크립트는 택스트 처리에 ㅈㄴ 좋다

	: 모든 language 에서 다 정규식 지원한다

* == 
? == 0개 혹은 1개 있다
+ == 앞의 단어가 1개 이상 있다
* == 앞의 단어가 0개 이상 있다
{n} == 딱 n번 반복된다
{n,m} == 앞의 단어가 n번 이상, m번이하 반복되어야한다
{n,} == 앞의 단어가  n번이상 반복되어야한다
( ) == 단어를 묶는다
[a-zA-Z] == 소문자 a - z 중 한문자
[0-9] == 0 - 9 중 한문자 == \d
[a-Z] == 소문자, 대문자 중 한문자.

^ == 시작
$ == 끝
	: 시작과 끝이 없으면 그거 포함되있기만 하면 다 되는거고 , 시작과 끝을 나타내면

\어쩌구 == 이스케이프시퀀스


전체에서 해당하는게 있기만하면 된다


FaQ : Frequently asked question 

막코딩 == 하드코딩 <---> 정공법 == 제대로 하는거


좀더 다양한 패턴을 받을수 있게 전화번호 검증 코드를 수정해야된다

input 태그의 required 속성을 명시하면 반드시 채워있어야하는 걸로 인식시킨다
	: 근데 모든 input 태그에 적용되는건 아니다	
	: 명시만 해도 작용하는건 required 속성이 boolean 속성이기 떄문에 명시만 하면 자동으로 true 된다

	: pattern 속성은 HTML5에서 추가된 속성으로, input 요소의 값을 검증하는데 사용된다. 정규표현식 패턴을 입력받아 해당 패턴에 맞는 문자열만 입력 가능하도록 제한하는 속성이다.
