cpu -> 명령어를 실행한다

명령어 사이클: CPU가 한 개의 명령어를 실행하는 데 필요한 전체 처리 과정
	• CPU가 프로그램 실행을 시작한 순간부터 전원을 끌 때까지 반복
	• 분류
		1. 인출 fetch 사이클 : 기억장치로부터 명령어를 읽어오는 단계
			: IR 레지스터에 저장되는 단계까지

		2. 실행 execution사이클 : 명령어를 해독하고 실행
			: 명령어를 해독 >> 어떤 종류의 연산을 수행해야되즌지



명령어 실행에 필요한 cpu 내부 레지스터
	- 프로그램 카운터 : 다음에 인출"할" 명령어의 주소를 가지고 있는 레지스터
	- 누산기(Accumulator, AC) : 데이터를 일시적으로 저장하는 레지스터
		: 산술/논리 연산관련

	- 명령어 레지스터(Instruction Register, IR) : 가장 최근에 인출"된" 명령어 코드가 저장되어 있는 레지스터
	- 기억장치 주소 레지스터(Memory Address Register, MAR) : 주소 버스와 cpu버스를 연결
		: 속도 차 극복 (택배보관함)

	- 기억장치 버퍼 레지스터(Memory Buffer Register, MBR) : 데이터버스와 cpu버스를 연결
		: 속도 차 극복


기타 cpu 내부 레지스터
	- 데이터 레지스터(Data Register, 범용 레지스터) : 그냥 데이터 일시 저장
	- 입출력 주소 레지스터(I/O Address Register, I/O AR) 
	- 입출력 버퍼 레지스터(I/O Buffer Register, I/O BR)
	- 스택 제어 레지스터(Stack Control Register, Stack Pointer, SP)
		:스택이다보니 후입선출, push pop
		: 블록 >> 메모리의 끝 부분
			: stack <- 보통 끝 부분
				- sp (stack point)
				- base

	- 상태 레지스터(Status Register, SR) : 특정 조건 발생을 표시하는 데 사용
		: 명령어 실행 결과에 따른 조건 플래그(condition flag)들 저장
			: S Z C E V I P
			: 조건 플래그
				▪부호(S) 플래그: 직전에 수행된 산술연산 결과값의 부호 비트를 저장 (양수:
0, 음수: 1)
				▪제로(Z) 플래그: 연산 결과값이 0이면, 1로 세트
				▪올림수(C) 플래그: 덧셈이나 뺄셈에서 올림수(carry)나 빌림수(borrow)가
발생한 경우에 1로 세트
				▪동등(E) 플래그: 두 수를 비교한 결과가 같게 나왔을 경우에 1로 세트
				▪오버플로우(V) 플래그: 산술 연산 과정에서 오버플로우가 발생한 경우에 1
로 세트
				▪인터럽트(I) 플래그
					: 인터럽트. 현재 cpu가 처리하고 있는 동작을 방해 << when? 더 급한게 들어왔을떄

					- 인터럽트 가능(interrupt enabled) 상태이면, 0으로 세트
					- 인터럽트 불가능(interrupt disabled) 상태이면, 1로 세트
						: 매우 중요한 명령어인 경우 ... 


				▪슈퍼바이저(P) 플래그
					• CPU의 실행 모드가 슈퍼바이저(커널) 모드(supervisor mode)이면, 1로 세트
						: 쉽게 말하면 관리자 모드

					• 사용자 모드(user mode)이면, 0으로 세트



클록 주파수와 클록 주기
❑클록(Clock) : 컴퓨터의 모든 부품이 일정한 속도로 작동하기 위한(=동기화위한) 전기적 진동(pulse)
	: 타이밍을 보통 클록이라는 전기적 신호로 맞춘다

	: 클록 수가 빠르면 처리 속도가 "대체로" 빠른 편 (항상은 x)

	: 구성
		: 상승 엣지rising edge
		: 하강엣지 falling edge

	: 클록 주파수(Hz 단위) >> 1초에 클록이 몇 번 발생하는지를 의미
		: 1초에 10^9 (1억)번 클록이 발생하면 클록 주파수는 1GHz (기가헤르츠)
			: 이때 클럭 주기 >> 1나노 세컨드

		: 클록주파수가 2GHZ
			: 이때 클럭 주기는 >> 0.5 나노 세컨드

	: 클록 주기 >> 다음 신호가 올떄까지의 간격
		: 그러니까 상승 엣지 다음의 상승 엣지가 등장하는 시점
		: 클록주기와 클록 주파수는 반비례
			: 클록 주기 = 1/클록주파수


	

❑ 마이크로 연산 : CPU 클록의 각 주기(딱 한 주기) 동안 수행되는 기본 단위의 동작
	: 인출 사이클(명령어 레지스터에 저장하는 단계까지)의 마이크로 연산 >> 3개의 마이크로 연산이 필요
		- 첫번째 주기(t0) :  MAR ← PC 
			: 주소 이동하는것.
			:  PC에서 명령어의 주소를 꺼내 MAR 에 저장한다. 대기시킨다.

		- 두번째 주기(t1) :  MBR ← M[MAR], PC ← PC + 1
		    : 명령어가 이동하는 것
		    : MBR ← M[MAR]
			: M == 기억장치 .
				: MAR 을 기반으로(=명령어 주소 기반으로) M에 접근해서 명령어를 가져온다
					: 배열같이 ...

			: 명령어를 MBR 로 옮길 때까지

		    :  PC + 1
				: 프로그램 카운터의 값을 1 증가
					: 만약에 명령어의 크기가 커서 2바이트에 저장되있으면 1 증가가 아니라 2 증가이긴 함. 어쩄뜬 항상 1 증가는 아니란 것. 편의상 그렇게 표시한거임


		- 세번째 주기(t2) :  IR ← MBR
			: 마찬가지로 명령어를 이동
			:  MBR에 있는 명령어를 명령어 레지스터인 IR로 이동시킴



	: 실행 사이클 >> 3명령어 코드를 해독(decode)하고, 그 결과에 따라 필요한 연산들을 수행
		: CPU가 수행하는 연산들의 종류
			▪ 데이터 이동: CPU와 기억장치 간 혹은 I/O장치 간에 데이터를 이동<< load.move..
				: LOAD, addr 명령어 사이클
					- 첫번째 주기(t0) :  MAR ← IR(addr)
						: IR 의 주소부분은 MAR 로 전송

					- 두번째 주기(t1) :  MBR ← M[MAR]
						: 데이터의 주소를 기반으로 실제 데이터를 가져온다
						: MBR 에는 데이터가 있게 된다


					- 세번째 주기(t2) : AC ← MBR
						: 데이터를 AC에 적재



			▪데이터 처리: 데이터에 대하여 산술 혹은 논리 연산을 수행 
			
			▪데이터 저장(=쓰기): 연산 결과 데이터 혹은 입력장치부터 읽어드린 데이터를 기억장치에 저장 << stop

				: 기억 장치 쓰기 동작 >> 주소, 데이터,쓰기 제오신호
				: STA[STOP] 명령어 >> 쓰기 동작
					- 첫번째 주기(t0) :MAR ← IR(addr)
						: 저장할 IR 의 주소부분은 MAR 로 전송
						: 주소 정보 저장

					- 두번째 주기(t1) : MBR ← AC
						: 데이터 정보 저장


					- 세번째 주기(t2)  : M[MAR] ← MBR
						: 쓰기 제어 신호를 보내고, 데이터를 MAR 이 지정하는 위치에 저장(쓰기) 한다

					: 모든 명령어에 대한 인출 및 실행 사이클 구하는 식 >> 클럭주기* ( 3+3)
						: 클럭주기 >> 1/클록주파수


				: Add, addr 명령어 >> 기억장치에 저장된 데이터를 AC의 내용과 더하고, 그 결과는 다시 AC에 저장하는 명령어. 읽기 동작
					: 읽은 값을 더한다는거다. 쓰기가 아니다
					: load 명령어와 거의 같은데 산술연산이 추가된 것

					- 첫번째 주기(t0) :MAR ← IR(addr)
						: 읽기할 IR 의 주소부분은 MAR 로 전송
						: 주소 정보 저장

					- 두번째 주기(t1) : MBR ← M[MAR]
						: 읽어온 값을 CPU에 저장한다


					- 세번째 주기(t2)  : AC← AC + MBR
						: AC 에 기존에 저장되있던 값과 MBR 에 저장된 값을 (ALU가) 더하고, 그 값을 AC에 저장한다
			
						

			▪프로그램 제어: 프로그램의 실행 순서를 결정 << jump
				: jump명령어 >>실행순서를 변경
					- 첫번째 주기(t0) : PC ← IR(addr)
						: 명령어의 오퍼랜드(분기할 목적지 주소)를 PC에 저장
						: 다음 명령어 인출 사이클에서 해당 주소의 명령어가 인출되므로, 분기가 발생
					: 모든 명령어에 대한 인출 및 실행 사이클 구하는 식 >> 클럭주기* ( 3+1)
						: 클럭주기 >> 1/클록주파수






	: 명령어의 구조
		: 연산코드(OP code) >> CPU가 수행할 연산을 지정

		: 오퍼랜드(operand) : 명령어 실행에 필요한 데이터가 저장된 주소(addr)



		
