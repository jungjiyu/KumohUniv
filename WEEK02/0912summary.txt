** 29쪽 시험 유력



cpu -> 명령어를 실행한다

명령어 사이클: CPU가 한 개의 명령어를 실행하는 데 필요한 전체 처리 과정
	• CPU가 프로그램 실행을 시작한 순간부터 전원을 끌 때까지 반복
	• 분류
		1. 인출 fetch 사이클 : 기억장치로부터 명령어를 읽어오는 단계
			: IR 레지스터에 저장되는 단계까지

		2. 실행 execution사이클 : 명령어를 해독하고 실행
			: 명령어를 해독 >> 어떤 종류의 연산을 수행해야되즌지



명령어 실행에 필요한 cpu 내부 레지스터
	- 프로그램 카운터 : 다음에 인출"할" 명령어의 주소를 가지고 있는 레지스터
	- 누산기(Accumulator, AC) : 데이터를 일시적으로 저장하는 레지스터
		: 산술/논리 연산관련

	- 명령어 레지스터(Instruction Register, IR) : 가장 최근에 인출"된" 명령어 코드가 저장되어 있는 레지스터
	- 기억장치 주소 레지스터(Memory Address Register, MAR) : 주소 버스와 cpu버스를 연결
		: 속도 차 극복 (택배보관함)

	- 기억장치 버퍼 레지스터(Memory Buffer Register, MBR) : 데이터버스와 cpu버스를 연결
		: 속도 차 극복


기타 cpu 내부 레지스터
	- 데이터 레지스터(Data Register, 범용 레지스터) : 그냥 데이터 일시 저장
	- 입출력 주소 레지스터(I/O Address Register, I/O AR) 
	- 입출력 버퍼 레지스터(I/O Buffer Register, I/O BR)
	- 스택 제어 레지스터(Stack Control Register, Stack Pointer, SP)
		:스택이다보니 후입선출, push pop
		: 블록 >> 메모리의 끝 부분
			: stack <- 보통 끝 부분
				- sp (stack point)
				- base

	- 상태 레지스터(Status Register, SR) : 특정 조건 발생을 표시하는 데 사용
		: 명령어 실행 결과에 따른 조건 플래그(condition flag)들 저장
			: S Z C E V I P
			: 조건 플래그
				▪부호(S) 플래그: 직전에 수행된 산술연산 결과값의 부호 비트를 저장 (양수:
0, 음수: 1)
				▪제로(Z) 플래그: 연산 결과값이 0이면, 1로 세트
				▪올림수(C) 플래그: 덧셈이나 뺄셈에서 올림수(carry)나 빌림수(borrow)가
발생한 경우에 1로 세트
				▪동등(E) 플래그: 두 수를 비교한 결과가 같게 나왔을 경우에 1로 세트
				▪오버플로우(V) 플래그: 산술 연산 과정에서 오버플로우가 발생한 경우에 1
로 세트
				▪인터럽트(I) 플래그
					: 인터럽트. 현재 cpu가 처리하고 있는 동작을 방해 << when? 더 급한게 들어왔을떄

					- 인터럽트 가능(interrupt enabled) 상태이면, 0으로 세트
					- 인터럽트 불가능(interrupt disabled) 상태이면, 1로 세트
						: 매우 중요한 명령어인 경우 ... 


				▪슈퍼바이저(P) 플래그
					• CPU의 실행 모드가 슈퍼바이저(커널) 모드(supervisor mode)이면, 1로 세트
						: 쉽게 말하면 관리자 모드

					• 사용자 모드(user mode)이면, 0으로 세트



클록 주파수와 클록 주기
❑클록(Clock) : 컴퓨터의 모든 부품이 일정한 속도로 작동하기 위한(=동기화위한) 전기적 진동(pulse)
	: 타이밍을 보통 클록이라는 전기적 신호로 맞춘다

	: 클록 수가 빠르면 처리 속도가 "대체로" 빠른 편 (항상은 x)

	: 구성
		: 상승 엣지rising edge
		: 하강엣지 falling edge

	: 클록 주파수(Hz 단위) >> 1초에 클록이 몇 번 발생하는지를 의미
		: 1초에 10^9 (1억)번 클록이 발생하면 클록 주파수는 1GHz (기가헤르츠)
			: 이때 클럭 주기 >> 1나노 세컨드

		: 클록주파수가 2GHZ
			: 이때 클럭 주기는 >> 0.5 나노 세컨드

	: 클록 주기 >> 다음 신호가 올떄까지의 간격
		: 그러니까 상승 엣지 다음의 상승 엣지가 등장하는 시점
		: 클록주기와 클록 주파수는 반비례
			: 클록 주기 = 1/클록주파수


	

❑ 마이크로 연산 : CPU 클록의 각 주기(딱 한 주기) 동안 수행되는 기본 단위의 동작
	: 인출 사이클(명령어 레지스터에 저장하는 단계까지)의 마이크로 연산 >> 3개의 마이크로 연산이 필요
		- 첫번째 주기(t0) :  MAR ← PC 
			: 주소 이동하는것.
			:  PC에서 명령어의 주소를 꺼내 MAR 에 저장한다. 대기시킨다.

		- 두번째 주기(t1) :  MBR ← M[MAR], PC ← PC + 1
		    : 명령어가 이동하는 것
		    : MBR ← M[MAR]
			: M == 기억장치 .
				: MAR 을 기반으로(=명령어 주소 기반으로) M에 접근해서 명령어를 가져온다
					: 배열같이 ...

			: 명령어를 MBR 로 옮길 때까지

		    :  PC + 1
				: 프로그램 카운터의 값을 1 증가
					: 만약에 명령어의 크기가 커서 2바이트에 저장되있으면 1 증가가 아니라 2 증가이긴 함. 어쩄뜬 항상 1 증가는 아니란 것. 편의상 그렇게 표시한거임


		- 세번째 주기(t2) :  IR ← MBR
			: 마찬가지로 명령어를 이동
			:  MBR에 있는 명령어를 명령어 레지스터인 IR로 이동시킴



	: 실행 사이클 >> 3명령어 코드를 해독(decode)하고, 그 결과에 따라 필요한 연산들을 수행
		: CPU가 수행하는 연산들의 종류
			▪ 데이터 이동: CPU와 기억장치 간 혹은 I/O장치 간에 데이터를 이동<< load.move..
				: LOAD, addr 명령어 사이클
					- 첫번째 주기(t0) :  MAR ← IR(addr)
						: IR 의 주소부분은 MAR 로 전송

					- 두번째 주기(t1) :  MBR ← M[MAR]
						: 데이터의 주소를 기반으로 실제 데이터를 가져온다
						: MBR 에는 데이터가 있게 된다


					- 세번째 주기(t2) : AC ← MBR
						: 데이터를 AC에 적재



			▪데이터 처리: 데이터에 대하여 산술 혹은 논리 연산을 수행 
			
			▪데이터 저장(=쓰기): 연산 결과 데이터 혹은 입력장치부터 읽어드린 데이터를 기억장치에 저장 << stop

				: 기억 장치 쓰기 동작 >> 주소, 데이터,쓰기 제오신호
				: STA[STOP] 명령어 >> 쓰기 동작
					- 첫번째 주기(t0) :MAR ← IR(addr)
						: 저장할 IR 의 주소부분은 MAR 로 전송
						: 주소 정보 저장

					- 두번째 주기(t1) : MBR ← AC
						: 데이터 정보 저장


					- 세번째 주기(t2)  : M[MAR] ← MBR
						: 쓰기 제어 신호를 보내고, 데이터를 MAR 이 지정하는 위치에 저장(쓰기) 한다

					: 모든 명령어에 대한 인출 및 실행 사이클 구하는 식 >> 클럭주기* ( 3+3)
						: 클럭주기 >> 1/클록주파수


				: Add, addr 명령어 >> 기억장치에 저장된 데이터를 AC의 내용과 더하고, 그 결과는 다시 AC에 저장하는 명령어. 읽기 동작
					: 읽은 값을 더한다는거다. 쓰기가 아니다
					: load 명령어와 거의 같은데 산술연산이 추가된 것

					- 첫번째 주기(t0) :MAR ← IR(addr)
						: 읽기할 IR 의 주소부분은 MAR 로 전송
						: 주소 정보 저장

					- 두번째 주기(t1) : MBR ← M[MAR]
						: 읽어온 값을 CPU에 저장한다


					- 세번째 주기(t2)  : AC← AC + MBR
						: AC 에 기존에 저장되있던 값과 MBR 에 저장된 값을 (ALU가) 더하고, 그 값을 AC에 저장한다
			
						

			▪프로그램 제어: 프로그램의 실행 순서를 결정 << jump
				: jump명령어 >>실행순서를 변경
					- 첫번째 주기(t0) : PC ← IR(addr)
						: 명령어의 오퍼랜드(분기할 목적지 주소)를 PC에 저장
						: 다음 명령어 인출 사이클에서 해당 주소의 명령어가 인출되므로, 분기가 발생
					: 모든 명령어에 대한 인출 및 실행 사이클 구하는 식 >> 클럭주기* ( 3+1)
						: 클럭주기 >> 1/클록주파수






	: 명령어의 구조
		: 연산코드(OP code) >> CPU가 수행할 연산을 지정
		: 오퍼랜드(operand) : 명령어 실행에 필요한 데이터가 저장된 주소(addr)



어셈블리 프로그램의 실행 과정
	: 10진수 배정됬다고 하면
	: ex 22페이지 ) 
		LOAD >>  1 
		ADD >> 5
		STA >> 2
		JUMP >> 8

	: LOAD(1) 250, PC → 100번지
	    1. 인출
		(1) 읽어옴
		(2) 프로그램 카운터는 0101 로 변경

	    2. 실행
		(1) ACL 로 이동

	: ADD(5) 251, PC → 101번지
	    1. 인출
		(2) 프로그램 카운터는 0102 로 변경

	    2. 실행

	: STA(2) 251, PC → 102번지
	    1. 인출
		(2) 프로그램 카운터는 0103 로 변경

	    2. 실행


	: JUMP(8) 170, PC → 103번지
	    1. 인출
		(2) 프로그램 카운터는 0104 로 변경

	    2. 실행
		(?) 프로그램 카운터를 170번지(?) 로 변경



간접 사이클
	: 실제로 잘 사용되진 않지만 알고 있어야
	: 인출 사이클과 실행 사이클중간에 추가될 수 있다
	: 실제로 사진의 A 는데이터의 주소의 주소 >> 이중 포인터
		: 주소 버스가 16개 >> 2^16개의 주소를 지정가능
		: 16 bit 전체라고 했을때 , (4bit 는 연산코드) 12bit가 주소저장부분이되므로, 2^12 이고, 주소저장부분에 저장할 수 있는 부분은 2^12이다. 이떄 쓸 수 있는게 간접 주소 지정방식.
			: 그러니까 데이터의 주소를 저장하는게 아니라 데이터의 주소의 주소를 저장하는거다

	: 간접 비트 >> 실제 데이터의 주소를 저장하는지,  데이터의 주소의 주소를 저장하는지 나타낸다
		; 보통 I 로 표현한다
	


간접 사이클의 마이크로 연산
	- 첫번째 주기(t0) :MAR ← IR(addr)
		: addr 은 데이터의 주소의 주소이다


	- 두번째 주기(t1) : MBR ← M[MAR]
		: 읽어온 값을 CPU에 저장한다


	- 세번째 주기(t2)  : IR(addr)← MBR
					
	: 인출명령어+ 실행명령어+ 간접 에서의 수행 시간 == 클록주기× (3+ 실행명령어클록주기+3) 



인터럽트 사이클
	: 인터럽트 >> 정상적인 프로그램 실행 중에 또 다른 프로그램의 실행 요구로 현
재 실행 중인 프로그램을 중단시키고 요구된 프로그램을 실행	
		:  상호 작용을 빨리하기 위하여 필요

	: 인터럽트 서비스 루틴(Interrupt Service Routine, ISR) >> 인터럽트를 처리하기 위하여 수행되는 프로그램 루틴. 인터럽트 처리를 위한 프로그램.

	: 인터럽트 벡터 테이블(interrupt vector table)  >> 다양한 인터럽트 신호를 처리하는 ISR의 시작 주소를 포함. 인터럽트 해서 중지된 서비스의 재개를 위한 테이블.
		: 인터럽트 한 다음에 복귀를 해야하고 이런건 스택에 저장되는 것


	: 인터럽트 처리 과정
		▪① 인터럽트 요청 신호가 발생
		▪② CPU는 현재 수행 중인 명령어까지만 완료한 후, 수행 중인 프로그램을
일시 중지
		▪③ 수행 중인 프로그램 상태(PC의 내용 등)를 안전한 장소([예] stack)에 보
관
		******: 프로그램 카운터 값을 저장해야된다

			: 일반적으로 스택은 주기억장치의 끝 부분을 사용


		▪④ 인터럽트의 원인을 찾아 해당 인터럽트 서비스 루틴을 실행
			: 해당 인터럽트 서비스 루틴의 시작 주소를 PC에 적재

		▪⑤ 인터럽트 서비스 루틴이 끝나면 보관해 두었던 레지스터 내용과 PC 내
용을 "복구"하여 인터럽트 당한 프로그램을 중단된 곳부터 다시 수행


	: 인터럽트 사이클의 마이크로 연산
		- 첫번째 주기(t0) :MBR ← PC
			: 복귀해서 수행할 명령어의 주소(인터서비스의 주소)가 PC에 있고, 이를 MBR 에 저장

		- 두번째 주기(t1) : MAR ← SP, PC ← ISR의 시작 주소
			: SP의 내용을 MAR로 전송하고, PC의 내용은 인터럽트 서비스 루틴의 시작 주소로 변경


		- 세번째 주기(t2)  : M[MAR] ← MBR, SP ← SP - 1
			: push(저장)됬으니까 1 씩 감소한다 << pop 이 아니다!
			: : MBR에 저장되어 있던 원래 PC의 내용을 스택에 저장

	: 스택 포인터(Stack Pointer, SP) >>  기억 장치에있는 어디에 있는지 표현하는 얘. 그러니까 stack의 top 포인터 같은




다중 인터럽트 >> 인터럽트 서비스 루틴을 수행하는 동안에 다른 인터럽트 발생
	: 그러니까 인터럽트 처리 중에 또 인터럽트가 들어옴
	; 다중 인터럽트의 처리방법
		sol1 : (새 인터럽트를) 걍 무시한다
		sol2 : 우선순위가 더 높은 인터럽트를 먼저 실행


<tmi> 인터럽트 우선순위
	1. 외부인터럽트 >> 전원 같은.. 외부 요인
	2. 내부인터럽트 >> 코딩 잘못했을떄 발생하는 ... 
	3. 소프트웨어 인터럽트 >> 리소스 요청하는.. 


서브 루틴 호출
	: 함수 호출 용도.. 
	: 호출된 함수를 수행하고 다시 돌아온다. 호출 후 다시 복귀한다
		: 분기 명령어와의 차이점이다 (복귀하는게)
			
	: 명령어
		CALL 명령어 >> 
		RET 명령어(return) >>

		: CALL 한 것과 복귀하는 주소가 다르다!!!
			: 200 라인에서 call 했으면 , 이후 복귀할 때는 201 라인으로 복귀한다 (한 줄 뒤)

		: 단순히 실행 순서만 변경할 때 사용할 때는 분기(branch) 명령어
사용
		

	: CALL X 명령어의 마이크로 연산
		- 첫번째 주기(t0) :MBR ← PC
			: 복귀해서 수행할 명령어의 주소(인터서비스의 주소)가 PC에 있고, 이를 MBR 에 저장

		- 두번째 주기(t1) : MAR ← SP, PC ← X
			: X 는 시작 주소
		
		- 세번째 주기(t2)  : M[MAR] ← MBR, SP ← SP - 1


	: RET 명령어의 마이크로 연산
		- 첫번째 주기(t0) :  SP ← SP + 1
		- 두번째 주기(t1) : MAR ← SP
		- 세번째 주기(t2)  : MBR ← M[MAR]
		- 네번째 주기(t3)  : PC ← MBR


	: 호출되서 도망갈떄 (현재위치가) PUSH , 복귀할 때 POP 되는 것


제어구너 
