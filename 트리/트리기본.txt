트리 
	: 비선형 자료구조로, 부모- 자식의 계층적 관계를 나타낸다
	: n 진트리 >> 부모가 최대 n 개의 자식을 가지는 트리
	: 뿌리가 거꾸로 있는 꼴이라고 보면 됨.
	: 구성
		루트 >> 최상위 노드
		부모 노드 >>
		자식 노드 >> 
		리프. 말단 노드 >> 더이상 자식이 없는 노드. 최하위 노드.
		서브 트리 >> 트리 안의 또 다른 트리의 구조가 나타나는 것
		간선 . edge >> 길
		레벨 >> 루트에서 몇 단계를 거쳤냐. 층.
			: 교재에서는 루트 노드를 레벨 1 로 시작했으나, 현이c의 경우 루트 노드를 레벨 0 으로 시작함.
			: (교재 기준) 레벨 i 에서의 최대 노드의 개수는 2^( i-1) 개

		높이 >> 레벨의 최대 차수(최대 레벨.)
			: (교재 기준)  노드가 n개 있을 때 lg(n+1)
			: (교재 기준) 높이가 h 일때 전체 노드의 최대 개수는 2^h -1

	: 이진 트리의 종류
		1. 완전 이진 트리 complete binary tree : 리프 층 제외 모든 노드가 꽉 차있고, 마지막 레벨은 왼쪽부터 채워져 있는 트리.
		2. 정 이진 트리 full binary tree : 자식이 0개 혹은 2개(1개는 안됨!!!)의 자식을 가지는 트리
		3. 포화 이진 트리 perfect binary tree : 모든 레벨의 노드가 꽉 차있는 트리
			: 포화이진트리 ⊂ 완전이진트리
				: 포화 이진 트리인 트리는 완전 이진 트리라고 할 수 있지만, 완전 이진 트리라고 포화 이진 트리인지는 모르는 거다.


: 이진 트리 순회 
	: 방식 >> 부모를 언제 방문하냐 따라 갈림
		1. 중위 순회 >> 왼 부 오
			(1) 최하단 왼쪽 자식까지 이동 
			(2) 최하단 왼쪽 노드 출력
			(3) 부 오 순으로 출력하면서 루트 노드 까지 올라옴
			(4) 루트 노드 출력 
			(5) 남은 영역에서 또 최하단 왼쪽 자식으로 이동
			(6) 최하단 왼쪽 노드 출력
			(7) 부 오 순으로 출력하면서 남은 영역의 최상위 노드까지 올라옴
			(8) 최상위 노드 출력
			(9) 5~8 을 반복
			(10) 마지막으로 남은 최하단 오른쪽 노드 출력

		3. 전위 순회 >> 부 왼 오
			(1) 루트 노드 출력
			(2) (부모)노드 출력하면서 최하단 왼쪽 자식 까지 밑으로 이동
			(3) 최하단 왼쪽 노드 출력
			(4) 오른쪽 노드 출력하면서 루트 노드까지 올라옴
			(5) 남은 영역에서 (부모)노드 출력하면서 최하단 왼쪽 자식 까지 밑으로 이동
			(6) 최하단 왼쪽 노드 출력
			(7) 오른쪽 노드 출력하면서 최상위 노드까지 올라옴
			(8) 5~7 을 반복
			(9) 마지막으로 남은 오른쪽 노드 출력

		2. 후위 순회 >> 왼 오 부
			(1) 최하단 왼쪽 자식까지 이동 
			(2) 최하단 왼쪽 자식 출력
			(3) 오 부 순으로 출력하면서 루트 노드까지 올라옴
			(4) 남은 영역에서 최하단 왼쪽 자식으로 이동
			(5) 최하단 왼쪽 자식 출력
			(6) 오 부 출력하면서 위로 올라옴
			(7) 4~6 반복
			(8) 마지막으로 남은 루트 노드 출력


	: 자료구조
		typedef Node{
			int data;
			struct Node* left; // 왼쪽 자식 가리킴
			struct Node* right; // 오른쪽 자식 가리킴
		}Node;

	: 연결리스트에서 첫 노드를 가리키는 head 포인터 역할처럼, tree 에서는 최상위 노드를 root 포인터가 가리킨다.

	: 출력 구현	
		: print 문을 어디다 두느냐 전위/중위/후위 가 구현이 됨
		void display(Node *node){
			if( node ){
				display( node->left );
				printf("%d ", node->value);
				display(node->right );
			}
		}
