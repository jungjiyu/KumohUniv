
<헷갈리는거 정리>

구조체라고해서 다 동적할당해서 쓰는게 아니다. 그냥도 쓸 수 있다.

메크로 상수 선언 하는 법 : #define 상수명 값
	: " ; " 안붙이는거 주의

switch 문의 case : case 다음 한칸띄고 괄호 없이 바로 숫자 쓰고 ':' 찍는거다
	ex) case 1 :

입력 받고 화이트 스페이스 지우기 : while (getChar() != '\n');

화면 지우기: system("cls");
뭐눌러야 계속 진행되게 하기: system("pause");

NULL 도 사실상 0 이므로 조건문 부분에 걍 쓸 수 있다.


----------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------
tip : 
	1. *입"후"출 보다는  *입"선"출 로 표현을 한다

스택 Stack
	: 데이터를 ( 초밥접시처럼 ) 차곡차곡 쌓아올린 자료구조로, push 와 pop 이 일어난다
		: push 삽입
		: pop 삭제

	: 후입선출.  LIFO( LastInFirstOut ) .

	: 배열 혹은 연결리스트로 구현한다.


배열로 stack 구현
	: 어느 위치까지 push 됬는질 기억할 top 이란  변수(포인터는 아님)가 필요하다
	: stack 의 상태 
		UnderFlow 상태 : top == -1 인상태.
			== 아직 저장된 데이터가 없다 
			== 더이상 삭제할 데이터가 없다.

		push k 개 된 상태:  top == k-1 인 상태.
			: top == 0 일때 1개 push 된거다

		OverFlow 상태: ( stack 사이즈가 m 이라고 했을때) top == m-1 인데 더 push 하려고 하는 상황
			: 그러니까 최대치로 push 한 상태서 또 push 하려고 하는 상황			

	: 배열에서 이미 들어온 값을 (새로운 값으로 대체할 순 있어도) 실제로 삭제를 할 순 없기 때문에, 그냥 top 을 한칸 낮추는 방식으로 "논리적"인 삭제를 한다. >> 물리적인 삭제가 아니다. top 위에 남아있는 값들은 걍 쓰레기 값으로 여겨진다.

	: 구현
		: push >> 주의 : overflow 상황
			if (stack->top < SIZE - 1) stack->ary[++stack->top] = val;
		: pop >> 주의: underflow 상황
			if (stack->top > -1) return stack->ary[stack->top--]; // 삭제대상값을 리턴하면서 top 을 낮춤
		: 완전 비우기
			stack->top = -1; 

연결리스트로 stack 구현
	: 맨 앞에 insert하는 방식으로 단일 리스트를 만든다.
	: 이미 가장 앞 노드를 가리키는 head 란 포인터가 있어서 따로 top 이란 포인터가 필요 없다
	: stack 의 상태 
		: UnderFlow 상태 : head == NULL 인 상태
			== 아직 저장된 데이터가 없다 
			== 더이상 삭제할 데이터가 없다.

		:  OverFlow 상태가 존재하지 않는다
			: 사이즈 제한이 없고 필요한 만큼 그때 그때 만들 수 있어서 그렇다
		
	: 배열로 구현한 stack 과는 다르게 free 를 통해 pop 할때 실제로 free 를 통해 삭제 가능하다 >> 물리적인 삭제

	: 구현
		: push
			: 리스트의 가장 앞에 insert 하는거라 매번 head 의 업데이트가 필요
			
			Node* newNode = (Node*)malloc(sizeof(Node));
			newNode->val = val;
			newNode->next = *head;
			*head = newNode;

		: pop >> 주의 : underflow 상황

		if (*head != NULL){
			Node* tmp = *head;
			int val = tmp->val;
			*head = (*head)->next;
			free(tmp);
			printf("%d 가 pop 됬습니다\n",val );
		}



		
