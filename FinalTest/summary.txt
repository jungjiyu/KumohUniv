큐 >> 먼저 업뎃 후, 삽입/삭제
    (1) 배열기반 큐
	: 최대 삽입 가능한 갯수 >> MAX_SIZE-1 . for 문 돌릴 떄 주의.

    (2) 연결리스트기반 큐
	: 언더플로우상태 >> front == NULL
	: front ,rear  "포인터" 를 함수를 통해 변경하기위해 
		: 함수 파라미터는 Node ** front,  Node ** rear 로 선언
		: arg 는 &front , &rear

	: enqueue 할 때,  "첫 노드 삽입인경우"에 대한 처리 필요.
		: *rear = *front = newNode; //  (front 와 rear 의 초기화)
	: dequeue 할 때, "마지막 노드 삭제인 경우"에 대한 처리 필요

	: dequeue 와 enqueue 할 때 , 두 경우 모두 파라미터로 front 와 rear 를 필요로 한다. ( 삽입한다고 rear 만, 삭제한다고 front 만 필요한게 아니다)
		


스택 >> 먼저 업뎃 후 삽입 , 삭제저장후 업뎃. (스택은 큐와 달리 따로 삭제에대해저장하는게없어서 얘만 순서 다른것)
	: top 
		: -1 로 초기화한다
		: +1 이후 삽입한다
		: top == 마지막삽입요소"인덱스"
		: top + 1 == 삽입된요소"갯수"




큐응용
	: 구조체타입 vs 구조체포인터타입 
   	  : Queue queue , Stack stack 선언 한 경우 >>  push(&stack , c); , enqueue(&queue, c); 
	  : Queue* queue , Stack* stack 선언 한 경우 >>  push(stack , c); , enqueue(queue, c); 
		: 함수쪽은 두 케이스 모두 동일

	: strlen 사용 시 <string.h> 포함 해야됨.

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

**반환값 적용 하는거 잊어먹음 안된다 : tree 기초 의 insert 함수 , tree 응용(BST)의 delete 함수
  >>내부에  다음 둘도 함께 자연스럽게 필수적
	1. 마지막 return node ; 문  과, 
	2. 호출부의 루트업데이트도 
 
	



선형구조: 하나씩 순차적으로나열
비선형구조: 다음에 여러개도 올 수 있음 


반환값 적용하는거 잊어먹음 안된다.
   : insert 호출부에서
	(1) root = insert(root, rand() % 90 + 1);
		: insert 는 최종적으로 삽입이 반영된 루트노드를 반환하므로, 그를 새로 받아야된다.

  : insert 내부에서
	(2) cur->left = insert( cur->left , key);  
	(3)  cur->right = insert( cur->left , key);  

insert 내부에서 젤 처음에 cur == NULL 검사를 해주는걸 잊음 안된다 
insert 내부에서 마지막에 return 해주는거 잊음 안된다 >> return cur





각 순회 함수에서 , 노드를 수정하지 않더라도 NULL 값의 여부를 확인하기 위해선 반드시 포인터 타입으로 받아야된다. 아무리 사용자 정의타입이라 하더라도 , 포인터 타입이 아닌 변수가 주소를 저장할 수 없어서, "포인터타입이아닌변수 == NULL" 와 같이 비교하면 에러 나버린다.
	void postorder(Node* cur) { // Node cur 하면 
	if (cur == NULL) return; // 여기서 에러난다.
	printf("%d->", cur.key); // 이부분 자체에선 에러 안난다
	.
	.
	.




이진트리의 전위순회(preorder), 중위순회(inorder), 후위순회(postorder) 중 두 가지가 주어졌을 때 나머지 하나를 구하는 법
	: 전위순회 >> 루트 왼 오
	: 중위순회 >> 왼 루트 오
	: 후위순회 >> 왼 오 루트
	: 반드시 중위순회가 힌트로 주어져야 풀 수 있다.
	: 전위순회에서 첫 번째 노드는 항상 루트 노드
	: 후위순회에서 마지막 노드는 항상 루트 노드


	case1. 중위순회 && 전위||후위 순회 힌트
		step 1 : 루트노드get >> 전위순회의 첫 노드 || 후위순회의 마지막 노드
		step 2. : 중위순회에서 루트노드를 기준으로 2분할하고, 왼쪽 서브 트리부터 탐색. (왼쪽이 모두 끝나야 오른쪽으로 go)
		step 3 : "중위순회의 해당서브트리"와 비슷한 얘들끼리 뭉쳐진 부분을 "전위순회 || 후위순회 " 에서 찾고, 찾은 영역의 "가장 앞 || 끝 노드" 를 중위순회의 해당 서브트리의 루트 노드로 지정함. 이를 서브트리에 노드가 하나 남을 때까지 반복. 
		step 4 : 분할한 트리를 후위 || 전위 순회로 재구성 >> 왼 오 루트 || 루트 왼 오 식으로, 작은 얘들부터 시작하여 거슬러 올라감 
 
	

트리를 그리는 방법 >> 위에서 전위/후위 구하는 과정에서 분할된 중위순회를 루트를 기준으로 분석하여 그림됨. so EASY


---------------------------------------------------------------------------------------------------

insert 함수
	: 초기화 대한 작업 해줘야!!! >>루트가 NULL 이면, root 에 다이렉트로 newNode 할당!!


중복여부검사하는 함수
	: cur >> 최종적으로 insert 함수에서 활용되는 변수로, 연결당할말단노드를 의미
	: par >> cur 의 업데이트 전 값을 저장할 용도이고, 순회전 NULL 로 초기화
	: while 문 내부
		if >> 같은지( tree->cur->key == key), 맞으면 return 1;
		else if >> cur 키값보다 작은지
			step1. cur 값을 par 에 임시저장
			step2. cur 값이 리프 노드인지 검사( tree->cur->L == NULL), 맞으면 return 0;
			step3. 리턴안되고넘어왔음 업뎃( cur = cur->L)

		else if >> cur 키값보다 큰지
			위의 로직과 비슷한데, cur->L 을 cur->R 로 바꾼...



delete 함수
	: if (curNode->key == target)  내부의 두자식있는경우 "제외한" 모든 조건문에서 return 을 한다.
	: 	Node* temp = curNode; // 한 자식 case에서 free 이후에도 자식에 접근하기 위함
	: 두자식 삭제할 때 업뎃 받아야됨 >> 			curNode->L= delete(curNode->L,temp->key);



---------------------------------------------------------------------------------------------------


퀵정렬

partition
	: 주의 >> swap 할 때, 해당 "값" 들만 swap 되는거지, 인덱스변수들(low,high,pivot) 자체는 변형이 없다.



---------------------------------------------------------------------------------------------------


인접리스트 기반 표현할 떄  GraphNode* adj_list[MAX_VERTICES] 는 "포인터배열"이다. 
	:   초기화 당시 공간확보 필요 없고, 이미 있는 공간의 요소 단위로 NULL 값 만 할당해주면 된다 << 가변적인 배열쓰겠다고 굳이 포인터 타입으로 선언한게 아니라. 


인접리스트의 포인터배열의 각 요소는 , "헤더"이다.  
	: list[ i ] == 정점i 에 대한 연결리스트의 0번째 노드
	: list[i].vertex == 정점i 대한 연결리스트의 0번쨰 노드의 정점값.
	: list[i].link == 정점i 대한 연결리스트의 1번째 노드.

주의 : 인접리스트의 앞에 삽입할 때, head 라는 지역변수 없이, 다이렉트로 업데이트 해야된다. 안그럼 헤더의 변경 사항이 함수 내에서만 적용되고, 밖에선 적용되지 않는다.
    GraphNode* head = g->adj_list[start]; // head 는 지역변수
    node->link = head; // 이건 잘 됨
    head = node; // 이렇게 되면 변경 사항이 함수 내에서만 적용됨 >>  g->adj_list[start] = node; 으로 다이렉트 해야됨.


dfs 기반 탐색
	(1) 인접행렬 상황 >> 해당 열에서 젤 가까운 새끼 부른다
		step1. 방문처리
		step2. 출력
		step3. 단일 for문 : 열만 움직이는
 		for (int j = 0; j < g->n; j++) {
			if(g->adjMat[v][j]&& !visited[j]) dfsMat(g,j,visited);
		}


	(2) 인접리스트 상황
		






 





	
