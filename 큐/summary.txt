큐
: 스택에서는 한쪽에서 삽입과 삭제가 일어났다면 스택에서는 양방향에서 삽입과 삭제가 이뤄짐. 한 줄서기, 파이프 같은 느낌. 
: FIFO
: rear == 뒤쪽
: front == 앞쪽

: 삽입 == enqueue
	: rear 에서 일어남	
: 삽입 == dequeue
	: front 에서 일어남

: 배열과 연결리스트 둘 다로 구현 가능


: 변수 1개만 사용?
	: 삭제를 걍 인덱스 0 에서 고정적으로 하고, 추가를 하는 인덱스를 저장하는 변수만 써서 Stack 에서 처럼 변수 하나만 쓸 수 있긴 한데 그럼 시간 복잡도가 넘 높아진다
		: 앞에서 삭제될때마다 뒤에있는 데이터를 직접 하나씩 당겨줘야되다 보니까 시간 복잡도 개 커짐

: rear 과 front 두 변수를 사용해서 구현 ( top 같이 1개만 쓰는게 아님)
	: rear
		: 삽입하려는 인덱스 (아직 삽입안된상태임)

	: front	
		: 삭제하려는 인덱스 (아직 삭제 안된 상태. 데이터가 있따)

	: 데이터는 front 부터 rear -1 인덱스까지 있는거다

	: front == rear 인 상황
		case1. 데이터가 꽉 찬 상태
		case 2. 데이터가 없는 상태

	: count 변수 >> 데이터를 삽ㅇ입ㅎ할떄 마다 +1 , 삭제할때마다 -1
		: 

	: deque 
		: 물리적인 삭제가 아니라 논리적 삭제
		: front 를 1 증가시킨다

	: 원형 큐로 구현
		: font , rear 가 모두 0 에서 시작 
		: rear 자리에 데이터 삽입할 때마다 rear 하나씩 증가 시킴
		: 굳이 쓰는 이유 >> 뒤에있는 모든 원소들을 옮겨주긴 좀그러니까
