리터럴 : 프로그래머가 직접 입력한 값
	정수 리터럴
		: 기본적으로 int 형 취급되고, long 범위의 리터럴 할당을 원하면 접미사 L을 붙여야된다.
		: 다양한 진수의 형태로 리터럴 입력이 가능하지만 출력은 걍 10진수로만 나온다
			: 2진수 --> 0b어쩌구
		****** 8진수 --> 0어쩌구
			: 16진수 --> 0x 

	문자 리터럴
		: ' 으로 감싸진다
		: 유니코드를 사용하여 한국어도 저장 간ㅇ하다
		: 유니코드도 정수이기 떄문에 유니코드 자체도 직접 입력 가능하다.
		: 단순 '' 로 빈 문자를 넣으면 컴파일 에러난다.
		: 이스케이프 문자을 사용 가능하다
			\u16진수 == 해당 유니코드 문자
			\r == 캐리지 리턴

	실수 리터럴
		: 기본적으로 double 형이고, float 형 할당을 위해선 접미사 f 를 써야한다.
	******* float 타입 값에 실수 값 넣기 위해선 필수적으로 f 명시해야된다 (안그럼 컴파일 에러)

	문자열 리터럴
		: "로 감싼다
		: 문지열은 유니코드가 아니다
		: 자바에서 줄바꿈은 \r\n 이다 (right now)
 
-----------------------------------------------------------------------------------------------------------------------------

변수 = 데이터 저장되는 메모리 번지명
	: 한 변수가 다양한 타입의 값을 저장할 순 없다.
	: 사용법
		1. 선언 : 변수의 타입과 이름 지정
			: 선언만으로는 메모리가 할당되지 않는다
				: 그래서 초기화 이전에 해당 변수를 사용하려고 하면 컴파일 에러 나는거다
			: 이름에 특수 기호는 _ 랑 $ 밖에 못 넣는다
			: 이름에는 특수 기호 뿐 아니라 한글까지 들어갈 수 있다.

		2; 초기화  : 대입연산자로 값을 최초로 대입
			: 최초로 값이 대입될 때 메모리가 할당되어 거기 값이 저장된다

	: 변수를 다른 변수에 할당하면 값의 복사가 일어난다. 
	: 자바의 경우 오버플로우 일어나면 자동으로 범위넘겨주지 않고 걍 컴파일 오류 떄린다
	: 해당 블럭 내부에서만 사용 가능하다
	*****: 별 의미 없는 블럭이어도 그렇다 ;;;


-----------------------------------------------------------------------------------------------------------------------------


타입 
	(1) 기본 타입 primitive
		: signed type 의 경위 최상위 비트는 양수(0) , 음수(1) 을 타나낸다

		1. 정수 타입 
			(1) byte : 1바이트 
		******(2) char : 2바이트 << 범위가 0 ~ 65535 로 양수이며, 유니코드 저장이 가능
				: char 에 음수 넣음 컴파일 에러 뜬다

			(3) short : 2바이트 << 범위가 -32768 ~ 로 음수 양수이다
			(4) int : 4 바이트
			(5) long : 8 바이트 << long long 없고 걍 long 이다

	
		2. 실수 타입 : 부동 소수점 방식을 사용한다.
			(1) float : 4바이트
			(2) double : 8바이트


		3. 논리 타입
			boolean : true 혹은 false 를 저장한다. <-- 0 과 1 이 아님 주의


	(2) 레퍼런스 타입
		1. String : 문자열 저장 


-----------------------------------------------------------------------------------------------------------------------------
형변환 : 데이터 손실을 최소화 하는 쪽으로 일어난다
	자동형변환 promotion
		(1) 큰 타입 변수에 작은 타입값을 넣을 때
			: 실수 변수에 정수값 넣을 때는 항상 발생한다
			******: float 타입변수에  long 타입 값을 넣을 때도 발생해버린다 ;;
				: 실수타입이 정수타입보다 혀용범위가 더 크기 때문
		****** 예외적으로 char 값에 byte 값을 할당해도 자동형변환 되지 않고, 심지어 에러 발생한다
				:아무리 byte 타입 값이 음수가 아니라 할지라도 char 타입 자체의 허용 범위를 넘어서기 때문에 불가하다.

		(2) 정수 연산 할 때
			: int 이하의 피연산자는 연산 전 int 타입으로 자동 promotion 되어 연산 수행된다 
				*****: 이 경우 정수 연산의 결과는 항상 int 형 변수로 받아야된다.
				*****: int 보다 큰 long 형에 대해선 적용되지 않고, 오히려 long 타입으로 다른 피연산자가 변환된다.
						: 그러니까 byte 값 + long 값 --> long 값 + long 값 이므로 long 타입 변수에 저장해야된다.
				

		(3) 문자열 연산될때
			: + 연산자의 피 연산자가 하나라도 문자열일 경우 나머지 피연산자를 문자열로 자동 변환 시킨다.



	강제형변환 casting
		(1) 작은 타입 변수에 큰 타입값을 넣을 떄
			: 캐스팅 연산자로 괄호를 사용한다
			: 앞에 바이트를 날리고, 뒷 부분을 남긴다.  (생각해봄 데이터는 뒤에서부터 저장되니까)
			: 실수를 정수로 강제형변환 할 떄 소수점 이하 부분은 버려지고 정수 부분만 저장된다.

		(2) 문자열 <---> 기본 타입값
			1. 문자열값 ---> 문자값
				(1) 특정 위치의 문자만 >> 문자열.charAt(인덱스)
				(2) 문자열 전체를 단어 배열화 >> 문자열.toCharArray( )

			2. 문자열값 ---> 문자아닌기본타입값	
				: 래퍼클래스.parse기본타입명(문자열)
					Integer.parseInt( 문자열 )
					Boolean.parseBoolean(문자열)

			3. 기본타입값 --> 문자열값
				: String.valueOf(값);
			******: 문자값을 대상으로도 쓰일 수 있다
					: 주의 ) 배열까지 대상이 되진 않는다.



-----------------------------------------------------------------------------------------------------------------------------


콘솔로 출력하기
	System.out. 
		println( )
		print( )
		printf( "형식문자열", 값1 , 값2 .. );


-----------------------------------------------------------------------------------------------------------------------------

키보드로 입력 받기
	: 하는 법
		step1. scanner 객체 생성
			Scanner scanner = new Scanner(System.in);

		step2. scanner 객체 를 대상으로 nextXXXX ( ) 메서드 사용
			: nextLine( ) 을 제외하곤 모두 화이트 스페이스를 기준으로 입력 받는다
			(1) next( )  : (화이트 스페이스를 기준으로 ) String 을 읽음
			(2) nextLine( ) : 엔터를 기준으로 String 을 읽음	
				: 입력 받은 값 자체엔 엔터 없다
			(3) next타입명( ) : 특정 타입 값을 읽음 but 문자 타입은 없음 주의
			******: 문자는 할 수 없이 next( ).charAt(0) 해야된다
				: nextDouble , nextInt( ) , ..  

		step3. scanner 객체 닫기
			: 닫아야하는 이유 >> 
				(1) 가비지컬렉션 대상은 "사용중이지 않은" 데이터가 대상인데, scanner 이라는 변수에 저 Scanner 객체가 담겨있다는 것만으로도 가비지 컬렉션 대상에서 제외됨.
				(2) 리소스를 열어놓고 닫지를 않는경우 해당 리소스가 손상될 수가 있다
				(3) 해당 리소스에 여전히 access 하고 있는 것으로 간주되 다른 곳에서 해당 리소스를 사용 못하할 수 있따.

		scanner.close( ) ;



-----------------------------------------------------------------------------------------------------------------------------
연산 
	문자열 연산 : 앞에서부터 차례댈 수행되고, 교환 법칙은 성립하지 않는다
	
문자열 비교 할 떈 == 가 아닌 equals( )  를 사용ㅎ나다.

