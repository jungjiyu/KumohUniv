자식 객체를 생성하면, 부모 객체가 먼저 생성된 다음 자식 객체가 생성된다.
	: 부모 생성자는 암묵적으로 자식생성자의 첫줄에 super( ) 로 있다. >> 부모에 기본생성자가 없으면 에러 난다
	: 만약에 부모 클래스의 param 있는 initializer 쓰고 싶으면 직접 super(arg1, arg 2 .. ) 명시해야된다.

-----------------------------------------------------------------------------------------------------------------------------
헷갈리는 개념 정리
	컴파일러 >> 실행하기 전에 코드 전체를 한번에 다른 언어로 번역하는 프로그램.
		: 컴파일러라고 해서 무조건 결과물이 바이너리 코드인건 아니다. 

	인터프리터>> 실행할때 한 문장 단위로 다른 언어로 번역하는 프로그램


자바의 특징
	(1) 소스코드 --->  javac 가 컴파일 ---> 바이트 코드--> JVM --> 바이너리코드
		JVM⊂JRE⊂JDK

		JDK : JRE + "javac" 
			: 개발 할 경우 핋수적으로 JDK 설치
			: javac 는 소스 코드를 바이트 코드로 컴파일

		JRE : JVM + lib + 클래스 로더
			: 실행만 할 경우 JDK 말고 JRE 만 설치해도 됨

		JVM  
			: 바이트 코드 실행하는 가상 기계
			: 운영체제 별로 다름  << 운영체제 종속적
			: WORA 가능하게 해줌
			: GC 관리

			: 내부적으로 JIT 컴파일러 사용 >> 실행 속도가 빠르다
				: 실행 중에 바이트 코드를 기계어 코드로 컴파일하여 기계어를 실행하는 기법
			
				: Just In Time
				: 일반적인 컴파일 방식(정적 컴파일 방식) + 인터프리트 방식 의 컴파일러
					: 한줄씩 번역하는데 , 이미 읽어서 컴파일 했던건 캐싱해놨다가 또 등장하면 그거 써먹는다.
	
				: 주의 ) 컴파일+인터프리터 이긴 해도 JIT 인터프리터 라고 안하고 JIT 컴파일러라고만 한다

	




	(2) 객체 지향 --> 캡슐화 상속 다형성 지원 
	(3) 하나의 "소스" 파일에 여러 클래스를 작성 가능 (public 클래스는 하나만 가능)
	(4) 하나의 "클래스" 파일에는 하나의 클래스만 존재 -->  하나의 클래스 파일에 두 개 이상의 main() 메소드가 있을 수 없음
	(5) 멀티스레드
	(6) 자바는 메모리 반환 기능 없음 --> 가비지 컬렉션 :  JVM에 의해 자동 반환 
	(7) 실시간 프로그램 부적합 : GC 시점을 예측할 수 없어서
	(8) JIT 컴파일러 사용
	
-----------------------------------------------------------------------------------------------------------------------------
메모리 영역
	(1) 메서드 영역: 바이트 코드 파일 내용이 저장되는 영역. 클래스 관련 내용 저장. 
		: 해당 클래스의 메타 데이터가 저장됨 - "정적" 필드 , 상수, 메서드, 생성자

	(2) 스택: 메서드 호출 시 생기는 프레임이 생성되는 영역. 변수 저장.
		: 메서드 호출이 끝나면 프레임은 자동 제거된다
		: 프레임 내부에는 로컬 변수 스택이 있고, 여기에 (로컬 , 원시 둘 모두의 ) 변수가 저장된다
			: 원시타입의 경우 스택에 값ㅇ르 직접 저장
			:  참조 타입의 경우 힙에 실제 객체 저장후 그 주소값을 스택에 저장
		: 단순히 변수가 선언된다고 스택에 생성되는게 아니라, 값이 초기화 되어야 스택에 생성 ㅚㄴ다.

	(3) 힙 : 객체가 생성되는 영역.
		: 생성된 객체는 스택 영역 변수 혹은 메서드 영역의 필드 로 접근 가능

-----------------------------------------------------------------------------------------------------------------------------

오버라이딩 주의점
	:  A instanceof B >> A 가 부모고 B 가 자식이다 : 부자
 
-----------------------------------------------------------------------------------------------------------------------------
오버로딩과 오버라이딩
	: https://yummy0102.tistory.com/465
	오버로딩 : 매개변수만 다르면 나머지는 자유롭다
		1. 매개변수가 무조건 달라야된다 >> 자료형 혹은 갯수
			: 매개변수는 같고 반환형만 다른건 못만든다

		2.  접근제한자가 일치하지 않아도 된다

	오버라이딩 : 헤더 부분이 거의 존똑
		1. 접근제한자와 반환 형을 제외하곤 헤더 부분이 존똑이어야된다
		2. 접근제한자는 원본보다 낮은(== 제한이 낮은 == 널널한 ) 수준이어야한다.
			ex) 원본에서  protected >> 오버라이딩 할땐   protected , public 에서만 허용 

		3. 반환형
			원본 반환형이 원시 타입 혹은 void 인 경우 : 존똑 이어야한다

			원본 반환형이 참조 타입인 경우: 원본반환형 이하의 타입을 사용 가능하다
				: https://programming-beard.tistory.com/5
				: https://inpa.tistory.com/entry/JAVA-%E2%98%95-Object-%ED%81%B4%EB%9E%98%EC%8A%A4-clone-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC
				: 원본 반환 타입 뿐 아니러 원본 반환 타입의 자식 타입도 반환할 수 있단 말이다
				: JDK 1.5 부터 가능해졌다. (공변 반환 타입)
-----------------------------------------------------------------------------------------------------------------------------

Object 클래스에서 많이 오버라이딩하는 대표적인 메서드
	: Object 클래스
		: 모든 클래스의 부모 클래스. ( 만들면 자동으로 extends 된다) >> Object 의 멤버를 모두 사용 가능
		: != Objects 클래스

	: 사용자 정의 자료형을 구현할 때 오버라이딩 필요
	(3) Object clone( ) throws CloneNotSupportedException	
	******: 주의 
			1.clone( ) 의 경우 특별하게 별도로 "implements Cloneable " 해줘야 오버라이딩 가능하다
				: Clonealbe 이 구현되지 않은 clone 에서는 CloneNotSupportedException 예외가 발생된다
			2. Object 의 메서드 반환형이 Object 이긴 하지만 오버라이딩 특성상 반환형은 자식 타입도 가능해서 , 반환형을 사용자정의타입으로 해도 문제 없다
			3. throws CloneNotSupportedException 처리해줘야된다

		: Object 는 >> 해당 객체의 모든 필드에 얕은 복사를 적용하여 새로운 객체의 필드값을 생성하여 반환
			: 원시 타입 값의 경우 별 문제 없지만, 레퍼런스 타입의 경우 한쪽이 바뀌면 다른 쪽도 바뀌는 불상사 일어나므로 오버라이딩이 필요하다

		: 오버라이딩 방향 >> 내부적으로 아예 새로운 객체를 만들고 직접 값을 복사한다.
			: ?

	(2) boolean equals(Object obj) 
		: Object 는 >> 주소값 만으로 비교 
			:  그러니까 "==" 랑 ㅈㄸ 인거다
		: 오버라이딩 방향( 다른 제공 클래스에서는 ) >> 논리적 값을 비교
			1. 비교 대상이 자기 자신인가 ? 
      				if (this == o) return true; 
	
			2.  비교 대상이 해당 타입의 객체인가 ? >> 아니면 바로 귀가 조치 , 맞음 계속

	    		if (this == o) return true;    	
			if ( (o instanceof Person) ){ 
				3단계 내용
			}
			return false; 

			3. 필드값이 세세하게 일치하는가?
			******step1. 매개변수를 해당 타입으로 강제형변환
				step2. step1에서 구한 변수를 대상으로 필드값 비교 >> 만족하지 않으면 바로 false 로 귀가. (끝까지 살아남으면 true 반환 )
					case1 : 비교 필드가 원시 타입 >> 단순 " == " 로 비교
					case2 : 비교 필드가 제공 참조 타입 >> equals( )  로 비교

	    		if (this == o) return true
			if ( (o instanceof Person) ){ 
				자식타입명 어쩌구변수명 = (자식타입명)매개변수명;
				if( this.필드1 != 어쩌구변수명.필드1 ) return false ;   				
				if( ! (this.필드2. equals( 어쩌구변수명.필드2 ))  ) return false ;   				
				return true;
			}
		 	return false; 



	(1) String toString( )
		: Object 는 >> 해당 인스턴스의 해시코드 를 문자열로 반환
		: 오버라이딩 방향 ( 다른 제공 클래스에서는 )  >>인스턴스의 핵심 데이터를 문자열로 반환
		: 참고로 객체를 출력만 해도 자동적으로 .toString( ) 이 붙는다.


-----------------------------------------------------------------------------------------------------------------------------
특수값 NaN, Infinity
	: 나눗셈 혹은 나머지 연산의 2번째 피연산자가 "실수"값 0 일 때 발생
		: 정수값 0 인 경우는 걍 ArchimeticException 발생하고 끝남

	NaN << 피연산자1 % 0.0
		: Double.isNaN( 아무타입의변수 ) 로 확인 가능
		: NaN + 어떤 값 == NaN

	Infinity << 피연산자1 / 0.0
		: Double.isInfinity( 아무타입의변수 ) 로 확인 가능
		: Infininty + 어떤 값 == Ininfinty

-----------------------------------------------------------------------------------------------------------------------------
리터럴 : 프로그래머가 직접 입력한 값
	정수 리터럴
		: 기본적으로 int 형 취급되고, long 범위의 리터럴 할당을 원하면 접미사 L을 붙여야된다.
		: 다양한 진수의 형태로 리터럴 입력이 가능하지만 출력은 걍 10진수로만 나온다
			: 2진수 --> 0b어쩌구
		****** 8진수 --> 0어쩌구
			: 16진수 --> 0x 

	문자 리터럴
		: ' 으로 감싸진다
		: 유니코드를 사용하여 한국어도 저장 간ㅇ하다
		: 유니코드도 정수이기 떄문에 유니코드 자체도 직접 입력 가능하다.
		: 단순 '' 로 빈 문자를 넣으면 컴파일 에러난다.
		: 이스케이프 문자을 사용 가능하다
			\u16진수 == 해당 유니코드 문자
			\r == 캐리지 리턴

	실수 리터럴
		: 기본적으로 double 형이고, float 형 할당을 위해선 접미사 f 를 써야한다.
	******* float 타입 값에 실수 값 넣기 위해선 필수적으로 f 명시해야된다 (안그럼 컴파일 에러)

	문자열 리터럴
		: "로 감싼다
		: 문지열은 유니코드가 아니다
		: 자바에서 줄바꿈은 \r\n 이다 (right now)
		: 자바에서는 문자열 리터럴의 끝을 딱히 null 문자로 구분하지 않는다
	******: 문자열 리터럴은 String 객체이다
			 
 
-----------------------------------------------------------------------------------------------------------------------------

변수 = 데이터 저장되는 메모리 번지명
	: 한 변수가 다양한 타입의 값을 저장할 순 없다.
	: 사용법
		1. 선언 : 변수의 타입과 이름 지정
			: 선언만으로는 메모리가 할당되지 않는다
				: 그래서 초기화 이전에 해당 변수를 사용하려고 하면 컴파일 에러 나는거다
			: 이름에 특수 기호는 _ 랑 $ 밖에 못 넣는다
			: 이름에는 특수 기호 뿐 아니라 한글까지 들어갈 수 있다.

		2; 초기화  : 대입연산자로 값을 최초로 대입
			: 최초로 값이 대입될 때 메모리가 할당되어 거기 값이 저장된다

	: 변수를 다른 변수에 할당하면 값의 복사가 일어난다. 
	: 자바의 경우 오버플로우 일어나면 자동으로 범위넘겨주지 않고 걍 컴파일 오류 떄린다
	: 해당 블럭 내부에서만 사용 가능하다
	*****: 별 의미 없는 블럭이어도 그렇다 ;;;


-----------------------------------------------------------------------------------------------------------------------------


타입 
	(1) 기본 타입 primitive
		: signed type 의 경위 최상위 비트는 양수(0) , 음수(1) 을 타나낸다

		1. 정수 타입 
			(1) byte : 1바이트 
		******(2) char : 2바이트 << 범위가 0 ~ 65535 로 양수이며, 유니코드 저장이 가능
				: char 에 음수 넣음 컴파일 에러 뜬다

			(3) short : 2바이트 << 범위가 -32768 ~ 로 음수 양수이다
			(4) int : 4 바이트
			(5) long : 8 바이트 << long long 없고 걍 long 이다

	
		2. 실수 타입 : 부동 소수점 방식을 사용한다.
			(1) float : 4바이트
			(2) double : 8바이트


		3. 논리 타입
			boolean : true 혹은 false 를 저장한다. <-- 0 과 1 이 아님 주의


	(2) 참조 타입: 
		: 원시 타입의 경우 값 자체를 저장하지만 참조 타입은 객체가 생성된 메모리를 저장한다.
		: null 을 값으로 가질 수 있다
			: null == 아무런 객체를 참조하고 있지 않다
			: null 값으로 초기화 되더라도, 일단 초기화 된 변수의 경우 스택 영역에 생성된다.
			: NullPointerException : 참조타입 변수가 참조하고 있는 객체가 없는데 접근하여 활용하려고 할 떄 발생하는 예외.(오류)


		가비지 컬렉터
			: 아무런 변수한테도 참조 받지 않는 객체는 쓰레기로 취급 하여 힙 상에서 GC가 자동으로  제거해준다.
			: 자바에서는 개발자가 직접 객체를 제거할 수 없고, GC 만이 할 수 있다


			: 객체의 동일성 비교
				==  : 값을 비교하는 연산자로, 참조 타입의 경우 같은 객체를 가리키고 있는지 조사하게 된다.
					: 같은 객체를 참조하면 true, 아니면 (아무리 맥락상 내용은 같아도) false.
	

		0. 문자열 타입 String
			: 자바의 문자열은
				: 객체이다>> 문자열 객체 자체는 힙에 생성되고, 이 객체를 스택 영역의 참조 변수가 참조한다.
				: 불변(immutable)이다 >> 이는 String pool 의 구현 , 즉 객체의 재사용을 가능하게 한다
					: https://starkying.tistory.com/entry/why-java-string-is-immutable
					: 문자열 리터럴은 상수 개념이다

			: 문자열 객체 생성 방법
				(1) 문자열 리터럴
					: 문자열 리터럴 값을 사용하면 자동으로 String 객체가 생성된다.
					: Heap 영역 중에서도, String constant pool 이라는 영역에 저장되어 같은 내용의 문자열 객체는 공유, 재사용이 가능하다 << 메모리 낭비 줄일 수 있다.
						: 같은 내용이면 " == " 사용하면 true 나온다

				(2) new 연산자 사용 --> new String( "내용" )
					: 일반적인 Heap 영역에 해당 내용의 문자열 객체를 (이미 해당 내용이 존재하건 말건) 무조건 생성 시킨다 
						: 같은 내용이더라도 " == " 사용하면 false 나온다

			: 문자열 객체 비교 방법
				(1) 대상1.eqauls( 대상2) : 내용이 같은지 비교한다
				(2) == : 객체 자체가 같은지 비교한다

			: 문자열 길이 확인 방법 >> 문자열객체.length( ) 사용
				: 공백 문자도 카운트 된다

			: 문자열 대체 방법  >> 문자열객체.replace( "타켓" , "변경이후내용" )
				: 기존 문자열은 그대로 두고, 해당 내용의 문자열 객체를 "새로" 생성시킨다.
					: 문자열 리터럴은 상수 개념이라 변경 못한다.
				******: 결과를 활용하고 싶으면 (단순 replace 적용만 시키는게 아니라)  해당 리턴값을 별도로 저장해야된다 
						String str1 = str1.replace("병신" , "bingshin"); 

			: 문자열 일부 추출 방법 >> 문자열객체.subString( 타켓시작인덱스, 타겟종료인덱스+1 )
				: 2번쨰 arg 인덱스 까지가 아니라, 직전까지임을 주의
					ex) subString(0,6) // 0~5번쨰만 읽어온다
				: 결과를 활용하고 싶으면 해당 리턴값을 별도로 저장 필요
				: 문자열객체.subString( 타겟시작인덱스) 로 하면 자동으로 끝 인덱스 "까지"를 범위로 하여 추출해준다

			: 문자열특정부 위치 찾는 방법 >> 문자열객체.indexOf( "타겟문자열");
				: 해당 문자열이 시작하는 "인덱스" 를 리턴한다
				: 만약에 해당 문자열이 존재하지 않으면 -1 을 리턴한다

			: 단순히 문자열특정부분 활용하고 있는지 알아보는 방법 >> 문자열.contains( "타겟문자열");
				: true 혹은 flase 리턴한다

			: 문자열을 특정구분자를 기준으로 분리하여 문자열 "배열"을 얻어내는법 >> 문자열객체.split( "구분자문자 ")
				: '구분자' 가 아니라 "구분자" 임 주의
				: 반환 객체는 문자열 배열 객체이지, 문자 배열 객체가 아님 주의

		1. 배열 타입 : 연속된 공간에 인덱스 붙여 여러개의 값을 저장하는 구조
			: 같은 타입의 값만 저장 가능하고, 사이즈는 변경 불가
			: ArrayIndexOutofBoundsException >> 가능한 인덱스 넘어서 접근했을 떄 발생

			: 일차원 배열 배열
				: 배열 참조 변수의 선언 방법
					: 어쨌꺼나 선언부는 사이즈를 명시하지 않는다.
					sol1 . 타입 변수명 [ ] 
					sol2 . 타입[ ] 변수명
  
				: 배열 객체 생성 방법
					: 값을 저장할 메모리를 할당하는 거다
					: 단순히 다른 배열 객체를 참조하기 위해 생성한 배열 참조 변수의 경우 이 과정이 필요 없다.

					sol1 .  " new 타입[사이즈] "  
						: 선언 이후에도 할당 가능하다
						: 기본값으로 초기화까지 시켜준다 (0 혹은 null 혹은 flase)
	
					sol2 . "{ 값1, 값2, 값3 ..., 값n }"
					****** : 선언과 동시에만 할당 가능하다
							: new 연산자를 사용하지 않으니까 선언 이후에 자동적으로 인식할 방법이 없는듯?

					sol3. "new 타입[ ]{ 값1, 값2, 값3 ..., 값n }"
					****** : 선언 이후에"도" 할당 가능하다
							: 매개변수에도 이는 적용된다. 매개변수의 parameter 가 String[ ]  ary 인 함수의 arg 로 {값1, 값2 , .. } 는 불가하지만, new String[ ]{값1, 값2 , .. } 는 가능하다.

				: 배열의 길이 구하는 법 >> 배열객체.length
					: length( ) 메소드가 아닌 필드임을 주의 ( length( ) 는 문자열이다 )
						: 암기 tip --> S 가 A 보다는 더 구불거리니까 ( ) 를 필요로 한다.					
			: 다차원배열
				: 다차원배열 참조 변수 선언 방법
					: 마찬가지로 사이즈 명시 없이 [ ] 만 쓴다
					: n-1 차원의 배열을 요소로 가지는 배열을 만드는 원리이다.
					sol1 . 타입명[ ][ ] 변수명
					sol2. 타입명 변수명[ ][ ]
					sol3. 타입명[ ]  변수명[ ]

				: 다차원배열 객체 생성 방법
					: 비정방형배열. (가변배열)
						: 이차원 비정방형 배열에서의 length
							배열명.length == 배열의 열 갯수. 
							배열명[i].length == 배열의 해당 열에서의 행 사이즈
							 Σ배열명[i].length == 배열 전체의 요소 갯수 
							
						sol1. "new 타입[ 열사이즈 ][  ]"
							: 이렇게 할당하고 나서 배열명[ i ] 마다 new 타입[행사이즈] 를 할당해서 쓰면 된다.

							int[ ][ ] arr = new int[3][];
							arr[0] = new int[2];
							arr[1] = new int[4];
							arr[2] = new int[1];

						sol2. "{ { 값1 , 값 2 , 값 3, .. } , {값1 , 값 2 }, ..     } "  


					: 정방형배열. 
						sol1. "new 타입[ 사이즈1 ][ 사이즈2 ]"
						sol2. "{ { 값1 , 값 2 , 값 3, .. } , {값1 , 값 2 , 값 3, .. }, ..     } "  
	
			: 배열의 복사
				(1) 값 자체만 복사 System.arrayCopy( 복사당할배열변수, 복사당하기시잘할인덱스, 복사혜택누릴배열변수 , 복사혜택적용되기시잘할인덱스 , 복사항목수 )  
				(2) 앝은 복사  : 객체의 주소값을 복사 
					: 타배열명을 할당
					: 한쪽이 변경되면 다른쪽에도 영향 미침

				(3) 깊은 복사 : 힙의 데이터 까지 복사
					: 타배열명.clone( ) 을 할당 
					******: 기본적으로 제공되는 타입이 아닌 사용자 정의 타입인 경우 따로 clone( ) 메서드 오버라이딩 필요
		
					: 한쪽이 변경되도 다른 쪽에 영향 안미침

			: 향상된 for 문 
				: 접근 순서 ) 배열명 --> 변수명 --> 수행냉ㅇ
				for( 요소타입 변수명 : 배열명){ 
					수행내용 
				} 

		2; 클래스 
		3. 인터페이스 타입
		4. 열거 타입






-----------------------------------------------------------------------------------------------------------------------------
형변환 : 데이터 손실을 최소화 하는 쪽으로 일어난다
	자동형변환 promotion
		(1) 큰 타입 변수에 작은 타입값을 넣을 때
			: 실수 변수에 정수값 넣을 때는 항상 발생한다
			******: float 타입변수에  long 타입 값을 넣을 때도 발생해버린다 ;;
				: 실수타입이 정수타입보다 혀용범위가 더 크기 때문
		****** 예외적으로 char 값에 byte 값을 할당해도 자동형변환 되지 않고, 심지어 에러 발생한다
				:아무리 byte 타입 값이 음수가 아니라 할지라도 char 타입 자체의 허용 범위를 넘어서기 때문에 불가하다.

		(2) 정수 연산 할 때
			: int 이하의 피연산자는 연산 전 int 타입으로 자동 promotion 되어 연산 수행된다 
				*****: 이 경우 정수 연산의 결과는 항상 int 형 변수로 받아야된다.
				*****: int 보다 큰 long 형에 대해선 적용되지 않고, 오히려 long 타입으로 다른 피연산자가 변환된다.
						: 그러니까 byte 값 + long 값 --> long 값 + long 값 이므로 long 타입 변수에 저장해야된다.
				

		(3) 실수 연산할 때
			: 정수피연산자 와 실수피연산자 연산 --> 정수가 실수피연산자로 casting
			 
		(4) 문자열 연산될때
			: + 연산자의 피 연산자가 하나라도 문자열일 경우 나머지 피연산자를 문자열로 자동 변환 시킨다.



	강제형변환 casting
		(1) 작은 타입 변수에 큰 타입값을 넣을 떄
			: 캐스팅 연산자로 괄호를 사용한다
			: 앞에 바이트를 날리고, 뒷 부분을 남긴다.  (생각해봄 데이터는 뒤에서부터 저장되니까)
			: 실수를 정수로 강제형변환 할 떄 소수점 이하 부분은 버려지고 정수 부분만 저장된다.

		(2) 문자열 <---> 기본 타입값
			1. 문자열값 ---> 문자값
				(1) 특정 위치의 문자만 >> 문자열.charAt(인덱스)
					: 인덱스는 0 부터시작
				(2) 문자열 전체를 단어 배열화 >> 문자열.toCharArray( )

			2. 문자열값 ---> 문자아닌기본타입값	
				: 래퍼클래스.parse기본타입명(문자열)
					Integer.parseInt( 문자열 )
					Boolean.parseBoolean(문자열)

			3. 기본타입값 --> 문자열값
			******: 문자값을 대상으로도 쓰일 수 있다
				(1) String.valueOf(값);
				(2) 래퍼클래스.toString(값);
					



-----------------------------------------------------------------------------------------------------------------------------


콘솔로 출력하기
	System.out. 
		println( )
		print( )
		printf( "형식문자열", 값1 , 값2 .. );


-----------------------------------------------------------------------------------------------------------------------------

키보드로 입력 받기
	: 하는 법
		step1. scanner 객체 생성
			Scanner scanner = new Scanner(System.in);

		step2. scanner 객체 를 대상으로 nextXXXX ( ) 메서드 사용
			: nextLine( ) 을 제외하곤 모두 화이트 스페이스를 기준으로 입력 받는다
			(1) next( )  : (화이트 스페이스를 기준으로 ) String 을 읽음
			(2) nextLine( ) : 엔터를 기준으로 String 을 읽음	
				: 입력 받은 값 자체엔 엔터 없다
			(3) next타입명( ) : 특정 타입 값을 읽음 but 문자 타입은 없음 주의
			******: 문자는 할 수 없이 next( ).charAt(0) 해야된다
				: nextDouble , nextInt( ) , ..  

		step3. scanner 객체 닫기
			: 닫아야하는 이유 >> 
				(1) 가비지컬렉션 대상은 "사용중이지 않은" 데이터가 대상인데, scanner 이라는 변수에 저 Scanner 객체가 담겨있다는 것만으로도 가비지 컬렉션 대상에서 제외됨.
				(2) 리소스를 열어놓고 닫지를 않는경우 해당 리소스가 손상될 수가 있다
				(3) 해당 리소스에 여전히 access 하고 있는 것으로 간주되 다른 곳에서 해당 리소스를 사용 못하할 수 있따.

		scanner.close( ) ;



-----------------------------------------------------------------------------------------------------------------------------
연산 주의점
	(0) 도트 연산자가 우선순위 대빵이다 >> 캐스팅 연산 적용된 객체를 대상으로 도트 연산자 사용 원하면 괄호는  필수다
		ex ) ( (자식타입명)객체명 ).필드

	(1) 문자열 연산 : 앞에서부터 차례댈 수행되고, 교환 법칙은 성립하지 않는다
	(2) 실수 연산 : 부동소수점 방식을 사용하여 값이 정확하지 않을 수 있따
	(3) ArthemticException : 나눗셈 연산자 혹은 나머지 연산자 에서 2번째 피연산자가 0일 떄 발생
		피연산자%0.0 >> NaN
		피연산자/0.0>> Infinity 
	(4) 정수/정수 == 정수
		: 실수 값 나오게 하려면 피연사중 하나로 casting 필요

-----------------------------------------------------------------------------------------------------------------------------
패키지
	: 패키지 풀 네임이 다르면 패키지 다른거다. 부모, 자식 관계라고 해서 더 연결되고 그런거 없다.


protected : 자식 클래스에서 직접적으로 new  연산자로는 생성 못하고, super( ) 를 통해서만 생성 가능하다.
접근제한자
	: 필드 , 메서드 범위 요약 
		: static 인 경우 >> 클래스의 접근 제한 이상
		: static 아닌 경우 >> 생성자의 접근 제한 이상

	: 클래스) 1차 관문
		1. public >> 다른 패키지서도 사용 가능 && 부모 클래스가 될 수 있게 함
			: static 필드, 메서드 ) 클래스를 대상으로 접근. 생성자의 접근 제한자에 영향 안받음
				: public >> 모든 패키지서 접근 가능
				: protected >> 같은 패키지서 혹은 자식 클래스에서 접근 가능
				: default >> 같은 패키지 내에서만 접근 가능
				: private >> 자신이 속한 클래스 내부에서만 접근 가능
	
			: 생성자) 1.5관문
				: public >> 모든 패키지에서 객체 생성 가능
					: static 아닌 필드, 메서드 ) 객체를 대상으로 접근. 2관문
						: public >> 모든 패키지에서 접근 가능
						: protected >> 같은 패키지에서 혹은 자식 클래스에서 접근 가능
						: default >> 같은 패키지 내에서만 접근 가능
						: private >> 자신이 속한 클래스 내부에서만 접근 가능

				: protected >> 같은 패키지에서 혹은 자식 클래스에서 객체 생성 가능
					: static 아닌 필드, 메서드 ) 객체를 대상으로 접근. 2관문
						: public, protected >> 같은 패키지에서 혹은 자식 클래스에서 접근 가능
						: default >> 같은 패키지 내에서만 접근 가능
						: private >> 자신이 속한 클래스 내부에서만 접근 가능

				: default >> 같은 패키지 내부에서만 객체 생성 가능
					: 접근 제한자를 명시하지 않은 경우
					: static 아닌 필드, 메서드 ) 객체를 대상으로 접근. 2관문
						: public, protected, default >> 같은 패키지 내에서만 접근 가능
						: private >> 자신이 속한 클래스 내부에서만 접근 가능
					
				: private >> 자신이 속한 클래스 내부에서만 객체 생성이 가능. 주로 singleton 원할떄 사용
					: static 아닌 필드 메서드 ) 객체 접근 대상으로 접근. 2관문
						: public, protected, default ,private >> 자신이 속한 클래스 내부에서만 접근 가능

		2. 아무것도 안씀(default) >> 다른 패키지서 사용 불가. import 조차도 불가.

		3. final >>상속 불가
----------------------------------------------------------------------------------------------------------------------

하이딩 vs 오버라이딩
	: 상속 클래스에서 자식 클래스에 부모 클래스의 멤버와 같은 이름의 멤버가 선언되있는 경우
		: 필드 >> 정적이냐 인스턴스냐 상관없이 오버라이딩이 아닌 하이딩이 일어남
		: 메서드 >> 정적이면 하이딩 , 인스턴스면 오버라이딩

	: 하이딩 << static binding
		: 어떤 타입의 객체냐 따라 먼저 참조하는 멤버가 다르다
			 :첫번째론 해당 생성자가 포함된 클래스 내에서 찾고, 없으면 외부 클래스에서 찾는다
				: 그러니까 부모 클래스 타입의 객체가 자식 클래스의 멤버까지 사용할 수 있단 말이다

		: 부모와 동일한 이름의 static 메서드 혹은 동일한 이름의 필드에 대해서 일어난다

	: 오버라이딩 <<  Dynamic Binding
		: 어떤 클래스의 생성자로 생성된 객체인가에 따라 먼저 참조하는 멤버가 다르다
			: 첫번째론 해당 생성자가 포함된 클래스 내에서 찾고, 없으면 '부모' 클래스에서 찾는다.

		: 인스턴스 메서드를 대상으로 일어나는 것이라 런타임에 일어나는 거다


----------------------------------------------------------------------------------------------------------------------


부모를 자식 타입으로강제 형변환 하는건 자식 생성자로 만들어졌었던 얘들만 가능하다




