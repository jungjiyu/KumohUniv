
<헷갈리는거 정리>

문자배열 과 &문자배열
	: 문자배열로 포인터 연산할떄 제외하곤 둘이 같은거라 봄 된다
		: 문자배열 == 0번쩨 요소 주소 인데 , &문자배열 == 0 번쨰 요소가 시작하는 주소라서 그렇다

문자열과 문자 포인터
	: https://dojang.io/mod/page/view.php?id=1791#google_vignette
	: 문자포인터는 따로 동적할당하지 않아도 아무크기의 문자열을 가리킬 수 있다. 
		: 문자열 자체는 읽기 전용 문자 배열이라 이미 메모리가 확보되있는거고, 그걸 포인터가 가리키는 것이기 때문
	: 그런데 문자 포인터를 이용해 문자열을 입력받는 것은  메모리 확보를 해준 후에야 가능하다.
		: 메모리를 확보한 후 그 자리에 입력받는 데이터를 저장하는거지 입력받는다고 자동으로 그에 대한 메모리가 할당되는게 아니기 때문
	:  문자 포인터를 이용해 문자열을 입력받을떄 포인터명 그자체를 arg 로 함 된다
		: 문자포인터는 주소값이지만, *문자포인터 는 주소가 아닌 값임을 주의

	: 참고로 문자열을 할당받은 상태인 문자 포인터엔 * 써서 새로 집어넣지 못한다. 문자열은 쓰기가 불ㄹ가한 영역에 저장되어있기 때문



동적할당된 메모리를 가리키고 있는 포인터의 사용법
	: 포인터이긴 해도, 다른 변수의 주소를 저장하기 위해서라보단 값을 저장하기 위해 사용한다
	: *포인터명 == 가변배열명 이라고 생각함 편하다. 


' -> ' 연산자
	: 포인터가 가리키는 대상의 멤버값에 바로 접근하게 해준다.
		: (*포인터명).멤버 == 포인터명 -> 멤버 이다.

구조체 복사
	case1 : malloc 해서 구조체 생성한 상황에서 '=' 를 이용
		: 얕은 복사 일어남. 값 자체를 따로 따로 복사한게 아니라 주소를 복사한거라서(포인터1 = 포인터2; 꼴이니) 한쪽 바뀌면 다른쪽도 바뀜

	case3 : malloc 해서 구조체 생성한 상황에서 멤버 별로 값을 복사
		: 한쪽 바뀐다고 다른쪽 안바뀜

	case2 : malloc해서 구조체 생성한 상황에서 '=' 를 사용
		: 이건 뭔 복산지 모르겠으나, 값 자체도 잘 복사되고 한쪽 바뀐다고 다른쪽까지 바뀌진 않음
		: 굳이 양쪽 다 malloc 되어있을 필욘 없고, 복사당하는 얘만 malloc 되어있음 됨.


 while(--n) 과 while(n--)
	while(--n) : n-1 번 이동 
	while(n--) : n번이동

tip :
	뭐든 입력 받은 후엔 while( getchar( ) != '\n'); 해주는게좋다 (버퍼 비우기)
----------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------

배열 vs 연결리스트
	배열: 연속적인 메모리 할당
		: 장점) 인덱스 기반으로 요소 접근을 하기 떄문에 어느 요소를 찾아가건 접근 속도가 동일
		: 단점) 
			1. 중간에서 수정일어날시 그 뒤의 데이터가 모두 이동해야됨
			2. 메모리 공간이 가변적이지 않음.

	연결리스트: 비연속적인 메모리 할당
		: 장점 ) 
			1. 메모리 공간이 유연함 << 필요할때마다 생성해서 씀
			2. 중간에서 수정일어나도 그 주변만 수정됨

		: 단점)
			1. 뒷 요소일수록 접근하는  속도가 느려짐


단일연결리스트
	: 노드 구조체 << 원소
		: 멤버
			(1) 값을 저장할 변수
			(2) 자기참조포인터: 다음 노드를 가리킨다

	: 리스트 구조체 << 노드를 원소로 하는 리스트
		: 멤버
			(1) head : 처음 노드를 가리킬 포인터 << 필수
			(2) tail: 맨 마지막 노드를 가리킬 포인터 << 필수는 아님


	: 인덱스 기반 노드의 삽입 방법
		: 일단 노드를 생성할때마다 node 크기로 동적할당 해야한다
		1. 맨 앞 >> head 변경 필요
			case1 : 아무것도 없는 상태 >> head 초기화 
			case2 : 뭔가 있는 상태 >> head초기화 && 추가한node의 next 값 설정

		2. 중간 >> 앞의 노드 멤버값 변경 필요
			: k번째로 삽입할때 그 앞( k-1번째 ) 노드의 next 값을 수정해줘야하니 k-1 번째 노드에서 일단 stop 필요
				: while(--k ) 만큼 반복 이동. 즉 , k-1 번 이동

		3. 끝 >> tail 변경 필요
			case1 : count 멤버를 도입한 상태 >> k == count 로 젤 끝임을 감지
				case(1) tail 포인터를 도입한 경우 
					1. tail 이 가리키던 노드의 next 가 새로운 노드 가리키게함
					2. tail 을 새로운 노드를 가리키게 수정

			case1 : count 멤버를 도입안한 상태 >> 걍 중간삽입알고리즘과 병행
else {

	//(1) k-1번째 노드로 이동
	Node* current_node = list->head;
	int n = k;
	while (--n) {
		current_node = current_node->next;
	}

	//(2) 중간삽입케이슨지 검사
	if (current_node->next != NULL) {
		new_node->next = current_node->next;
	}
	current_node->next = new_node;

}

	: 오름차슌 기반 노드의 삽입 방법
		: 일단 노드를 생성할때마다 node 크기로 동적할당 해야한다
		1. 가장 작은값이 삽입됨 >> head 값 변경 필요
			case1. 아예 젤 처음 삽입값 (list->head == NULL)
			case2. list->head 보다도 삽입값이 더 작음(list->head->val > newNode->val)

		2. tail 도입했을떄 가장 큰 값 삽입됨 >> tail 값 변경 필요
			: 걍 list->tail->val < newNode->val 조건으로 걸러내고. tail 값 수정.


		3. 중간값 삽입 || tail 도입안했을때의 가장 큰 값 삽입
			: prevNode까지 도입
				: prevNode 가 newNode 의 앞노드, curNode 가 newNode 의 뒷 노드가 되고, curNode 가 newNode 보다 더 커진 시점 혹은 curNode 의 next값이 null 임이 검출된 시점에서 while 문 종료
					: curNode->next == NULL 까지 검사당했단 말은 prevNode->next == NULL 까지 실행됬단 소리고, prevNode 가 newNode 의 앞 노드임을 고려했을때 newNode 는 가장 끝에 삽입되는게 됨.
						: 가장 끝에 삽입하는경우 nweNode->next = curNode ; 해주면 안되는거 주의

		Node* prevNode = list->head;
		Node* curNode = list->head;

		while (curNode->next != NULL) {
			curNode = curNode->next;
			if (curNode->val > newNode->val) {
				break;
			}
			prevNode = prevNode->next; // 조건 검사 "후" prev 도 이동
		}
		
		if (prevNode->next != NULL) newNode->next = curNode;
		prevNode->next = newNode;





				

	: tip 
		>> 삽입
			: 삽입 가능한 젤 마지막 인덱스 == 현재리스트의노드갯수
			: k번째에 새노드 삽입한다고 했을떄 k-1 번째 노드의 next 값을 수정해야하므로,  curNode가 최종적으로 k-1번째 노드를 가리키게 노드순회 반복문을 짠다( k-1 번 반복 이동 )

		>> 순회한다 == currentNode 포인터 도입한다.
		>> 삭제한다 == delNode 포인터를 도입한다
		>> 오름차순으로 삽입할때
			가장앞노드
		
------------------------------------------------------------------------------------------

이중 연결 리스트
	: next, prev 포인터 모두 가지는 노드


이중연결리스트 역순 정렬 (역순 insert 가 아님)
	: 0개거나 1개 있으면 굳이 역순 정렬 적용 안해도 됨
	: 노드가 2개 이상인 경우
		: curNode 로 순회하면서 prev 와 next 값을 바꾸면 된다. 예상외로 prev 나 next 가 null 값을 가리킨다고 해서 swap 하는것 자체의 처리는 다르지 않고, 다만 추가적으로 head 포인터 혹은 tail 포인터가 그 노드를 가리키게만 설정함 된다

		while(curNode != null) {
			1. curNode 의 next 와 prev 값을 swap
			2. curNode 의 prev 가 NULL 인지 검사
				2.5 맞으면 해당 노드를 head 포인터가 가리키게 조치 취함
			3. curNode 를 "prev"방향으로 이동
				: 1. 에서 이미 next 와 prev 를 swap 한 상태이므로 사실상 다음 노드는 next 가 아닌 prev 포인터가 가리키고 있음을 주의
			}




동적할당: 런타임에 메모리 공간을 확보하는것
	: 관련 함수는 stdlib.h 헤더파일에 포함되어있다	
	: 가변적인 배열로 주로 사용된다.		
	: 동적 할당 방법
		: malloc, calloc 반환값을 저장하는 포인터의 경우 주로 *포인터명 으로 일종의 변수처럼 사용한다 보면 됨.  즉 공간을 언제든지 회수 할 수 있는 변수처럼 생각함됨. ( 포인터이긴해도, 다른 변수의 주소를 저장하기 위해서 쓰이진 않음 )
			: 동적할당을 사용하는 이유가 변수 , 배열의 공간을 실행 도중에 동적으로 확보하기 위해서이기
			  때문에 동적할당 받은 포인터에 보통 &(변수)를 대입하는게 아니라 (변수는 공간이 완전 잡혀있는 얘니까 굳이 동적할당을 사용하는 의미가 없어짐.)
			 *포인터 = 원하는값 을 직방으로 넣고 *포인터의 형태로 변수처럼 사용하는 것.
				:ex)
					int *p = (int *)malloc(sizeof(int));
					*p = 10;
					printf("%d",*p);


		: malloc, calloc 반환값을 저장하는 포인터의 경우  변수 중에서도 배열타입 변수처럼 자주 사용됨
			: *( 포인터명+n )==포인터명[n] = 배열명[n] , 포인터명+ n = &(배열명[n]) 이므로
				: scanf("형식지정자",&포인터명[n]);   // 배열명 자체가 아닌 요소 단위로 접근시 & 사용하는거 잊지x
				: printf("형식지정자",포인터명[n]);
				: free(포인터배열명[n]) //  포인터배열의 요소 단위로 메모리 반환가능
					// 아니 그럼 배열 통째로 반환하는건 안됨?




		: 주의 ) 동적할당을 여러번 시행할때 서로 연속적이지 않을지 몰라도, 각각 그 자체적으로는 연속적인 메모리가 확보되는거다.  

		(1) void* malloc(unsinged int size); 
			: 반환형이 void* 형 ---> 사용전 특정포인터타입으로 형변환해 사용한다
				: 만약에 정상적으로 동적할당이 이루어지지 않으면 NULL포인터를 반환한다.

			: 주로 arg 로 직접적인 사이즈를 쓰기 보단 " n*sizeof(타입) " 과 같이 쓰는 편
				: 컴파일러 따라 자료형의 사이즈가 다르게 정의될 수 있으니
				: n == 요소의 개수

		(2) void* calloc(unsignedint n , unsinged int size);
			: malloc기능+ 요소개수따로 받기+ 0으로 자동 초기화기능
			: 첫 arg == 배열 요소 개수 , 두번쨰 arg == 한 요소당 size
				: 그러니까 사이즈 자체는 malloc(n*sizeof(자료형)) == calloc(n, sizeof(자료형))

	: 동적 할당 변경 방법
		: void * realloc(void *, unsinged int ) 
			: 동적할당 받았던 메모리의 크기를 변경한다. 
				: 크기를 늘리는 경우 저장된 내용은 유지되면서, 뒷 부분이 늘어난다( 새로 추가된 부분은 쓰레기 값으로 채워진다). 
					: 기존 데이터가 유지되는건 맞는데, 메모리 위치가 유지되는건 보장 못함 주의

				: 크기를 줄이는 경우 마찬가지로 뒷 부분이 줄어든다

			: 첫 arg 로는 이미 동적할당된 부분을 참조하고 있는 포인터, 두번째 arg 로는 변경될 사이즈를 할당한다
			: 주의 ) 
				1. 그냥 arg 로 해당 포인터를 대입하는걸로 끝내면 안되고, 다시 재할당받아야된다.
					: 기존 데이터가 유지되는건 맞는데, 메모리 위치가 유지되는건 보장 못한다
						: 참고로 realloc 로 인해 쓸모없게된 메모리영역은 자동으로 반환되므로 노상관.
					: ex) 
						int *p = (int *)malloc(6*sizeof(int));
						p = (int *)realloc(p,8*sizeof(int)); // arg 로 대입하고, 다시 반환 받는다

				2. 반환타입이 void* 이므로 재할당할때 강제형변환 필수
				3. 두번째 arg 는 단순 요소 개수가 아니라 "사이즈"( 개수 * sizeof(타입)) 임을 주의

	: 동적할당메모리반환 )  메모리 공간을 공용 메모리로 돌리는 작업
		memory leak >> 더이상 사용하지 않는 메모리를 계속 붙잡고 있어서 과부하 걸리는것
			: memory leak 을 방지하기 위하여 더이상 사용하지 않는 얘들은 바로바로 반납하자

		댕글링 포인터(Dangling Pointer) >>  해제된 메모리 영역을 여전히 가리키고 있는 포인터
			: https://thinkpro.tistory.com/67
			: 요약하자면, free(특정포인터) 한 후에 바로 특정포인터=null; 해주는게 좋다
			: 동적할당 메모리를 반환하면,  거기에 저장한 값은 날라가고 쓰레기 값으로 채워지는게 맞다. 그런데 반환된 공간을 사용한다고 해서 에러가 나지도 않고, 대부분 값이 제대로 나온다. 하지만 해당 메모리는 공용 메모리로 돌려진 상태라 어떤 상황이 발생할지 예측불가하므로, 해제된 메모리에 값 저장하지 말자. 할거면 새로 공간을 할당하여 사용하자
				: 댕글링 포인터 ex)
 					int *p2 = (int*)malloc(sizeof(int));
					*p2 = 10;
					printf("동적할당된상태에서의 값: %d \n",*p2);
					free(p2);
					printf("메모리 해제된 상태에서의 쓰레기값: %d \n", *p2);
					*p2 = 10;
					printf("메모리 해제된 상태에서 값(10) 넣었을때: %d ", *p2);


		: free( 포인터 ) 를 사용해서 한다
		: 주의 
			1. 일차원 가변적 배열로 사용한 포인터의 경우 걍 그 포인터만 free 시키면 되지만, 이차원 가변젹 배열로 사용한 포인터의 경우 일단 "요소단위로 free 한 다음에" , 마지막으로 "이차원가변포인터를 free" 시켜야된다
			2. 이미 free 한 메모리를 또 free 하면 에러난다





  
