Object
  (1) equals : 참조변수의 값이 같은지 다른지 여부를 비교할 때 사용한다.
    : 원시타입의 경우 "==" 로 값이 같은지 다른지 판단 가능하지만, 참조 변수에 사용하는 경우 값자체가 아닌, 주소값을 비교하게 된다. 따라서 참조변수의 값 자체의 비교를 위한 메서드가 필요하다.
      String s1 = "Hello";
      String s2 = "Hello";
      System.out.println(s1 == s2); //  false

  : 오버라이딩 형태 >> 필드값을 비교하게 한다.
    public boolean equals(Ojbect o){
      if(this == o ) return true; // 걍 객체 자체가 같으면, 당연히 true 를 반환
      if( !(o instanceof 해당클래스 )) return false; // 해당클래스타입의 인스턴스가 아닌경우 

      해당클래스 임시변수 = (해당클래스)o; // 형변환
      if( this.필드명 != 임시변수.필드명 ) return false;
      if( this.필드명2 != 임시변수.필드명2 ) return false;
      .
      .
      .
      return true; // 앞에서 걸리지지 않아야 마지막에 true 를 반환
    }



  (2) hashcode : 객체의 공한 숫자값. 주민등록번호.
      : 보통 equals 를 오버라이딩하는 경우, hashcode 도 해야됨
        :  equals() 의 결과가 true 인 두 객체의 해시코드는 반드시 같아야한다는 자바의 규칙 때문
          : hashcode 와 equals 가 모두 같아야, 같은 객체로 인식된다.때문에 두 메소드를 재정의 하지 않을시 (hash 값을 사용하는) Collection을 사용할 때 , 아무리 equals 로 같은 객체 처리를 했어도 해시값은 다르기 떄문에 최종적으론 다른 객체로 인식하여 중복된 내용이 삽입될 수 있는 문제가 발생한다. 

      : 구현 내용
        : 간단히 하면, equals 메서드에서 같은지 검사당하는 필드를 대상으로 Object"s".hash( Object obj ) 를 활용하면된다.
        public int hashcode() {
          return Objects.hash( 특정필드 );
        }



  (3) toString



상속
  : https://velog.io/@rhdmstj17/java.-super%EC%99%80-super-%EC%99%84%EB%B2%BD%ED%95%98%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0
  : 자바에선 다중 상속이 불가하다.
  : 필드
    : 자식과 부모가 동일한 이름의 필드를 가진다면 >> 필드하이딩 일어난다
      : 자식 클래스 내부에선, 단순 필드명으로 접근 시 자식클래스에 정의된 필드를 사용하게 된다.
      : 자식 클래스 내부에서 부모 클래스에 정의된 해당 필드를 사용하고 싶다면, "super.해당변수명" 을 통해 접근해야된다. 
        : super 는 자식 인스턴스의 생성에 앞서 만든 부모 인스턴스를 의미하는 거지, 부모 클ㄹ래스 자체를 의미하는 것이 아니기 때문에 static 필드 뿐 아니라 인스턴스 필드도 접근 가능하다.
 

  : 생성자
    : 자바에선 자식클래스 생성자 실행 이전, (우리가 별도의 명시를 하지 않아도) 기본적으로 "super();"를 생성자에 추가하여 부모의 기본 생성자를 호출한다.
    : 부모에 기본 생성자갸 없는 경우 arg 를 대입한 super 생성자로, 생성자를 명시적 지정 해야된다.
      : super( arg1, arg2 .. ) 사용시 주의할 점
        : 자식 클래스 생성자의, "맨 첫 줄"에만 사용 가능하다.



제네릭 : 결정되지 않은 타입을 파라미터로 처리하고, 실제 사용할 때 해당 파라미터를 확정 시켜 사용하는 기능
  : 다양한 내용물을 저장해놨다 바로 꺼내 쓸 수 있게 하기 위함. 
    : 다양한 내용물의 저장을 위해 단순 Object 타입을 쓴다고 하면, 물론 모든 자료형의 변수를 받아 둘 수 있긴 함. 근데 문제는, 꺼낼 때 어떤 자료형으로 변환할 지 알기 위해 일일이 모든 클래스를 대상으로 instanceof 를 쓸 순 없다는 것.
  : 타입파라미터
    : 오로지 참조 타입만 할당 가능하고, 원시타입은 불가하다. 
    : 주로 타입파라미터 앞글자 따서 T 로 많이 표기함.

  : 제네릭타입 >> 타입파라미터를 가지는 "클래스" 혹은 "인터페이스"
    : < T > 표시 자체는 "타입파라미터" 이고, 이 <T> 를 가지는 클래스를 "제네릭타입"이라 하는거다
    : 다른 클래스에서 제네릭타입을 implements 하거나 extends 할때, 타입파라미터값을 명시해주지 않아도 오류가 나지 않는다. 자동으로 <Object> 를 추가해준다. 물론 Ojbect 가 아닌 특정 타입을 사용 가능하게 하고 싶으면 <특정타입> 을 명시해주어야된다

  ; how to 
    (1)클래스 자체를 설계할 때는 확정시키지 않는다.
      : 클래스명 옆에 < 파라미터명1, 파라미터명2, ..  > 를 명시한다 << 꺾쇄 있음 주의 
      : 클래스 내부에 해당 파라미터명을 타입으로 하는 필드 혹은 메서드를 정의한다 << 이때는 꺽쇄 없음 주의 

    (2)해당 클래스의 객체를 만드는 시점에 확정시킨다.
      : 클래스명<확정타입> 인스턴스명 = new 클래스명<확정타입>( 필요한인자1, 필요한인자2 , .. ) ;
          : 근데 사실 생성자 부분에서는 < > 을 빈칸으로 둬도 된다.

      
