배열
  : 자바의 배열도 사이즈가 고정적
  (1) 선언 : 선언 자체엔 사이즈 명시 안함 주의
    1. 타입[] 변수명;	
    2. 타입 변수명[];	

  (2) 생성 (할당) : 
    : new 키워드로 생성하더라도 , 어떠한 경우더라도 ( ) 는 안붙인다. 근데 사이즈는 표시할떄도 있고, 안할 떄도 있다.
    1. { 값1 ,값2 , 값3 .. } << 선언과 동시에 할당할 때"만" 가능
  **2. new 타입[]{ 값1 ,값2 , 값3 .. } 
      : 선언 이후에도 할당 가능
      : 사이즈 명시 안함 주의
  **3. new 타입[사이즈] 
      : 사이즈만 잡고 당장은 결정안하는 경우 사용

  (3) 초기화

Object
  (1) equals : 참조변수의 값이 같은지 다른지 여부를 비교할 때 사용한다.
    : 원시타입의 경우 "==" 로 값이 같은지 다른지 판단 가능하지만, 참조 변수에 사용하는 경우 값자체가 아닌, 주소값을 비교하게 된다. 따라서 참조변수의 값 자체의 비교를 위한 메서드가 필요하다.
      String s1 = "Hello";
      String s2 = "Hello";
      System.out.println(s1 == s2); //  false

  : 오버라이딩 형태 >> 필드값을 비교하게 한다.
    public boolean equals(Ojbect o){
      if(this == o ) return true; // 걍 객체 자체가 같으면, 당연히 true 를 반환
      if( !(o instanceof 해당클래스 )) return false; // 해당클래스타입의 인스턴스가 아닌경우 

      해당클래스 임시변수 = (해당클래스)o; // 형변환
      if( this.필드명 != 임시변수.필드명 ) return false;
      if( this.필드명2 != 임시변수.필드명2 ) return false;
      .
      .
      .
      return true; // 앞에서 걸리지지 않아야 마지막에 true 를 반환
    }



  (2) hashcode : 객체의 공한 숫자값. 주민등록번호.
      : 보통 equals 를 오버라이딩하는 경우, hashcode 도 해야됨
        :  equals() 의 결과가 true 인 두 객체의 해시코드는 반드시 같아야한다는 자바의 규칙 때문
          : hashcode 와 equals 가 모두 같아야, 같은 객체로 인식된다.때문에 두 메소드를 재정의 하지 않을시 (hash 값을 사용하는) Collection을 사용할 때 , 아무리 equals 로 같은 객체 처리를 했어도 해시값은 다르기 떄문에 최종적으론 다른 객체로 인식하여 중복된 내용이 삽입될 수 있는 문제가 발생한다. 

      : 구현 내용
        : 간단히 하면, equals 메서드에서 같은지 검사당하는 필드를 대상으로 Object"s".hash( Object obj ) 를 활용하면된다.
        public int hashcode() {
          return Objects.hash( 특정필드 );
        }



  (3) toString



상속
  : https://velog.io/@rhdmstj17/java.-super%EC%99%80-super-%EC%99%84%EB%B2%BD%ED%95%98%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0
  : 자바에선 다중 상속이 불가하다.
  : 필드
    : 자식과 부모가 동일한 이름의 필드를 가진다면 >> 필드하이딩 일어난다
      : 자식 클래스 내부에선, 단순 필드명으로 접근 시 자식클래스에 정의된 필드를 사용하게 된다.
      : 자식 클래스 내부에서 부모 클래스에 정의된 해당 필드를 사용하고 싶다면, "super.해당변수명" 을 통해 접근해야된다. 
        : super 는 자식 인스턴스의 생성에 앞서 만든 부모 인스턴스를 의미하는 거지, 부모 클ㄹ래스 자체를 의미하는 것이 아니기 때문에 static 필드 뿐 아니라 인스턴스 필드도 접근 가능하다.
 

  : 생성자
    : 자바에선 자식클래스 생성자 실행 이전, (우리가 별도의 명시를 하지 않아도) 기본적으로 "super();"를 생성자에 추가하여 부모의 기본 생성자를 호출한다.
    : 부모에 기본 생성자갸 없는 경우 arg 를 대입한 super 생성자로, 생성자를 명시적 지정 해야된다.
      : super( arg1, arg2 .. ) 사용시 주의할 점
        : 자식 클래스 생성자의, "맨 첫 줄"에만 사용 가능하다.



제네릭 : 결정되지 않은 타입을 파라미터로 처리하고, 실제 사용할 때 해당 파라미터를 확정 시켜 사용하는 기능

  : 타입파라미터
    : 주로 타입파라미터 앞글자 따서 T 로 많이 표기함.
    : 타입 파라미터 범위 한정하기
      : 장점
      : how to
        (1) <T extends 기준타입> : T 로 기준타입 이하( 기준타입 혹은 그의 후손타입)만 허용 
          : 주의 >> 기준타입으로는 일반클래스 뿐 아니라 인터페이스도 올 수 있는데, 그런다고 해서 implements 키워드를 사용하진 않는다!

        (2) <T super 기준타입> : T 로 기준타입 이상(기준타입 혹은 그의 조상타입)만 허용
      
    : 주의
      1. 오로지 참조 타입만 할당 가능하고, 원시타입은 불가하다.
      2. 제네릭타입의 타입파라미터는 static 멤버(메서드와 필드 모두)에는 적용이 불가 
        : 인스턴스 생성할 떄 타입파라미터가 확정되는거니까
      3. 하지만 메서드자체는 static 이건 아니건 제너릭메서드화 할 수 있음.  
        : 제네릭메서드의 타입파라미터는 호출당시에만 확정되면되는거라서서

  : 와일드카드타입파라미터 <?>
    : 일반적인 T 와 같은 문자가 아닌 , '?'문자로 선언된다.
    : 제네릭타입간의 형변환을 가능하게 한다
      if 자식타입을 타입파라미터로 하는 제네릭타입을 해당 타입이 받게하고 싶으면 >> extends 키워드 사용
      if 부모타입을 타입파라미터로 하는 제네릭타입을 해당 타입이 받게하고 싶으면 >> super 키워드 사용




  : 제네릭타입 >> 타입파라미터를 가지는 "클래스" 혹은 "인터페이스"
    : 다양한 내용물을 저장해놨다, (캐스팅없이) 바로 꺼내 쓸 수 있게 하기 위함. 
      : 다양한 내용물의 저장을 위해 단순 Object 타입을 쓴다고 하면, 물론 모든 자료형의 변수를 받아 둘 수 있긴 함. 근데 문제는, 꺼낼 때 어떤 자료형으로 변환할 지 알기 위해 일일이 모든 클래스를 대상으로 instanceof 를 쓸 순 없다는 것.
    : < T > 표시 자체는 "타입파라미터" 이고, 이 <T> 를 가지는 클래스를 "제네릭타입"이라 하는거다
    : 다른 클래스에서 제네릭타입을 implements 하거나 extends 할때, 타입파라미터값을 명시해주지 않아도 오류가 나지 않는다. 자동으로 <Object> 를 추가해준다. 물론 Ojbect 가 아닌 특정 타입을 사용 가능하게 하고 싶으면 <특정타입> 을 명시해주어야된다
      : <특정타입> 을 타입파라미터로 할 수도 있다. 꼭 당장(?) 진짜 명시적인 타입을 할당하지 않아도 된다
        ex ) class Sample<T> implements ISample<T> // 꼭 ISample<String> 처럼 당장 확정짓지 않아도 된다.

    ; how to 
      (1)클래스 자체를 설계할 때는 확정시키지 않는다.
        : 클래스명 옆에 < 파라미터명1, 파라미터명2, ..  > 를 명시한다 << 꺾쇄 있음 주의 
        : 클래스 내부에 해당 파라미터명을 타입으로 하는 필드 혹은 메서드를 정의한다 << 이때는 꺽쇄 없음 주의 
    
      (2)해당 클래스의 객체를 만드는 시점에 확정시킨다.
        : 클래스명<확정타입> 인스턴스명 = new 클래스명<확정타입>( 필요한인자1, 필요한인자2 , .. ) ;
            : 생성자의 < >의 내부는 빈칸으로 둬도 된다.
              : 선언과 동시에 할당하지 않더라도, 생략 가능하다.
            : 인스턴스 타입 부분과, 생성자 부분의 <확정타입> 자체(꺽쇄포함)를 아예 생략할 수도 있다. 이 경우 Object 가 확정타입으로 자동적용된다.

  : 제네릭 타입 간의 형변환
      : 타입파라미터가 "와일드타입파라미터" 인 경우를 제외하곤, 제네릭타입명<부모타입> 과 제네릭타입명<자식타입> 간의 형변환은 "불가"하다.
        : 그러니까 People<Object> pOb = new People<String>( ) ;이 불가.
        : 생각해봄 당연한게,  제네릭타입명<부모타입> 과 제네릭타입명<자식타입> 은 타입파라미터 끼리 상속관계인거지,  제네릭타입명<부모타입> 과 제네릭타입명<자식타입> 자체가 상속 관계 인 것은 아니니까.




  : 제네릭 메서드 >> 타입파리미터를 가지는 "메서드"
    : 다양한 타입의 매개변수를 받을 수 있게 한다.
    : 자체적으로 타입파라미터가 선언된 메서드
      : 주의 ) 타입파라미터를 활용한다헤서 제네릭메서드인게 아니다. 그러니까 클래스 선언부에 선언된 타입파라미터를 쓰는 메서드는 제네릭 메서드가 아니다. 해당 메서드에서, 타입파라미터가 "선언"되어야한다.
    : how to
      1. 메서드 선언할 때 타입파라미터를 "접근제한자 와 (있다면)static 부분"의 바로 뒤에 선언하고, 해당 "타입파라미터"를 "메서드의파라미터"의 타입으로 한다 
        : 접근제한자 < 타입파라미터명1, 타입파리미터명2, ..> 리턴타입 메서드명( 메서드파라미터a, 메서드파라미터b, .. )

            : static 이건 아니건 상관없다.

     2. 활용한다
      sol(1) 호출할때 직접 특정타입으로 명시해준다
        : 메서명앞에 명시해야됨 주의!! << 암기 tip. 선언 당시에도 메서드명 앞에 선언됬으니까.
        : ex ) FruitBox.<Integer>addBoxStatic(1, 2);

      sol(2) 특정타입 명시 없이 호출한다.
        : 가능한 이유 >> argument 의 타입으로 컴파일러가 추정하여 결정해준다.
        : ex ) FruitBox.addBoxStatic(1, 2); 




스레드
  : 기본용어
    : 프로그램 >> 실행중이지 않은 코드 덩어리
    : 프로세스 >> 실행"중" 인 프로그램
    : 스레드 >> 하나의 프로세스 내의 코드 실행 흐름
    : 멀티테스킹 >> 두가지 이상의 작업을 동시에 처리하는 것.
      : 주의 ) 프로세스 들은 서로 독립적이기 떄문에 하나의 프로세스에서 오류 발생한다고 다른 프로세스가 영향을 받진 않지만, 스레드 들 또한 서로 독립적이지만 한 스레드에서 문제 발생하면 해당 프로세스 자체가 종료된다. 
      (1) 멀티 프로세스 : 한 운영체제에서, 두 가지 이상의 프로그램을 동시에 돌림 
      (2) 멀티 스레드 : 한 프로세스에서, 두 가지 이상의 스레드를 동시에 돌림
        : 메인 스레드만 있을 경우 싱글 스레드, 메인 스레드 이외의 작업 스레드도 있을 경우 멀티 스레드.
        : 멀티 스레드의 경우, "모든" 스레드가 종료되어야 프로세스가 종료된다(메인 스레드가 끝난다 해서 해당 프로세스를 중료되지 않는다).

  : 종류
    1. 메인스레드 main thread
      : main 함수 있는 클래스에 대한 스레드. 실행흐름.
      : 모든 자바프로그램은 메인스레드가 main( ) 메서드를 실행하며 시작된다. 
      : 메인 스레드에서 필요에 따라 추가적인 스레드들을 생성 및 실행시킬 수 있다.

    2. 작업 스레드 task thread
      : Runnable 인터페이스
        : Thread 인스턴스 생성시 이 타입의 객체를 필수적으로 arg 로 넣어야된다. 
        : public void run( ) >> 스레드객체를 대상으로 .start()  하여 실행할 시, 이 메서드의 코드가 실행된다.

      : 주의 > 스레드를 생성한다고 해서, 실행되는게 아니다. 객체 생성 이후, 직접 "스레드객체명.start( ) " 해줘야 실행된다.

    : 스레드의 상태
      1. new : 스레드 객체가 생성된 상테
          : 이 상태서 start( ) 메서드의 호출로, runnable 단계로 넘어갈 수 있다. 그러니까 start( ) 를 쓴다고 해서 , 바로 실행되는게 아니라 , 실행 대기 상태로 넘어가는거다,
      2. runnable : 실행대기상태.
      3. running : 실행 상태
        : cpu 를 점유하여, run( ) 이 실행되고 있는 상태
        : run( ) 메서드기 모두 실행되면 terminated 단게로 간다.
        : cpu 스케줄링에 의해 해당 스레드가 다시 runnable 상태로 돌아가고, 다른 스레드가 실행될수도 있다. 즉, 각 스레드는 실행대기상태와 실행상태를 번갈아가면서 조금씩 실행된다.

      3.5 일시정지 : 스레드가 실행될 수 없는 상태.
          : 다시 실행되기 위해선, runnable 을 거쳐 run 상태로 가야된다.
          : 주의 >>  
            1. cpu 스케줄링에 의해 run 상태에서 runnbale 상태로 다이렉트 back 하는 상황과 일시정지 상태는 다른거다
            2. 오류 난게 아니다. 

          : 일시정지로 보내는 메서드
            (1) Thread.sleep( ms단위시간 ) : 해당시간동안 스레드를 일시정지상태로 만든다. 해당 시간이 지나면, 자동적으로 runnable 상태로 돌린다.
            (2) Thread.join() : join( ) 을 호출시킨 메서드가 속한 스레드를 일시정지상태로 만든다. 실 ??
            (3) Thread.wait() : 동기화 블록 내에서 스레드를 일시정지 상태로 만든다.

          : 일시정지를 푸는 메서드
            (1) interrupt( ) : interruptedException 을 발생시켜 runnbale 혹은 terminated 상태로 돌린다
            (2) notify( ) , notifyAll( ): wait( ) 메서드로 인해 일시정지상태인 스레드들을 , runnbale 상태로 돌린다.

      4. terminated : 종료


      : 생성 방법
        sol(1) Thread 타입 객체 생성 :
          1. Runnable 구현 클래스 정의 >>  run( ) 을 오버라이딩하여 실행내용을 명시한다.
          2. Runnable구현클래스타입 객체를 arg 로 하여 Thread 생성
            : Thread 스레드명 = new Thread( Runnable구헌객체 );
 
        sol(2) Thread 자식 타입 객체로 생성 : 
          1. Thread 클래스를 상속하는 자식 클래스 정의 >> 이떄 반드시 run( ) 을 "오버라이딩"해준다.
          2. 자식클래스타입의 객체 생성
            : Thread 스레드명 = new 자식클래스멍( ); 


      : 스레드 일시중지 하는 법 >> Thread.sleep( 나노세크단위 );
        : run() 이 속한 스레드를 해당 시간 만큼 중지시킨다.

      **: 주의 >> 예외를 발생시키기 떄문에 try catch 문과 함께 써야된다
          ex) try{ Thread.sleep(1000);} catch(Exception e){e.printstacktrace();} 


    : 각 작업 스레드는 자동적으로 , "Thread-n" 이라는 이름을 가지게 된다.
      : n 은 "0" 부터 실행된다.
      : Thread 객체를 대상으로 getName 을 사용하여 얻을 수 있고, 이름의 수정을 원하는 경우 .setName(String name) 쓰면 된다.
        : Thread 스레드명 = Thread.getCurrentThread( ); 을 통해 현제 스레드에 대한 객체를 얻고, 이 변수를 대상으로 쓰면된다.




      
