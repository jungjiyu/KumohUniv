



<산술논리연산장치 ALU>
	- 산술 연산과 논리 연산을 수행하는 하드웨어 모듈
	- 구성 요소
		▪ 산술 연산장치: 산술 연산들(+, -, ×, ÷)을 수행
		▪논리 연산장치: 논리 연산들(AND, OR, XOR, NOT 등)을 수행
		▪시프트 레지스터(shift register): 비트들을 좌측 혹은 우측으로 이동시키는
기능을 가진 레지스터
		▪보수기(complementer): 2진 데이터를 2의 보수로 변환(음수화)
		▪상태 레지스터(status register): 연산 결과의 상태를 나타내는 플래그(flag)
들을 저장하는 레지스터


		

<컴퓨터 산술과 논리 연산>

정수의 표현
	- 2진수 체계: 0, 1, 부호 및 소수점으로 수를 표현
		- 부호 없는 정수 unsinged >> 2진수 데이터를 그대로 2진수로 읽으면 된다
		- 부호가 있는 정수 >> 음수와 양수를 구분해야된다 
		- 𝑛-비트 부호 없는 정수의 표현 가능 범위: 0 ~ 2 **(𝑛 − 1)


	- 2진수, 8진수, 10진수, 16진수의 진법 변환
	-

소수의 표현
	- 정수부분 + . + 소수점이하부분
	- 10진수로의 변환 방법 : 소수점 이하이든 이상이든 걍 a*(2**n) 한 거 똑같이 더하는거임.
	
	
음수의 표현
	- 최상위 비트 : 0 >> 양수
	- 음수 
		- 어떤 표현 방법을 채택하든 결과적으로 음수의 최상위 비트는 1이 된다
		- 표현 방법
			sol 1. 부호화 크기 표현 : 최상위 비트로만 구분. (최상위 비트 이하 부분은 모두 동일)
				; 단순 최상위 비트 가 1 이면 음수, 0 이면 양수 인 것.
				: 사람 입장에선 직관적이여서 편하긴 한데, 컴터 입장에선 불편
				    why1 : 덧/뺄셈 과정이 복잡
					컴터의 처리 step1. 두수의 부호를 비교
					컴터의 처리 step2. 부호가 같은 경우에는 크기 부분들을 더하고, 다른 경우에는 크기 부분의 차이를 구함
					컴터의 처리 step3. 크기 부분의 절댓값이 더 큰 수의 부호가 부호로 세트
			
				    why2 : 0 에 대한 표현이 2개 
					: 이로 인한 문제
						 • 데이터가 ‘0’인지 검사하는 과정이 복잡함
						 • 𝑛-비트 단어로 표현할 수 있는 수들이 2𝑛 개가 아닌, (2𝑛 − 1)개로 감소
					0 0000000 = +0
					1 0000000 = -0


			sol 2. 1의 보수 표현 : 모든 비트들을 반전 (0 → 1, 1 → 0)
				: 문제점 
					1. 얘도 0 에 대한 표현이 2개 (양의 0 과 음의 0 이 존재 )
						: 8-비트 2진수로 표현할 수 있는 10진수의 범위가 1의 보수로 표현할 때가 2의 보수로 표현할 떄보다 더 작다

				: 참고 what is 보수 표현 (complement representation) >> 음수를 2진수로 표현하는 방법

			sol 3. 2의 보수 표현 : 1의 보수 적용시키고 +1 함
			******: 왜 1 의 보수 안쓰고 2의 보수 쓰냐 >> 2의 보수는 0 이 하나 있다. 



비트 확장
	- int(4byte) + short(2 byte) 를 가능하게 하는 것. 그러니까 서로 다른 자료형의 값끼리 연산을 가능하게 하기 위한 형변환
	- 비트가 추가되더라도 표현만 바뀌는 거지 값 자체는 바뀌면 안된다
	- 부호화-크기 표현의 비트 확장: 부호 비트를 새로운 맨 좌측 위치로 이동시키고, 나머지 위치들은 무조건 0으로 채움
		• +21 = 00010101 >> 0000000000010101
		• -21 = 11101011 >> 1000000000010101

	- 2의 보수 표현의 비트 확장: 확장되는 상위 비트들은 "부호 비트와 같은 값"으로 세트
		: 그러니까 추가되는 얘가 0 일 수도 1일 수도 있단 소리임
			: 양수였음 0 이 추가되는거고 음수였음 1 이 추가된느거임

		• +21 = 00010101 >> 0000000000010101
		• -21 = 11101011 >>1111111111101011
	

<논리 연산>
	
멀티플렉서(multiplexer, MUX) : 2**n개의 입력 선들 중에서 하나를 n개의 "선택신호"따라 선택하여 출력 선에 연결하는 조합논리회로
	: 입력은 n 개인데 출력은 1개
	- D0 , D1 ,, .. D7 >> 선택신호 

디멀티플렉서(demultiplexer, DEMUX): 정보를 한 선으로 받아 "선택신호"따라 2**n 개의가능한출력선들중하나를선택하여, 받은정보를전송하는회로
	: 입력이 1갠데 출력은 n 개


레지스터의 일부 비트만 병경 하는 법
	: 기본적 논리연산(AND 연산, OR 연산, XOR 연산, NOT 연산)을 활용한 응용된 논리연산(선택적-세트 연산, 선택적-보수 연산, 마스크 연산, 삽입 연산, 비교 연산)을 활용




선택적-세트(selective-set) 연산: 데이터의 일부 비트들을 1로 세트(셋팅)해주는 논리적 연산
	: 대응되는 위치의 비트들을 1로 셋팅한 것을 OR 연산 적용시킨다 

선택적-보수(selective-complement) 연산: 데이터의 일부 비트들을 보수화(반전)시키는 논리적 연산
	: 보존하고 싶은 얘는 0 으로 취하고 ,바꾸고 싶은 부분은 1 로 취한걸 대상비트와 XOR 연산 적용시킨다


마스크(mask) 연산: 데이터 일부 비트들을 0으로 리셋(reset) 시키기 위한 논리적 연산
	- 0으로 바꾸고 싶은 부분을 0 으로 채우고 기존 유지 원하는 부분은 1 로 채운 꼴을 AND 연산 활용

삽입(insert) 연산: 데이터의 일부 비트들을 새로운 값들로 대체시키기 위한 논리적 연산
	- how
		step1. 삽입할 비트 위치들에 대하여 마스크(AND) 연산 수행
		step2. 새로이 삽입할 비트들과 OR 연산을 수행


비교 연산 : A와 B 레지스터의 내용을 비교
	- XOR 연산 활용	
		- 만약 대응되는 비트들의 값이 같으면 → A 레지스터의 해당 비트를 ‘0’으로 세트
		- 만약 서로 다르면 → A 레지스터의 해당 비트를 ‘1’로 세트
		- 모든 비트들이 같으면(A = 00000000) → Z(zero) 플래그를 1로 세트




<시프트연산>
시프트 연산 : 레지스터 내 데이터 비트들을 왼쪽 || 오른쪽으로 한 칸 씩 이동
	- 좌측시프트 : 모든 비트들을 좌측으로 한 칸씩 이동
		- 최하위 비트로는 ‘0’이 들어오고, 최상위 비트는 버림
	- 우측시프트 : 모든 비트들이 우측으로 한 칸씩 이동
		- 최상위 비트(𝐴4)로 ‘0’이 들어오고, 최하위 비트(𝐴0)는 버림

	- 시프트 기능을 가진 레지스터의 내부 회로 >> D 플립플롭(flip-flop)
		: D 플립플롭(flip-flop):
			: • 클록 펄스(상승/하강엣지)가 입력되면 기존의 저장 값이 Q로 출력되고 D의 입력이 D 플립플롭에 저장됨


순환 시프트 : 똥꼬에 있는게 머리로 들어간다...  (최상위 혹은 최하위에 있는 비트를 버리지 않
고 반대편 끝에 있는 비트 위치로 이동
▪순환 좌측-시프트(circular shift-left): 최상위 비트가 최하위 비트 위치로 이동
▪순환 우측-시프트


직렬 데이터 전송(serial data transfer) : (시프트를 이용해) 복사하기.
	: 시프트 연산을 데이터 비트 수만큼 연속적으로 수행함으로써 두 레지스터들 사이에 한 개의 선을 통하여 전체 데이터를 이동하는 동작
	: 34p >> A 레지스터의 내용은 보존됬는데, B 레지스터는 A 의 내용이 복사됨(수정됨)


산술적 시프트(arithmetic shift)
	- 수(number)를 나타내는 데이터(부호를 가진 데이터)에 대한 시프트 동작
	- 부호 비트(최상위비트) 는 "불변"이어야된다 !!! 
		- 수의 크기를 나타내는 비트 들에 대해서만 시프트한다
	- ▪산술적 좌측-시프트 : 걍 0 이 들어온다
	- ▪산술적 우측-시프트(arithmetic shift-right)
	******: 부호 비트의 확장이 일어난다 ( 꼭 0 이 아니라 1 이 들어올 수도 있다)


시프트의 주요 용도
	- 특정 산술 연산의 속도를 높이는 데 사용
		- 빠르게 2의 제곱수를 곱하거나 나눌 수 있음
		    : 오버플로우가 발생하지 않았다면 아래와 같다
			• "양의 정수"를 왼쪽으로 k 비트 시프트->  원래 수에 2**𝑘 곱한 것과 같음
			• "양의 정수"를 오른쪽으로 k 비트 시프트 ->  원래 수에 2**𝑘  나눈 것과 같음


C 플래그(캐리)를 포함한 시프트 연산
	- 실제 CPU에서는 일반적으로 시프트 연산에 올림수(C , 즉 캐리) 플래그가 포함
		▪SHLC(shift left with carry): C 플래그를 포함한 좌측-시프트
		▪SHRC(shift right with carry): C 플래그를 포함한 우측-시프트
		▪RLC(rotate left with carry): C 플래그를 포함하는 좌측 순환 시프트(회전)연산
		▪RRC(rotate right with carry): C 플래그를 포함하는 우측 순환 시프트(회전)연산

	- 산술적 "우측 시프트"에서 C 플래그의 값이 포함되면, 데이터의 부호가 변경되는걸 방지해야됨 !!!
		- 변경이 발생할 경우 
			sol1. 오버플로우(V) 플래그 세트해서 (오류가 발생했다는걸) 알려줘야됨
			sol1. C 플래그가 레지스터로 들어오지 못하게 막음

	******- 좌측 시프트는 상관 없다 

