



<산술논리연산장치 ALU>
	- 산술 연산과 논리 연산을 수행하는 하드웨어 모듈
	- 구성 요소
		▪ 산술 연산장치: 산술 연산들(+, -, ×, ÷)을 수행
		▪논리 연산장치: 논리 연산들(AND, OR, XOR, NOT 등)을 수행
		▪시프트 레지스터(shift register): 비트들을 좌측 혹은 우측으로 이동시키는
기능을 가진 레지스터
		▪보수기(complementer): 2진 데이터를 2의 보수로 변환(음수화)
		▪상태 레지스터(status register): 연산 결과의 상태를 나타내는 플래그(flag)
들을 저장하는 레지스터


		

<컴퓨터 산술과 논리 연산>

정수의 표현
	- 2진수 체계: 0, 1, 부호 및 소수점으로 수를 표현
		- 부호 없는 정수 unsinged >> 2진수 데이터를 그대로 2진수로 읽으면 된다
		- 부호가 있는 정수 >> 음수와 양수를 구분해야된다 
		- 𝑛-비트 부호 없는 정수의 표현 가능 범위: 0 ~ 2 **(𝑛 − 1)


	- 2진수, 8진수, 10진수, 16진수의 진법 변환
	-

소수의 표현
	- 정수부분 + . + 소수점이하부분
	- 10진수로의 변환 방법 : 소수점 이하이든 이상이든 걍 a*(2**n) 한 거 똑같이 더하는거임.
	
	
음수의 표현
	- 최상위 비트 : 0 >> 양수
	- 음수 
		- 어떤 표현 방법을 채택하든 결과적으로 음수의 최상위 비트는 1이 된다
		- 표현 방법
			sol 1. 부호화 크기 표현 : 최상위 비트로만 구분. (최상위 비트 이하 부분은 모두 동일)
				; 단순 최상위 비트 가 1 이면 음수, 0 이면 양수 인 것.
				: 사람 입장에선 직관적이여서 편하긴 한데, 컴터 입장에선 불편
				    why1 : 덧/뺄셈 과정이 복잡
					컴터의 처리 step1. 두수의 부호를 비교
					컴터의 처리 step2. 부호가 같은 경우에는 크기 부분들을 더하고, 다른 경우에는 크기 부분의 차이를 구함
					컴터의 처리 step3. 크기 부분의 절댓값이 더 큰 수의 부호가 부호로 세트
			
				    why2 : 0 에 대한 표현이 2개 
					: 이로 인한 문제
						 • 데이터가 ‘0’인지 검사하는 과정이 복잡함
						 • 𝑛-비트 단어로 표현할 수 있는 수들이 2𝑛 개가 아닌, (2𝑛 − 1)개로 감소
					0 0000000 = +0
					1 0000000 = -0


			sol 2. 1의 보수 표현 : 모든 비트들을 반전 (0 → 1, 1 → 0)
				: 문제점 
					1. 얘도 0 에 대한 표현이 2개 (양의 0 과 음의 0 이 존재 )
						: 8-비트 2진수로 표현할 수 있는 10진수의 범위가 1의 보수로 표현할 때가 2의 보수로 표현할 떄보다 더 작다

				: 참고 what is 보수 표현 (complement representation) >> 음수를 2진수로 표현하는 방법

			sol 3. 2의 보수 표현 : 1의 보수 적용시키고 +1 함
			******: 왜 1 의 보수 안쓰고 2의 보수 쓰냐 >> 2의 보수는 0 이 하나 있다. 



비트 확장
	- int(4byte) + short(2 byte) 를 가능하게 하는 것. 그러니까 서로 다른 자료형의 값끼리 연산을 가능하게 하기 위한 형변환
	- 비트가 추가되더라도 표현만 바뀌는 거지 값 자체는 바뀌면 안된다
	- 부호화-크기 표현의 비트 확장: 부호 비트를 새로운 맨 좌측 위치로 이동시키고, 나머지 위치들은 무조건 0으로 채움
		• +21 = 00010101 >> 0000000000010101
		• -21 = 11101011 >> 1000000000010101

	- 2의 보수 표현의 비트 확장: 확장되는 상위 비트들은 "부호 비트와 같은 값"으로 세트
		: 그러니까 추가되는 얘가 0 일 수도 1일 수도 있단 소리임
			: 양수였음 0 이 추가되는거고 음수였음 1 이 추가된느거임

		• +21 = 00010101 >> 0000000000010101
		• -21 = 11101011 >>1111111111101011
	

<논리 연산>
	
멀티플렉서(multiplexer, MUX) : 2**n개의 입력 선들 중에서 하나를 n개의 "선택신호"따라 선택하여 출력 선에 연결하는 조합논리회로
	: 입력은 n 개인데 출력은 1개
	- D0 , D1 ,, .. D7 >> 선택신호 

디멀티플렉서(demultiplexer, DEMUX): 정보를 한 선으로 받아 "선택신호"따라 2**n 개의가능한출력선들중하나를선택하여, 받은정보를전송하는회로
	: 입력이 1갠데 출력은 n 개


레지스터의 일부 비트만 병경 하는 법
	: 기본적 논리연산(AND 연산, OR 연산, XOR 연산, NOT 연산)을 활용한 응용된 논리연산(선택적-세트 연산, 선택적-보수 연산, 마스크 연산, 삽입 연산, 비교 연산)을 활용




선택적-세트(selective-set) 연산: 데이터의 일부 비트들을 1로 세트(셋팅)해주는 논리적 연산
	: 대응되는 위치의 비트들을 1로 셋팅한 것을 OR 연산 적용시킨다 

선택적-보수(selective-complement) 연산: 데이터의 일부 비트들을 보수화(반전)시키는 논리적 연산
	: 보존하고 싶은 얘는 0 으로 취하고 ,바꾸고 싶은 부분은 1 로 취한걸 대상비트와 XOR 연산 적용시킨다
