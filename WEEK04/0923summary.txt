주소 지정 단위 >> 기억 장치에 몇 bit 로 저장되는지 .. 
	: 레지스터 아님 주의 

1. 직접 주소 지정 방식
	: EA = A
	: A == 데이터의 주소
	: 메인 메모리 >> 1번 access  , 레지스터 >> 1번 액세스
	: 장점 >> 데이터 인출을 위해 한 번의 기억장치 액세스만 필요
	: 단점 >>   직접 지정할 수 있는 기억 장치의 주소가 제한적 << 단점떄문에 전역 변수 같은걸 저장할 떄 주로 사용된다
	


2. 간접 주소 지정 방식
	: 간접 사이클과 유사
	: A == 데이터의 주소의 주소 . 그러니까 주소 A 에 실제 찾고자하는 주소가 값으로 들어가있따
	: 메인메모리 액세스 >> 2번, 래지스터 액세스 >> 1번
	: 장점 >> 최대 기억장치용량이 워드의 길이에 의하여 결정
		: 워드 길이가 𝑛 비트라면, 최대 2**n개의 기억 장소에 대한 주소지정이 가능

	: 단점 >> 두 번의 기억장치 액세스가 필요. 속도가 느리다.  << 이것 떔에 잘 사용되지 ㅇ낳는다
	:  만약 I = 1 이면, 간접 주소지정 방식 → 간접 사이클 실행
		: 별다르게 간접 비트에 대한 언급이 없으면 간접 주소 지정 방식이 아닌거임


3. 묵시적 주소 지정 방식 << 이미 (AC 나 Stack 같은 곳에) 주소가 지정되있는 .. 	
	: ex ) 
		‘POP’ 명령어 >> stack 에서의 명령어.. 
		‘SHL’ 명령어: 누산기에서의 명령어 ...
	: A 가 없다
	: 액세스 정도는 케바케라서 패스
	: 장점 >> 명령어가 간결
	: 단점 >> 사용될 수 있는 경우가 적다 (묵시적으로 나타낼 수 ㅇㅣㅆ는 애가 적다)


4. 즉시 주소 지정 방식 
	: 데이터가 명령어에 포함되어있는 방식. 그러니까 오퍼랜드 필드에 실제 데이터가 들어있는 
	: 메인메모리 액세스 >> 0번, 래지스터 액세스 >> 0번
	: 장점 >> ㅈㄴ 빠르다
		: 이 방식이 가장 빠르다. 기억 장치나 레지스터에 별도로 액세스가 필요 없으니까 
	: 단점 >> 넣을 수 있는 상수 값의 크기가 제한적임. (오퍼랜드 필드 비트 수 범위 내에서만 할당 가능)
	: 보통 초기값 설정하는데 많이 사용


5. 레지스터 (직접) 주소 지정 방식
	: 명령어의 오퍼랜드가 해당 레지스터를 가리키는 방법
	: 연산에 사용될 데이터가 레지스터에 저장되어있는 경우에 사용
	: 직접 주소 방식처럼 쓰는데 기억장치가 아닌 레지스터를 활용하는 것	
	: R == 데이터를 가진 레지스터의 주소
	: 메인메모리 액세스 >> 0번, 래지스터 액세스 >> 1번
	: 장점 >> 
		1. 오퍼랜드 필드 비트 수가 적어도 됨
			: 레지스터의 숫자가 적으니까

		2. 속도 빠름 << cpu 에 있으니까

	: 단점 >> 데이터가 저장될 수 있는 공간이 CPU 내부 레지스터들로 제한



6. 레지스터 간저ㅂ  주소 지정 방식
	: 명령어의 오퍼랜드가 해당 레지스터의 유효 주소를 가리키는 방법
	: R == 데이터의 주소를 가진 레지스터의 주소
	: 메인메모리 액세스 >> 1번, 래지스터 액세스 >> 1번
	: 장점 >> 간접이다 보니 주소 지정할 수 있는 기억장치 영역이 확장
	: 단점 >> 데이터 인출을 위하여 한번의 "기억장치" 액세스가 필요


7. 변위(오프셋) 주소 방식
	: "기준 레지스터 + R -> 유효주소" 되는것 활용하는 것
		: 기준 >> A  
		: 변위 >> R
	: A == 변위
	: R == 기준레지스터
	: 기준 래지스터 액세스 >> 1번, 메인메모리 액세스 >> 1번
	: 사용되는 레지스터에 따라 다양한 변위 주소지정 방식 가능
	    기준 1 >>  PC: 상대 주소지정 방식(relative addressing mode)
		8. 상대 주소지정 방식
			: PC >> 기준
			: A >> ?
			: 앞 또는 뒤로 일어난다
			: 장점 >>  (전체 기억장치 주소가 명령어에 포함되어야 하는) 일반적인 분기 명령어보다 적은 수의 비트만 필요. 비트 전체가 필요없다.
				: PC가 묵시적으로 지정될 수 있으므로 레지스터 필드가 필요 없음
			: 단점 >> 분기 범위가 오퍼랜드 필드의 길이에 의해 제한


	    기준 2 >> 인덱스 레지스터: 인덱스 주소지정 방식(indexed addressing mode)
		9. 인덱스 주소지정 방식	
			: A == 배열의 시작 주소
			: IX == 현재 인덱스
			: 주요 용도: 배열 데이터 액세스
			: 특징 >> 자동 인덱싱이 가능하다 
				: 2개의 연산이 동시 실행된다
					: EA = (IX) + A
					: IX  IX + 1


	    기준 3 >> 베이스 레지스터: 베이스-레지스터 주소지정 방식(base-register addressing mode)
		10. 베이스-레지스터 주소지정 방식
			: 베이스 레지스터의 내용과 변위 A를 더하여 유효 주소를 결정
			: 베이스 >> 기준점. 프로그램이나 데이터 블록의 시작 주소
				: 베이스 레지스터(BR): 기준(base)이 되는 프로그램이나 데이터 블록의 시
작 주소가 저장

			: 다중 프로그래밍 에서 프로그램 시작 주소 지정/변경할 떄 자주 사용한다



주의 문제 >> 상대 주소지정 방식을 사용하는 JUMP 명령어가 450번지에 저장됨. 만약 오퍼랜드 A = ‘21’이라면, 몇 번지로 분기하는가?
	: 451 + 21 로 472 이다. "450+21 이 아님을 주의!!!!"
		: 이 명령어가 인출 된 후에는 PC의 내용이 451로 증가됨






간접 레지스터는 속도가 넘 느려서 잘 안쓰인다


명령어 설계 철학 : CISC 가 먼저 나오고 RISC 가 나중에 나왔다
	CISC >> 명령어는 복잡해야된다
		: 3 주소 명령어 
		: 프로그램 길이가 감소
		: 명령어 ㅣㄹ행 시간이 김<< 주소 지정 방식이 다양
		: 명령어 수. 종류가 많음.
		: 고성능이다 -> 보통 CISC


	RISC >> 명령어는 간단해야된다
		: 1 주소 명령어
		: 프로그램 길이가 증가
			: 그러니까 1 줄 쓸 수 있는걸 4줄로 길게 늘려서 써야됨
		: 명령어 수. 종류가 적음. 필요한 것만 있음
		: 명령어의 길이가 일정
		: 주소 지정 방식 종류가 단순.
		: 전력 효율성 우수 -> 보통 RISC






