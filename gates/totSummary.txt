VIAVDO 프로그램 사용법

모듈 == 하나의 독립적인 시스템. 부분.

RTL Register-transfer level :  레지스터와 로직회로를 이용하는 "디지털 회로 설계" 수준.
	: vhdl 을 이용하여 design 한 결과물을 RTL 이라 봄 된다

design source : 우리가 실제로 디자인한 로직, 코드.
	: vhdl 의 언어로 작성
	: @@@@.vhd 
		:  헷갈리지 않게 하기 위해 모듈명과 파일명을 일치하게 해라
	: DUT 를 만드는 거임

testbench == simulation source : 작성한 design source를 검증하는 코드.
	: 가상으로 만들어진 파일이지, 실제로 존재하진 않는다.
		: https://www.youtube.com/watch?v=HmlJ7DFMwOM
	: 테스트 밴치엔 port 존재 안한다
	: 보통 다음의 모듈을 추가한다
		- DUT Design Under Test : 설계한 모듈. 테스트 중인 장치
		- clock & reset gen : degital logic 을 동작시키기 위해 필요한 clock 과 reset 을 만들어주는 모듈
		- stimulus : DUT 의 input 을 gen 하는 역할을 한다. 자극을 주면 output 이 나오는게 digital logic,
		- checker : DUT 의 output 이 원하는 결과에 맞는지 check 하는 모듈

Behavioral simulation : cell 및 wire 의 delay 정보가 들어가지 않은 코드 자체의 functional simulation



https://rubber-tree.tistory.com/28
메뉴바
	simulation>> 작성된 코드를 rtl 시뮬레이션 (테스트벤치적용) 할때 사용. 제대로 설계되었나 확인
	RTL_ANALYSIS >> (시뮬레이션 후) 생성된 도식 확인
	synthesis >> 시뮬레이션까지 다 했으면 synthesis, 즉 합성을 함
	implementation > 합성이 완료되면 실제로 물리적 소자와 맵핑을  함


보라색 코드 >> 예약어 : 식별자 명으로 사용 불가

------------------------------------------------------------------------------------------------------------

vhdl 기본 구조
	: 한 설계(파일)에 다수의 entity, architecture 가 있을 수 있으나 꼭 한개의 entity에 한개의 architecture가 짝을 이루게 해야된다

	(1) Entity Declaration >> 엔티티의 인터페이스( 외적연결 그러니까 port , generic) 정의하는 부분
		Entity : VHDL 설계의 기본 단위. 전반적인 시스템.
		: Entity Declaration 에서 정의 가능한 요소
			: generic 과 port 는 모두 component 에서도 (새로) 선언 가능하다
			: generic >> 설계를 일반화하는데 사용되는 매개변수
				: https://m.blog.naver.com/go_forever/220235957694
				: 밑 쪽 정리에 더

			: port >> 입구, 출입구 라고 보면된다. "인터페이스" 이다.
				: port( 포트명1 : 모드 타입;
						...
					포트명n : 모드 타입 );

					: 주의 ) port( ); 내부의 마지막 줄엔 ';'안붙인다
						: 모드 >> 특정 포트의 데이터 흐름 방향 을 정의한다 
							: 종류 )  in , out , inout, buffer 

		: 형식 ) 
			entity 엔티티명 is
				generic (파라미터명1 : 타입 ;
								. . .  
				파라미터명n : 타입 );
				port( 포트명1 : 모드 타입;
					...
					포트명n : 모드 타입 );
			end 엔티티명;

				: 주의 ) end entitiy; 가 아니라 end 엔티티명 이다


	(2) Architecture Body>> 엔티티 내부 동작을 정의하는 부분.  실제로 실행되는 부분.
			: 형식 ) 
				architecture 아키텍쳐명 of 엔티티명 is
					객체선언부
				begin
					실행사항
				end 아키텍쳐명;
	



------------------------------------------------------------------------------------------------------------

vhdl 기본 문법


:https://prosigi.tistory.com/83
:https://m.blog.naver.com/ansdbtls4067/221249221793


: https://blog.naver.com/r2adne/120155040778



component||proccess 는 end component||proccess;
entity||Arcitecture 는 end 해당이름;




1. 기본 문법
	- VHDL 은 대소문자 구분을 하지 않는다.
	- VHDL 에서 문장간의 구별은 세미콜론(;) 으로 표시 한다.
		: 가독성을 위해 엔터 무한대로 칠 수 있다

	- '--' 로 한 줄 주석처리 가능.
	- '/* */' 로 여러줄 주석처리 가능
	- 논리적 '0' 과 '1'
		: '0' == 논리적 거짓 >> 거짓. 비활성. 꺼짐
		: '1' == 논리적 참 >> 참. 활성. 켜짐.
			: 따로 false, true 는 없음 주의

		: 0 과 '0' , 1과 '1' 은 다르다
			:0,1 은 계산할때 쓰이는 Numeral Literal 이고 '0' 과 '1' 은 논리적 0 과 1 을 나타내는 character Literal 이다

이게 뭐임?? vHdl 에서 field ?? >>- Field 와 Attribute
		: Field  >> 레코드 또는 객체 내부 데이터
			: 주로 레코드 또는 객체의 "구성 요소"를 나타내는데 사용
			: 외부 코드에서는 '직접'은 접근 불가해서 getter 와 setter 메서드 사용 필요

		: Attribute >> 레코드 또는 객체 외부 데이터
			: 주로 레코드 또는 객체의 "상태"를 나타내는데 사용
			: 외부 코드에서는 '직접'은 접근 가능 && getter 와 setter 메서드도 사용 가능



2. VHDL 의 기본 구성
	(-3) 대입 연산자
		1.  <= 
			: 값이 즉시 할당되는 것이 아니고, 다음 사이클에 적용될 신호 할당을 해준다
				:  Process문 내의 '<=' 의 경우 Process문이 끝나는 End process를 만날 때 비로써 그 값이 대입된다. 즉 시간이 지남에 따라 변한 값을 가진다.

			: "=>"는 대입연산자가 아니다
				: port map 에서 형식포트명과 실제 포트명을 mapping 하는데 사용된다.

		2.  :=
			: 값이 즉시(딜레이 없이) 대입된다.
			: 변수나 상수를 초기화하는데 사용된다


	(0) 객체 object
		: 값을 가질 수 있는 것을 말한다. 
		: 객체는 " 객체종류 객체명 : 타입; " 의 꼴로 선언된다
			: 선언과 동시에 초기화 가능
				ex) 
					variable a : std_logic;
					a:='0';
					은

					variable a : std_logic := '0' ; 
					와 같다

		: 객체의 종류 >> 객체의 성질( 선 , 단순임시저장용, 상수저장용 ) 을 결정하는 것.
			: 주의 ) 객체의 종류와 자료형은 다른거다. 

			1. signal
				: VHDL 합성시 Wire(선) 로 구현되며, Component 의 연결에 사용되는 외적 변수이다.
					: 선이란 ? >> 하드웨어의 선(버스) 같은거. 회로도에 표시되는 선.
 
				: 선언 위치 >> architecture 의 begin 윗 부분

					1) Entity Declaration Section
					2) Architecture의 Declaration Section (architecture문과 begin문 사이)
					3) Package Declaration Section
					4) port signal에서 선언

				: 대입
					: Delta Delay 이후에 대입된다.
						: 초기값을 대입할때만 " := " 을 사용하고, 이외의 모든 값을 대입할땐 "  <= " 를 사용한다
						: delay 값을 명시하지 않을 경우 default 값으로 delay 되는데 사용자 입장에서 명확하지 않으므로 가능하면 delay 되는 시간을 명시해라 
						: ex)    
							signal temp : std_logic_vector(3 downto 0) := "1000";
							temp <= "0000" after 10ns;
			


			2. variable
				: 단지 중간 연산단계에 주로 이용되고, (Wire로 구현되진 않음), process나 부프로그램( function,  procedure) 에서 사용되며 그 내부에서만 유효한 내적 변수이다
				: 선언 위치
					1) Entity Declaration Section
					2) Architecture의 Declaration Section (architecture문과 begin문 사이)
					3) Package Declaration Section ( process ~ begin 사이 )

				: 대입 >> delay 없이 바로 된다
					: 기호는  ":=" 만 사용한다
	
			3. constant
				: 상수를정의하는데 사용된다
				: 선언 && 초기화 위치 >> architecture 의 begin 윗 부분.
				: 대입  >> delay 없이 바로 된다
					: 기호는 ":=" 만 사용한다 


	(1) 속성 attribute
		: 객체의 추가적인 정보. 
		: ' 표시로 접근 >> 객체명'속성명
		: 주로 배열 객체를 대상으로 쓰인다

		: 종류
			1. 사전 정의 attributes
				(1) 값 vlaue 관련 >> 단순히 특정 값을 반환하는 속성
				******1. 'Left , 'Right : 제일 왼쪽(처음)  오른쪽(끝) || 값 반환
				******2. 'High , 'Low: 가장 큰 | |작은 값 반환
				******3. 'Length: 배열객체의 사이즈(요소 갯수) 반환
					4. 'Ascending : 해당 객체가 오름차순이면 true, 아니면 false 를 반환

					5. 'Structure, 'Behavior : 해당 객체가 다른 객체에게 참조 당하고 있으면 true, 아니면 false 를 반환

					6. 'Simple_name, 'Instance_name , 'Path_name : 경로를 String 으로 반환

				(2) 함수 function >> 함수와 같은 속성
					: 일부는 arg 를 필요로 하고, 일부는 arg 를 필요로 하지 않는다
					: 배열 객체 , 시그널 객체를 대상으로 쓰인다
				******1. 'Pos( 특정값 ) : 해당 값이 배열의 몇번째 인덱스인지 반환
						: 인덱스는 0 부터 시작하는거 주의 
						type state_type is (Init, Hold, Strobe, Read, Idle);
						variable P: integer := state_type’pos(Read); --  Read 는 3 번쨰 값이므로 3 을 반환한다
 
				******2. 'Val( 인덱스값 ) : 배열의 해당 인덱스에 저장한 값을 반환
						type state_type is (Init, Hold, Strobe, Read, Idle);
						variable P: integer := state_type’val( 3 ); --  3 번째 값은 Read 이므로 Read 를 반환	
					3. 'Succ( 특정값 ) : 현재 배열을 오름차순으로 정리했을 때( 숫자가 아니라면 원본 배열이 오름차순으로 여겨진다. 그러니까 이미 존재하는 배열을 reverse 한 배열은 내림차순이 되는 것이다 )의 해당 값의 바로 다음의 위치한 값을 반환
						type state_type is (Init, Hold, Strobe, Read, Idle);
						variable P: integer := state_type’succ( read ); -- read 바로 다음의 Idle 를 반환

					4. 'Pred( 특정값 ) : 현재 배열을 오름차순으로 정리했을 떄의 해당 값의 바로 이전의 값을 반환
						type state_type is (Init, Hold, Strobe, Read, Idle);
						variable P: integer := state_type’pred( read ); -- read 바로 앞의 Hold 를 반환

					5. 'leftof( 특정값 ) :  현재 배열 그 자체에서 해당 값의 바로 이전의 값을 반환
						: 현재 배열이 오름차순일 때는 >> 'Pred( 특정값 ) ==  'leftof( 특정값 )
						: 현재 배열이 내림차순일 때는 >> 'Succ( 특정값 ) ==  'leftof( 특정값 )


					6. 'rightof( 특정값 ) :  현재 배열 그 자체에서 해당 값의 바로 다음의 값을 반환

					7. 'left ( 범위 ) : 해당 범위의 시작값을 반환
						: 아래에서 써놨지만 배열 객체의 범위는 배열명'range 하면 구해진다.
					8. 'right( 범위 ) : 해당 범위의 끝 값을 반환
					9. 'High( 범위 ) : 해당 범위의 가장 높은 값을 반환
						: 오름차순 범위이면 >> 'right( 범위 ) == 'high( 범위 )
						: 내림차순 범위이면 >> 'left( 범위 ) ==  'high( 범위 )

					10 'Low( 범위 ) : 해당 범위의 가장 낮은 값을 반환
					

				******11. 'Event :  대상 "시그널" 의 값이 변경되면 true 를 , 아니면 false 를 반환
						
					12. 'Active : 대상 "시그널"이 유효하면(== U 가 아니면) true , 아니면 false 반환
						: 'Event 와 다르게 값의 변화가 없어도 값이 유효하면 true 인거임

					13. 'last_event : 이전에 값이 변경됬던 시간 반환
					14. 'last_active: 이전에 값이 유효했던 시간 반환
					15. 'last_value: 이전 값 반환

				(3) 신호 signal
					1. 'Delayed( 시간 )
					2. 'Stable
					3. 'Quiet
					4. 'Transaction

				(4) 타입 type
				(5) 범위 range

			2. 사용자 정의 attributes

			
		: http://pldworld.info/_hdl/2/_ref/acc-eda/language_overview/objects__data_types_and_operators/understanding_vhdl_attributes.htm
		: https://dad-rock.tistory.com/444

	
	(-1) 리터럴 Literal
		: String 리터럴 >> "어쩌구"
			: 코드 내부에 쓰인 "" 없는 문자열은 문자열리터럴 이 아니라 이미 존재하는 객체나 ㅋ워드 같은거임

		: Character 리터럴>>  '문자'
		: Bit String 리터럴
			2진 >> B"값"
			8진 >> O"값"
			16진 >> X"값"

		: Numeric 리터럴 
			1.정수(Integer) 리터럴
				: 10진수 정수 >> 그냥 숫자 (ex: 1234 ) 
				: 2,8,16 진수 정수 >> 진수#숫자 (ex: 8#132 )
					: 가독성을 위해 '_' 사용 가능하ㅏ다
					: ex) 2#1110_0000 == 2#11100000

			2. 실수(real) 리터럴
				: 소수점있는숫자(ex: 19.32) 혹은 E 들어간 숫자(ex: 1E6)

			3. 물리 리터럴
				: 12ft 같은거



	(-2) 타입 Type
:https://prosigi.tistory.com/83

		: 있는거 그대로 쓸수도 있고. 사용자가 직접 만들어 쓸수도 0.
		: 암기 tip >> 범위 지정하는데 RANGE 라는 키워드가 있으면 괄호 없이, RANGE 라는 키워드가 없으면 괄호 있이 쓰는거다
		: 타입 종류
			(1) Scalar Type 숫자형 :  숫자(0 , 1, 2, 3 .. 등)로 순서를 정의할 수 있는 자료형
				1. 열거형 Enumeration Type : STD_LOGIC, BOOLEAN , CHARACTER 
					: STD_LOGIC >>
						: 주의 ) STD_LOGIC_1164라이브러리 사용 시 BIT 타입은 따로 안쓰고  STD_LOGIC 타입을 쓴다

						'U': uninitialized
						'X': unknown. Impossible to determine this value/result.
					******'0': 논리적 0 ,그러니까 false
					******'1': 논리적 1, 그러니까 true
						'Z': High Impedance. 그러니까 저항이 매우 높은 상태, 그러니까 전류가 거의 흐르지 않는 상태
							: High Impedance vs Weak signal 
								: High Impedance == 전류가 거의 안흐른다
								: Weak signal == 논리적 수준이 불확실하다

						'W': Weak signal, 0인지 1인지 판별불가상태
						'L': Weak signal 인데 아마도 0 인 상태(==Low)
						'H': Weak signal 인데 아마도 1 인 상태(==High)
						'-': Don't care.

					: BOOLEAN >> true 혹은 false 할당
					


				2. 정수형  : INTEGER 
					: (정수형 자체의 범위가 넓어서 기본적으로는 32 비트를 차지하는데, 쓸만큼만 비트를 할당하기 위해서 ) 범위를 특정하여 쓸 수도 있다 >> INTEGER RANGE 시작값 TO 끝값;
					: ex ) SIGNAL inputA : INTEGER RANGE 3 to 19;

				3. 실수형  : REAL
				4. 물리형  :  UNIT : TIME, DISTANCE

			(2) Composite Type 복합형 : Scalar Type을 조합하여 사용할 때 사용하는 자료형. 
				1. 배열형 Array Type : 같은 Scalar Type 의 원소로만 이뤄져야됨. 주로 Scalar type 의 범위를 좀더 좁히기 위해 사용한다
					: 배열형의 인덱스 통한 접근 방법 >> 배열명(인덱스)
					(1) 제한형 Constraint Type  : TO, DOWNTO
						: 각각 "숫자1<= <= 숫자2" (이상 이하)가  된다 
						작은숫자 TO 큰숫자 
						큰숫자 DOWNTO 작은숫자

					(2) 무제한형 Unconstraint Type: STD_LOGIC_VECTOR, STRING , BIT_VECTOR				: STD_LOGIC_VECTOR >> std_logic 데이터 타입을 여러개 묶어놓은 데이터 타입
							: 쌩으로 쓰지 않고 STD_LOGIC_VECTOR( 값1 TO||DOWNTO 값2 ) 이런식으로 쓴다.
							: 사실 array (n downto 0) of std_logic 과 같은 소리다.


						******1. STD_LOGIC_VECTOR( n DOWNTO 0 ) : "내림차순"으로 n+1 개를 묶은 것
								: 0번쨰 비트는 오른쪽에서 시작하므로 DOWNTO 를 써야된다  
								ex)  A <= "11001100" 했을 때 A(0) == 젤 뒤 '0'



							2. STD_LOGIC_VECTOR( 0 TO n )  : "오름차순"으로 n+1 개를 묶은 것
								ex)  A <= "11001100" 했을 때 A(0) == 젤 앞 '1'



				2. 집합형 Record Type: 다양한 Scalar Type 의 Object 를 묶는 Type. 
					: 내부적으로 다른 scalar타입의 Field 들을 가짐. 
					: Record Type 로 선언된 객체의 field 를 참조하기 위해 '.' 연산자를 사용.
					: Record Type 로 선언된 객체의 field 를 한번에 초기화 하는 것도 가능	
						ex) 

Type Person is record 
        name : string;
        age : integer;
    end record Person;
constant vv : Person := ("kim",19);


						
					
				
		: 사용자 타입 선언 방법>> Type 타입명 is 타입명세;
			(1) Scalar Type
				(1) Enumeration 
					: Type 타입명 is (값1, 값2 , ... );
					: ex ) Type bitbit is ( '0' , '1');

				(2) Integer  , Real  
					: Type 타입명 is range 최소숫자 to 최대 숫자;
					: ex) Type byte is range -128 to 128;
	
			(2) Composite Type
				1. Array Type
					(1) 제한형 Constraint Type  : 
						: Type 타입명 is array( 숫자1 to||downto 숫자2) of 특정scalarType;
						ex) Type byte is array( 7 downto 0 ) of STD_LOGIC;

					(2) 무제한형 Unconstraint Type: 
						: Type 타입명 is array( 특정scalarType range<>) of  특정scalarType;
						ex) Type yayaya is array( Integer range<> ) of STD_LOGIC;

				2. Record Type
					Type 타입명 is record 필드명1: scalar타입 ; 필드명2: scalar타입 ; 필드명3: scalar타입 ;  end record;
						: 마지막 필드 선언할때도 ';' 붙이고, 마지막엔 end record ; 해주는거 잊지 x




	(-1) 부분 타입 subtype : 특정 데이터 타입의 일부만 사용하고 싶을 때 사용
		SUBTYPE 부분타입명 IS 특정타입명 range 시작점 to||downto 종료지점
		ex) 
			TYPE aa IS INTEGER RANGE -100 TO 200 ;
			SUBTYPE bb IS aa RANGE 0 TO 100;


	(1) 연산자 Operator	
		: 괄호를 사용하여 우선순위 조절 가능
		: 종류 
			1. 논리연산자 Logical Operator : or , and , nor, nand , xor , xnor , not
			2. 관계연산자 Relational Operator :  = , /= , < , <= , > , >=
				'=' : 같다
				'/=' : 다르다 

			3. 산술연산자 Arithmetic Operator : + , - , * , / , abs , ** , mod , rem 
				/ : 나눗셈
				abs : 절댓값
					: ex) abs(-18)
				** : n승
				mod : modulo 연산	
				rem : 나머지 연산자

			4. 연결연산자 Concatenation Operator : &
				: 이어준다. (각 위치별로 더하는게 아니라 끝에 붙이는거다)
				: ex) ('0', '1', '1') & ('0', 'Z', '1') = ('0', '1', '1', '0', 'Z', '1')
				: ex)  "Hello" & "World" =  "HelloWorld" ; 
					

			5. 시프트 연산자 Shift Operator :  sll, srl , sla , sra , rol , ror

병행/순차 처리문
	: vhdl 문장은 proccess 문 내부 제외 기본적으로 다 병행처리된다
	: 병행처리문 >> 동시에 처리
	: 순차처리문 >> 순서대로 하나하나 처리
		: 반드시 앞 문장이 실행되야 뒷 문장이 실행될 수 있다


	(2) 대기문 wait statement
		: 순차처리문이다.
		:형식 >> wait for XX; --XX 로는 10ns 같은거 가능
		: 주의 ) proccess 문이 신호 감지절을 가진 경우 ( proccess(A, B) 같이 ) 사용 불가. (썡 proceess 만 있어야) 
		:https://seo-dh-elec.tistory.com/68
			

	 (3) 조건문
		: proccess 문 내부에서 사용되어야 순차문이고, 외부에서는 병렬문이 된다.
		1. if 문
			:  else 는 생략 가능하다 >> 내부적으로 else 생략 시 원래 변수 값을 유지 시킬 수 있도록  else y <= y; 같은걸 지가 알아서 생성해준다

			(1) if ~ else 문 
				if ( 조건문 )  then 
				실행문1;
				실행문2;
				실행문3;
				. . .
				else 
				실행문01;
				실행문02;
				실행문03;
				. . .

			 	end if;

			(2) 다중 if 문 >>
				if ( 조건문 )  then
				실행문1;
				실행문2;
				실행문3;
				. . .
				elsif( 조건문 ) then 
				실행문01;
				실행문02;
				실행문03;
				. . .

				else 
				실행문1;
				실행문2;
				실행문3;
				. . .

			 	end if;


		2. case 문
			: switch 문 같은거. 해당 객체의 값에 따라 실행한다
			: 진리표와 같은 기능표에 대한 설계에 적합
			: 주의 >> 마지막에 when others 로 default 처리를 꼭 해줘야된다
			case ( 객체명 )  is
			when 값1 => 실행문1;
			when 값2 => 실행문2;
			.
			.
			when others => 실행문 ;
			end case;

	(4) 반복문 loop 
		1. for-loop>> 변수 범위만큼 반복
			: 루프 변수는 어떠한 객체로도 선언되지 않고(변수종류 타입 그런거 명시 없이) 단순 변수명만 쓴다. 
			: 변수 범위는 n to m , m downto n 같은거다
			레이블명 : for 루프변수 in 변수범위 loop
				순차처리문
			end loop 레이블명;

		2. while-loop >> 조건이 참일 동안 반복
			레이블명: while (조건문) loop
				순차처리문
			end loop 레이블명;
		3. 단순 loop >> 무한 반복
			레이블명:loop
			순차처리문
			end loop 레이블명;
		: https://prosigi.tistory.com/83


	(5) 조건적 병렬 처리문 when ~ else
		: proccess 문의 외부에서 if 문 처럼 작동하게 하기 위함.
		: https://dad-rock.tistory.com/427
		: https://seo-dh-elec.tistory.com/69
		: 형식 >>
			signal_name <= input_1   WHEN (조건문1)   ELSE
			input_2   WHEN (조건문_2)   ELSE
        	       ...
              		input_n-1 WHEN (조건문_n-1) ELSE
               		input_n;

	(6) 병렬 선택 신호 배정문 with ~ select ~ when
		: proccess 문의 외부에서 case 문 처럼 작동하게 하기 위함.
		: 형식 >> 시그널1이 값1이면 input_1 이 시그널2 에, 값2이면 input_2가 시그널2 에	.. 들어가는거다
			with 시그널명1 select
				 시그널명2 <= input_1   WHEN 값1 ,
				 		   input_2   WHEN 값2 ,
				 		   . . .
				 		   input_n   WHEN OTHERS ,



----------------------------------------------------------------------------------------------------------------


델타지연 : ' <= ' 를 사용하면, 즉 signal 의 값을 할당하면 델타지연으로 모델링 된다
	: 순차문들이 그만큼 지연을 반영하여 순차적으로 진행되는 것이다. 
		: 논리적으로 그런거지, 실제로 시간 지연이 되진 않는다. 그러니까 실제로 더 오래걸리진 않는다
	: 기본적으로 델타 지연을 해주지만 개발자 입장서 명확하지 않으므로 직접 지연 시간을 적는게 추천된다
		: 형식) 시그널변수명 <= 어떤것 AFTER XX ; -- XX로는 20ns 같은게 가능
		: https://dad-rock.tistory.com/414
	: https://seo-dh-elec.tistory.com/69


----------------------------------------------------------------------------------------------------------------

VHDL 모델링 방법
		: https://effectiveresource.tistory.com/m/70
		: (논리)회로의 추상화 >> 회로의 구성 요소를 단순하게 표현하는것
		: 캡술화 >> 내부 구현 정보를 숨기고 인터페이스만 노출하는 설계 기법
			: 엔티티, 컴포넌트 , 패키지 등을 이용해 가능

		(1) Behavioral Description 동작적 표현
			: 논리회로의 동작을 알고리즘적으로 표현하는 것
			: 논리회로에 대한 최상위 추상화 레벨( == 그러니까 젤 간단하게 표현하는 방법이란 뜻 )

			1. Process문
				: 시스템을 모듈별로 기술하는데 쓰인다
					: 시스템은 하드웨어 모듈로 구성되어 있고, 각 모듈은 병행처리를 하면서 서로간의 통신을 통해 관계를 유지한다.   
				
				: Architecture내 begin ~ end 사이에 선언된다. 여러 개의 Process문이 있을 수 있으다.
				:  각 Process문은 병행처리를 하지만, Process문 내부는 순차처리를 한다. 
				:  일종의 무한 루프처럼 동작한다. 감지신호가 변화 할때마다 동작(실행)한다. 
				: 라벨을 부여 가능하나 필수는 아니다
				: 선언 형식
					라벨명: process( 감지신호1, 감지신호2 .. )               
						begin
							. . .	
					end process 라벨명;

				: proccess문 내부의 신호 배정문( '<=' 로 시그널에 할당하는거 ) 은 proccess 문이 끝나야 실행된다
					: ex)
						process(A)		
							variable V1, V2 : integer
						begin
							V1 := A - V2;	--V1은 변수이므로 델타지연없이 T시점에 새로운 값을 가진다.
							Z <= -V1;	--Z는 시그널이기 때문에 현재값, 미래값을 동시에 가짐
							V2 := Z + V1 * 2;	--  process문이 끝나지 않았기 때문에 Z는 이전값이 반영됨

						end process;


	
			2. Data Flow Descrption 자료 흐름적 표현 
				: 부울 대수식을 이용하여 입출력 관계를 기술하는 설계방식
				: 논리회로에 대한 중간정도의 추상화 레벨
				: 문장 순서는 무관, 주로 병행처리문을 사용
				: 그러니까 함수 호출 없이 얌전하게 단순 문장으로만 써놓는거다
 

		(2) Structural Descrption 구조적 표현
			: 구성요소( Component) 및 구성요소간의 연결( port map 문 )까지 표현하는 설계방식
			: 동작적 표현보다 하드웨어 구조에 가까운 표현

			1. Component 문
				: 시스템의 구성 요소를 설계하는문
					: Component 는 클래스처럼 붕어빵틀 느낌임. (아래에 써놨지만) 실제로 사용할땐 instance 를 만들어 사용.
				
				: 선언위치 >>  architecture ~ begin 부분

				: 선언 형식
					component 컴포넌트명 is
						generic (파라미터명1 : 타입 ;
								. . .  
						파라미터명n : 타입 );
						port(
							형식포트명1: 모드 타입;
							형식포트명2 : 모드 타입;
							. . .
							형식포트명n : 모드 타입 ); 
						end component;
						
							: (generic의 )파라미터와 (port)형식포트명 >> 걍  파라미터
								: 실제로 Component 가 Entity 에 정의된 port 와 generic 을 사용한단 소리가 아니다.  실제로 사용하는 generic,  port 는 generic, port map 에서 정의한다


				:  Component Instantiation 컴포넌트 인스턴스화 >>generic map, port map 문 사용
					: 사실 component 는 약간 클래스 느낌이다. component 를 통해서 인스턴스를 여러개 생성 가능하고, 생성할때 사용되는 key word 가 port map( )  인거다
					: 생성 위치 >> Archtecture 의 begin ~ end 사이에 서술한다
						: 반복문이나 조건문에서 서술하는 것도 가능하다

					: 형식 >> 인스턴스명 : 대상컴포넌트명 generic map(어쩌구) port map( 어쩌구 ) ;
						: 인스턴스명은 생략이 가능하다. 근데 대부분 인스턴스명 지어준다
							: 인스턴스명을 쓰지 않아도 잘 실행되고, 인스턴스는 생성되면 띡 끝이지 생성이후 그 인스턴스명으로 또 뭔갈 하진 않는다. 하지만 디버깅적인 측면에서 장점이 있다고 한다
				
						: generic map 하는 방법 >>generic map(썡값1, 쌩값2 , ... )
							: component 에 generic 이 정의되어있는 경우만 generic map 을 명시하는거지, 무조건 쓰는건 아니다

						: port map( ) 하는 법 >>
							case1 : 위치 결합 positional association
								: (별도로 이름을 명시하지 않고) 형식포트명 순서대로 나열하는것
								: 형식 >> 인스턴스명 : 대상컴포넌트명 port map( 실제포트1, 실제포트2 , ... ) ;


							case2 : 이름 결합 named association
								: (형식포트명 순서와 상관 없이) 이름을 밝혀 결합하는 것
								: 형식 >> 인스턴스명 : 대상컴포넌트명 port map( 형식포트1=>실제포트1, 형식포트2=>실제포트2 , ... ) ;


			2. Generate 문
				: Component instance 의 반복적 생성 위해 사용
				: 주의 >> generate 문에서 라벨 부여는 필수 ( 라벨을 이용해 gerate 문 종료)

				(1) for-generate문 : 단순 반복 생성
					: 형식
						라벨명:for i in N downto M generate
						 	인스턴스명 : 대상컴포넌트명 port map( 실제포트1, 실제포트2 , ... ) ;
						end generate 라벨명;


				(2) if-generate문 : 조건 따라 반복 생성 
					: 형식
						라벨명1:for i in N downto M generate
							라벨명2:if 조건문 generate 
								인스턴스명 : 대상컴포넌트명 port map( 실제포트1, 실제포트2 , ... ) ;
							end generate 라벨명2;

							라벨명3:if 조건문 generate 
								인스턴스명 : 대상컴포넌트명 port map( 실제포트1, 실제포트2 , ... ) ;
							end generate 라벨명3;
						.
						.
						.

						end generate 라벨명1;



			3. Generic 문
				: Generic. 일반화. Generic의 파라미터를 Entity에 전달함으로써, 회로의 개수나 입출력의 크기가 매개변수에 의해 결정되게 하는 것 >> 코드 재활용 가능
				: Generic의 파라미터
					: 상수 객체 사용
					: 모드는 in 고정 <-- 따로 명시할 필요 없다
					: 사용용도
						1. 반복생성의 개수를 위한 파라미터상수
						2. 입출력의 크기를 위한 파라미터상수

				: 선언 위치 >>  Entity 선언부
				: 선언 형식 >> generic (파라미터명1 : 타입 ;
								. . .  
								파라미터명n : 타입 );

						: port 선언과 마찬가지로 마지막 파라미터명 문장 뒤에는 ';' 안붙이는거 주의

				: 사용은 component 객체 만들때 generic map 으로 하는 것 같다
				: https://dad-rock.tistory.com/447


------------------------------------------------------------------------------------------------------------

회로도 기호

	 MUX 멀티플렉서 〔| 
		: 제어선 따라서 여러 입력값 중 하나를 선택하여 출력값으로 내보낸다
		: m * n MUX == 입력이 m 개이고 출력이 n 개인 MUX
		: 실습 내역 >> 4bit mask
		: https://blog.naver.com/tb_elec_engineer/221033922130
		: https://dad-rock.tistory.com/420



https://community.element14.com/technologies/fpga-group/b/blog/posts/systemverilog-study-notes-rtl-combinational-circuit-operators

	: = >> 내부에 선언된 거 집어넣는다 , <= : 외부에 선언된 거 집어넣는다






----------------------------------------------------------------------------------------------------------

    Port ( X,Y,Z : in STD_LOGIC;
           F : out STD_LOGIC);
end gates;

architecture Behavioral of gates is
    signal f1,f2:STD_LOGIC;
begin
    or_gate:process(X,Y)
        begin 
            if X='1' or Y='1' then f1<='1';
            else f1<='0';
             end if;
    end process;
    
      nand_gate:process(Y,Z)
        begin 
        if(Y='0') or (Z='0') then f2 <='1';
        else f2 <= '0';
        end if;

    end process;  
    
    xor_gate : process(f1, f2)
    begin
    if(f1=f2) then F <='0';
    else F <= '1';
    end if;
    end process;


----------------------------------------------------------------------------------------------------------


architecture Behavioral of gates_tb is
    component gates
        Port ( X,Y,Z: in STD_LOGIC;
           F : out STD_LOGIC);
    end component;
    signal X,Y,Z : STD_LOGIC;
    signal  F :  STD_LOGIC;

begin
    uut : gates port map(X,Y,Z,F);
        stimulus: process

    begin
    
        wait for 100ns;
        X <= '0';
        Y <= '0';
        Z <= '0';


        wait for 100ns;
        X <= '0';
        Y <= '0';
        Z <= '1';



        wait for 100ns;
        X <= '0';
        Y <= '1';
        Z <= '0';

        
        wait for 100ns;
        X <= '0';
        Y <= '1';
        Z <= '1';
        
        
       wait for 100ns;
        X <= '1';
        Y <= '0';
        Z <= '0';
        
        
       wait for 100ns;
        X <= '1';
        Y <= '0';
        Z <= '1';


       wait for 100ns;
        X <= '1';
        Y <= '1';
        Z <= '0';
        

        wait for 100ns;
        X <= '1';
        Y <= '1';
        Z <= '1';
             
        wait for 100ns;




wait;
end process;
end;



----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------


entity gates is
    Port ( X,Y,Z : in STD_LOGIC;
           F : out STD_LOGIC);
end gates;

architecture Behavioral of gates is
    signal f1,f2:STD_LOGIC;
begin
    or_gate:process(X,Y)
        begin 
            if X='1' or Y='1' then f1<='1';
            else f1<='0';
             end if;
    end process;
    
      nand_gate:process(Y,Z)
        begin 
        if(Y='0') or (Z='0') then f2 <='1';
        else f2 <= '0';
        end if;

    end process;  
    
    xor_gate : process(f1, f2)
    begin
    if(f1=f2) then F <='0';
    else F <= '1';
    end if;
    end process;



end Behavioral;
----------------------------------------------------------------------------------------------------------
entity gates_tb is
--  Port ( );
end gates_tb;

architecture Behavioral of gates_tb is
    component gates
        Port ( X,Y,Z: in STD_LOGIC;
           F : out STD_LOGIC);
    end component;
    signal X,Y,Z : STD_LOGIC;
    signal  F :  STD_LOGIC;

begin
    uut : gates port map(X,Y,Z,F);
        stimulus: process

    begin
    
        wait for 100ns;
        X <= '0';
        Y <= '0';
        Z <= '0';


        wait for 100ns;
        X <= '0';
        Y <= '0';
        Z <= '1';



        wait for 100ns;
        X <= '0';
        Y <= '1';
        Z <= '0';

        
        wait for 100ns;
        X <= '0';
        Y <= '1';
        Z <= '1';
        
        
       wait for 100ns;
        X <= '1';
        Y <= '0';
        Z <= '0';
        
        
       wait for 100ns;
        X <= '1';
        Y <= '0';
        Z <= '1';


       wait for 100ns;
        X <= '1';
        Y <= '1';
        Z <= '0';
        

        wait for 100ns;
        X <= '1';
        Y <= '1';
        Z <= '1';
             
        wait for 100ns;




wait;
end process;
end;

----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------



entity mask_dg is
    Port ( input : in STD_LOGIC_VECTOR(3 downto 0);
           sel : in STD_LOGIC;
           F : out STD_LOGIC_VECTOR(3 downto 0));
end mask_dg;

architecture Behavioral of mask_dg is
constant mask0 : std_logic_vector := "0000"; -- off
constant mask1 : std_logic_vector := "1111";	--on

begin

process(sel, input)
begin
if (sel ='1') then
F <=  input and mask1;
else
F <= input and mask0;
end if;
end process;

end Behavioral;

----------------------------------------------------------------------------------------------------------


entity mask_tb is
end mask_tb;



architecture Behavioral of mask_tb is
    component mask_dg
        Port ( input : in STD_LOGIC_VECTOR(3 downto 0);
               sel : in STD_LOGIC;
               F : out STD_LOGIC_VECTOR(3 downto 0));
    end component;

    signal input: STD_LOGIC_VECTOR(3 downto 0);
    signal sel: STD_LOGIC;
    signal F: STD_LOGIC_VECTOR(3 downto 0);

begin

    uut: mask_dg port map (input=>input, sel=>sel, F=>F);

    stimulus: process
    begin
        wait for 100ns;
        input <= "0000";
        sel <= '1';

        wait for 100ns;
        input <= "0011";
        sel <= '1';

        wait for 100ns;
        input <= "0101";
        sel <= '1';

        wait for 100ns;
        input <= "1000";
        sel <= '1';
        wait;




