트리 : 나무 형태
	: 비선형 자료구조
	: 계층관계를 나타내는(== 자식과 부모의 관계로 이루어진) 자료구조
	: 나무가 거꾸로 들어진 꼴. 위쪽은 뿌리고 아래쪽은 리프임.

	: 노드
		: 각 지점. 
		: 각 노드는 자식 노드를 가리킬 2개의 포인터와 데이터를 가짐


	: 간선 . edge 
		: 두 노드를 연결하는데 사용. 길.

	: 부모 ) 간선으로 연결된 위쪽 노드
	: 자식 ) 간선으로 연결된 아래쪽 노드
	: 형제 ) 같은 부모를 가지는 노드

	: 루트
		: 트리의 시작
		: 최상위 노드
		: 루트가 가지는 자식의 개수에 따라 n 진 트리라고 한다
		: 2진 트리 >> 부모가 최대 2개의 자식을 가질 수 있는 트리

	: 서브 트리)  자식이 또 다른 자식을 가져 만들어진 작은 트리 형태

	: 리프 ) 더이상 자식이 없는 노드 . 말단(== 마지막 레벨) 노드.

	: 레벨
		: 루트에서  해당 노드까지의 경로에 있는 간선 수
		: 루트 레벨 == 0레벨
		: 노드 하나 거칠때마다 + 1 레벨

	: 차수 degree ) 노드가 갖는 자식 수

	: 높이 . 깊이 ) 루트부터 리프 까지 가장 긴 경로의 간선 수.



		
이진트리
	: 노드가 최대 2개의 자식(왼쪽 오른쪽)을 가질 수 있는 트리
	: 순서가 정의되어있지 않으므로 순서 없이 삽입 시 편향 이진 트리가 될 수 있다 >> 완전 이진 트리로 해결
	: n>=1 일 때
		: 레벨 n 에서 최대 노드 수 == 2*n << 레벨n 자체만 말하는거임 . n-1 층 이런거 포함 안하고.
		: 높이가 n 인 트리의 최대 노드 개수 == 2^(n+1) -1

	: n 개의 노드를 가지는 트리
		: 간선은 n-1 개
		: 높이는 log 2 n

	: 유형
		1. 완전 이진 트리 complete binary tree
			: 마지막 레벨을 제외한 모든 레벨은 노드가 가득 차있어야됨
			: 마지막 레벨은 왼쪽 ~ 오른쪽 방향으로 노드가 쭉 채워져야됨

		2. 정 이진 트리 full binary tree 	
			: 자식이 0 개 혹은 2개만 있는 트리. ( 1개는 불가)
			: 완전 이진 트리에 포함되지 않는다

		3. 포화 이진 트리 perfect binary tree
			: (leaf 노드를 제외한) 모든 노드가 2개의 자식 노드를 가짐
			: 모든 leaf 노드는 레벨이 같음 (== 마지막 레벨까지 꽉 채워져있음)
			: 완전 이진 트리 에 포함된다.


	: 이진 트리 순회 방법
		: 순회 >> 빠짐없이 방문하는 것.
		: 방식 
			: 부모를 언제 들르느냐 따라서 달라짐
			: 일단 항상 왼쪽 자식 이 오른쪽 자식 보단 먼저임

			1. 중위) 왼쪽 자식 --> 부모 -->  오른쪽 자식 
				: 왼쪽 자식 영역 먼저 처리하고, 루트 찍고 , 오른쪽 자식 영역 처리

				1. 일단 크게 루트 노드를 기준으로 왼쪽 자식, 오른쪽 자식을 구분지음

				2. 루트의 왼쪽 자식 영역 내에서 최외각 왼쪽 노드가 왼쪽 자식이 될때까지 영역 내의 최상위 노드를 기준으로 왼쪽 자식, 오른쪽 자식을 구분지음
				3. 최외각 왼쪽 자식 찍음
				4. 부모 찍고 그 왼쪽 자식의 오른쪽 형제 노드 찍으면서 루트 노드 까지 찍음

				5. 루트의 오른쪽 자식 영역내에서 최외각 왼쪽 노드가 왼쪽 자식이 될 떄 까지 왼쪽 자식, 오른쪽 자식을 구분 지음
				6. 최외각 왼쪽 자식 찍음
				7. 부모 찍고 그 왼쪽 자식의 오른쪽 형제 노드 찍으면서 오른쪽 자식 영역 내의 최상위 노드까지 찍음
				8. 남은 영역에서 영역 내의 최외각 왼쪽 자식이 없을 때까지 계속 이 짓(5~7)을 반복함
				9. 오른쪽 최외각 자식을 찍음



			2. 전위) 부모 --> 왼쪽자식 --> 오른쪽 자식
				: 루트 먼저 찍고 왼쪽 자식 영역 먼저 끝내고 오른쪽 자식 영역을 끝냄

				1. 일단 크게 루트 노드를 기준으로 왼쪽 자식, 오른쪽 자식을 구분지음

				2. 루트를 찍음

				3. 루트의 왼쪽 자식 영역 내에서 최외각 왼쪽 노드가 왼쪽 자식이 될때까지 영역 내의 최상위 노드를 기준으로 왼쪽 자식, 오른쪽 자식을 구분지음. 내려가는 길에 부모는 만나는 대로 바로 찍음
				4. 최외각 왼쪽 노드를 찍음
				5. 오른쪽 형제 노드 찍으면서 루트 노드까지 올라옴
			
				6. 오른쪽 자식 영역에서 최외각 왼쪽 노드를 왼쪽 자식 노드로 할 때 까지 왼쪽 자식, 오른쪽 자식을 구분 지음. 내려가는 길에 부모는 만나는 대로 바로 찍음
				7. 최외각 왼쪽 노드를 찍음
				8. 오른쪽 형제 노드 찍으면서 영역 내의 최상위 노드까지 올라옴
				9. 남은 영역에서 영역 내의 최외각 왼쪽 자식이 없을 때까지 계속 이 짓(6~8)을 반복함
				10. 오른쪽 최외각 자식을 찍음

 
			3. 후위) 왼쪽 자식 --> 오른쪽 자식 --> 부모
				: 왼쪽 자식 영역을 먼저 끝낸후 오른쪽 자식 영역을 끝내고 젤 마지막으로 루트를 찍음

				1. 일단 크게 루트 노드를 기준으로 왼쪽 자식, 오른쪽 자식을 구분지음
				2. 루트의 왼쪽 자식 영역 내에서 최외각 왼쪽 노드가 왼쪽 자식이 될때까지 영역 내의 최상위 노드를 기준으로 왼쪽 자식, 오른쪽 자식을 구분지음
				3. 최외각 왼쪽 자식 찍음
				4. 오른쪽 형제 자식 찍고, 부모 찍는 순으로 루트 바로 아래의 왼쪽 자식 까지 찍음

				5. 루트의 오른쪽 자식 영역 내에서 최외각 왼쪽 노드가 왼쪽 자식이 될때까지 왼쪽 자식, 오른쪽 자식을 구분지음
				6. 최외각 왼쪽 자식 찍음
				7. 오른쪽 형제 자식 찍고, 부모 찍는 순으로 오른쪽 자식 영역 내의 최상위 노드의 왼쪽 자식 까지 찍음
				8. 남은 영역에서 최외각 왼쪽 자식이 없을때까지 이짓(5~7)을 반복함
				9. 오른쪽 영역에서의 최상위 노드를 찍음
				
				10. 루트 노드를 찍음


재귀호출 reculsive
	: 함수 내에서 자기 자신을 호출하는 꼴의 함수
	: 함수는 호출 되면 메모리에 잡힌다. 그리고 해당 함수가 종료되면 메모리 상에서 삭제된다
	: 일단 재귀함수는 종료 조건이 매우 중요하다. 안그러면 무한 루프 돌게된다
	: 재귀함수의 작동 방식
		1. 재귀 함수는 종료되기 전까지 호출된 함수들은 메모리 상에 쌓인다
		2. 종료조건을 만족하는 경우 해당 함수는 더이상 또다른 함수를 호출하지 않고, 바로 이전(자신을 호출한. 역)함수 에게 값을 return 한다
		3. 함수들은 생성된 역순으로 종료되고(=최근에 호출된 순으로 return 하게 되고), 메모리 상에서 삭제된다
		4. 결론적으로 가장 먼저 호출된 함수가 가장 마지막에 return 되면서 재귀함수가 종료된다

	: 재귀호출하는 구문의 위쪽에 있는 코드와 아래쪽에 있는 코드는 수행되는 시점이 완전 다르다
		: 재귀호출 구문의 위쪽에 있는 코드는 함수가 호출될때 수행되는 구문이고, 재귀호출 구문의 아래쪽에 있는 코드는 함수가 종료되면서 수행되는 구문이다
	: 주의 ) 재귀호출되고 나서 차근차근 종료되는거지, 한번 종료 조건 만족해서 종료됬다고 바로 그 리턴값이 메인으로 오는게 아니다
	:재귀를 반복문으로 표현할 수 있다면 그렇게 하는게 좋다. 메모리 넘 잡아먹는다


<< 구현>>
BST Binary Search Tree 이진 검색 트리
: 부모 노드를 중심으로 왼쪽의 자식 노드 들은 부모 보다 다 작은 값, 오른쪽의 자식 노드 들은 부모보다 다 큰 값으로 구성되어있다
	: 중복된 값을 허용하지 않는다


: BST의 최솟값 >> 최외각 왼쪽 노드 (리프인지는 확신 불가)
: BST의 최댓값 >> 최외각 오른쪽 노드 (리프인지는 확신 불가)


: 검색 하는 법 
	: 일치하는 값 찾을떄까지 혹은 NULL 을 만날떄까지 search 
	1. 루트 노드와 입력값 비교 << 루트에서 값 일치 하는게 best 경우임
	2. 찾고자 하는 값이 루트노드보다 작다면 왼쪽, 크다면 오른쪽 노드로 이동
	3. 일치하는 값 찾을때까지 계속 왼쪽(현재노드보다 값이 작다면), 오른쪽(현재 노드보다 값이 크다면)으로 이동


: 원소 삽입 방법
	: NULL 값을 만날때까지 해당 노드보다 입력값이 더 작으면 왼쪽, 더 크면 오른쪽으로 이동


노드 삭제 방법 
	case1. 자식 노드가 없는 노드인 경우 == 왼쪽, 오른쪽 주소값이 모두 NULL 인 경우
		step1. 해당 노드를 걍 삭제
		step2. 해당 노드의 부모 노드의 포인터값을 NULL 값으로 업데이트

	case2. 왼쪽 혹은 오른쪽 자식 노드만 있는 노드인 경우
		: 무작정 해당 노드를 지워버리면 아래 자식 노드를 가리키는 노드가 없어 잃어버리기 때문에 이를 저장하는 임시 포인터 필요
		step1. 임시 변수로 자식 노드 주소 저장
		step2. 해당 노드 삭제
		step3. 해당 노드의 부모 포인터값을 임시 변수값으로 수정


	case3. 자식 노드가 둘 다 있는 노드인 경우 
		: 특이하게 해당 노드를 삭제하는게 아니다. 그 노드는 후손 노드의 값으로 업데이트만 시키고, 그 후손 노드를 삭제한다

		step1. 왼쪽 라인의 후손 노드 중 값이 가장 큰 노드를 찾는다
		step2. 그 후손 노드의 값으로 해당 노드의 값을 업데이트 한다 << 이렇게 되면 해당 노드의 왼쪽 자식들보다는 무조건 큰 값, 오른쪽 자식들 보다는 무조건 작은 값을 갖게 된다
		step3. 그 후손 노드를 삭제 한다
		step4. 삭제한 노드의 윗부분과 아랫 부분을 연결한다

트리에서 연결리스트의 head 와 같은 역할을 하는 포인터는 root 이고, 이 포인터가 최상위 노드를 가리키게 된다


오름차순 출력 방법 >> 중위 순회 하면 됨
중위 순회 >> 왼쪽 자식 - 부모 - 오른쪽 자식
-------------------------------------------------------------------------------------------------------------------------
힙 heap
	: 사용 이유 ) 루트에 최댓값이나 최솟값을 둠으로써 빠른 속도로 최대 or 최솟값을 찾음
	: complete binary tree (== 왼쪽~ 오른쪽으로 리프가 채워진 형태)로 구성되어야됨
		: BST 구현할떄와는 다르게 왼쪽 자식이 반드시 작은 값, 오른쪽 자식이 반드시 큰 값일 필요 없음. 부모가 두 자식 이상이거나(Max Heap 구현) 이하(Min Heap 구현) 이기만 함 됨
			: 자식과 부모값이 같아도 됨

	: heapify ) 자료를 힙 화 한다
	: 종류
		Max Heap : 루트에 최댓값을 둠
			: 부모 노드의 값이 자식 노드값 이상이다
			: heapify ) 
				1. 가장 밑으로 내려간다
				2. 자식들과 부모의 값을 비교하고, 부모가 가장 큰 값이 되게 swap 하며 올라온다
				3. 중간에 swap 하는 과정에서 밑 부분에서 자식이 부모보다 더 큰 값이 된 경우 또 다시 내려가서 swap 해준다
				4. 최종적으로 루트의 왼 오 자식 비교하여 루트 값을 결정한다

			: 원소 추가 )
				1. 일단 말단부에 (리프로써) (남는 가장 왼쪽 자리에)추가한다
				2. 위로 올라가면서 자식이 부모보다 더 크면 swap 해준다
				3. 중간에 swap 하는 과정에서 밑 부분에서 자식이 부모보다 더 큰 값이 된 경우 또 다시 내려가서 swap 해준다
				4. 최종적으로 루트의 왼 오 자식 비교하여 루트 값을 결정한다

			 : 원소 삭제 ) 루트 실제로 삭제되진 않고 가장 마지막 리프의 값으로 업데이트하고 해당 리프를 삭제한다
				1. 가장 마지막 리프(== 가장 오른쪽에 있는 리프) 의 값으로 루트 값을 업데이트한다
				2. 해당 리프를 삭제한다
				3. 아래로 내려가면서 자식이 부모보다 더 크면 swap 해준다
				4. 중간에 swap 하는 과정에서 밑 부분에서 자식이 부모보다 더 큰 값이 된 경우 또 다시 올라가서 swap 해준다
				5. 최종적으로 리프까지 결정한다
			
		Min Heap : 루트에 최솟값을 둠
			: 부모 노드의 값이 자식 노드값 이하이다


실질적으로 의미있는 값은 루트 밖에 없음

