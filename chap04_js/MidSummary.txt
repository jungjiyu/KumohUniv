구조적 프로그래밍 vs 절차지향 프로그래밍 언어 vs 객체 지향 프로그래밍 언어 vs 함수형 프로그래밍 언어
	: 구조적 프로그래밍
		: 기능을 중심적으로 개발하는 언어

	: 절차지향프로그래밍 언어
		: "순차적으로" 처리하는 언어
		: 함수만 있음

 	: 객체지향프로그래밍 언어
		: object 단위로 처리하는 언어
		: 추상화 캡슐화 상속성 다형성의 특징을 가짐
		: 함수와 객체가 있음
		: 클래스가 일급객체가 된다.
			: 일급 객체 >> 걍 일반적인 객체를 말하는 거임

	: 함수형 프로그래밍 언어, 비절차형 프로그래밍 언어
		: "순수 함수"를 사용하여 처리하는 언어. 	
			순수 함수 ) 동일 입력값에 대해 항상 동일 리턴값을 반환하며 외부 영향을 받지 않는 함수. 그러니까 side effect 가 없단 말.

		: 실행 순서를 지정할 필요가 없다
		: 함수 "자체" 가 일급 객체 가 된다.




스크립트 언어 : 이미 존재하는 소프트웨어를 제어하기 위한 용도로 사용되는 언어
	: 소스 코드를 컴파일(Compile)하지 않고도 실행할 수 있다.
	: 스크립트 언어 ⊂ 인터프리트 언어
https://velog.io/@jkijki12/%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8



자바스크립트
	: "동적인" 웹 페이지 작성을 위한 언어
		: 동적인 속성 변경. 이벤트에 반응하는 동작 구현. 콘텐츠 동적 변경. 상호 대화적인 콘텐츠 구현.
	: "모든" 웹 브라우져는 자바 스크립트를 지원
	: 점점 중요성이 커지고 있다
	: 자바스크립트 != 자바	
		: 공통점 >> 객체 지향을 지원한다.
		: 자바
			1. jvm 위에서 실행된다
			2. 컴파일 언어  : 번역 시간과 실행 시간이 별개이다.
			3. 객체 지향 언어
			4. 변수의 타입 선언 "반드시" 필요

		: 자바스크립트
			1. 브라우저 위에서 실행된다
			2. 인터프리터 언어. 스크립트 언어 : 번역과 실행이 동시에 일어난다.
			3. 구조적 프로그래밍, 함수형 프로그래밍, 객체지향 프로그래밍 , 객체 지향 프로그래밍 "기능"을 지원
				: 객체 지향 언어 != 자바 스크립트  
				: 함수 자체를 객체로 한다
				: 람다식도 지원한다

			4. 변수의 타입 선언 없어도 사용 가능

	: BOM  Browser Object Model 브라우저 객체 모델
		: 브라우져와 관련된 객체들의 집합
		: 최상위 객체 == window



	: DOM Doucument Object Model 문서 객체 모델
		: 웹페이지 (html , xml 문서 등)를 구조화 시켜 활용 가능한 객체(object) 형태로 만든 일종의 web api. 인터페이스.
	

		:  DOM ⊂ BOM
			: DOM 은 window 객체의 하위 객체 이다

		: tree 자료구조를 가진다. 계층적으로 표현된다.
			document 노드 : 최상위 "루트" 노드 
				: 해당 HTML 문서 전체를 나타내는 노드. 
					: html 문서 당 하나 씩 존재
				: document 객체를 가리킴. 
					:  주의) html 이 루트 "요소"라고는 하지만, DOM 에서 루트 노드는 아니다!
					: BOM 의 최상위 객체인 window 객체로도 접근 가능 (window.document)
				: element 노드를 자식 노드로 함

			element 노드 
				: 모든 html 요소( <html> 포함 )를 노드화 한 것.
				: attribute 노드, text 노드를 자식 노드로 함

			attribute 노드
			 
			text 노드 : 리프 노드 
				: html 문서 내의 텍스트를 노드 화 한 것



		:  JS "등"의  스크립팅 언어를 통해 조작 가능
			: 조작이 가능한거지, js 내에  DOM이 있는게 아니다
			: DOM 은 특정 프로그래밍 언어에 의존하지 않는 독립적인 인터페이스
			: js 에서는 "document " 객체를 통하여 DOM 에 접근, 사용 가능하다.

		: DOM 의 동적 생성과 정적 생성
			: 정적 생성 >> HTML 문서에 존재하는 태그를 노드로 생성하는 것. 
			: 동적 생성 >> 스크립팅 언어를 통해 HTML 문서에 없는 노드를 만드는 것.

		: https://www.codestates.com/blog/content/dom-javascript




: JS 삽입 위치가 렌더링에 주는 영향
	: 자바스크립트가 HTML 에 삽입되는 위치 
		(1) 인라인 자바스크립트
			: 대상 요소의 태그 내에 소스코드를 작성하는 방식
				: ' on이벤트명 '속성을 활용해 "자바스크립틈명령어" 를 할당하는 꼴로 사용
					ex) <button onClick="window.alert('jejejee');"> 버튼</button>

		(2) 내부 자바스크립트
			: 해당 HTML 문서의 <script> </script> 태그 내에 소스코드를 작성하는 방식
			: <head> 혹은 <body> 영역 에 작성 가능 

		(3) 외부 자바스크립트
			: HTML과 자바스크립트를 분리해서 외부 파일로 분리하는 방식
			:  해당 html 파일 내부에 <script src="파일명.js" ></script> 를 통해 가져온다.
			: 장점 
				1. 코드 재사용 
				2. 유지보수
			: <head> 혹은 <body> 영역 에 작성 가능 


	: 기본적인 HTML , CSS 렌더링 과정
		1. HTML 읽고 파싱(토큰화하여 parse tree 생성)하여 DOM tree 생성
		2. CSS 를 읽고 파싱하여 CSSOM tree 생성
		3. DOM 과 CSSOM 을 합쳐 Render tree 생성
		4. Render tree 를 기반으로 렌더링

	: JS 로 인한 영향
		: <head> 에 삽입한 경우 
			: parsing HTML --> fetching JS --> executing JS --> parsing HTML
			: HTML 파싱하다가 , 멈춘 후 js fetching 을 하고 excuting 이 완료 되면 , HTML 파싱을 재개한다
			: 문제점
				1. js 파일이 클 경우 파싱을 하다만 페이지를 사용자에게 오랫동안 보여주게 된다
				2. script 파일이 아직 파싱되지 않은 DOM 요소에 접근하여 문제가 발생할 수 있다

		: <body> 에 삽입할 경우 
			:  parsing HTML --> fetching JS --> executing JS
			: HTML 파싱을 먼저 진행 한 후 JS 파일을 다운로드 받고 실행
			: 장점 >> HTML 파싱이 완료된 페이지를 빠르게 볼 수 있다.
			: 담점 >>  js 에 의존적인 컨텐츠를 보는데에는 오래 걸린다.


	******: defer 속성과 함꼐 삽입할 경우 
			: parsing HTML & fetching JS --> executing JS  
			: HTML parising 과 fectcing 을 병렬로 하고, 이가 모두 끝나면 js 를 excute 하기 때문에 순서에도 문제가 발생하지 않고 비교적 빠르다

		: https://happytape.tistory.com/38.



JS 문법 기초
	: 문장 ) "브라우저"를 향한 "명령어"
		: 순차적으로 실행된다		
		: 세미콜론을 꼭 쓸 필욘 없지만 관습적으로 써준다

	: 변수 ) 데이터를 저장하는 상자
		: https://velog.io/@bathingape/JavaScript-var-let-const-%EC%B0%A8%EC%9D%B4%EC%A0%90
		: 변수 선언 방법
			sol0. const 로 선언 
				: 변하지 않는 변수
				: 변경이 불필요한 객체는 const 로 정의하는 게 좋다

			sol1 . let 으로 선언
				: 블럭 구조 지원

			sol2 . var 로 선언
				: 호이스팅
				: 오류 발생 가능성 높음

			sol3, 선언 없이 사용
				: 걍 쓰레기 아님?

		: 권장 방향 >> 일단 const 로 무조건 선언. 이게 안되는 경우 let 으로 선언해 사용

