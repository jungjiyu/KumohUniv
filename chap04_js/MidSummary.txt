구조적 프로그래밍 vs 절차지향 프로그래밍 언어 vs 객체 지향 프로그래밍 언어 vs 함수형 프로그래밍 언어
	: 구조적 프로그래밍
		: 기능을 중심적으로 개발하는 언어

	: 절차지향프로그래밍 언어
		: "순차적으로" 처리하는 언어
		: 함수만 있음

 	: 객체지향프로그래밍 언어
		: object 단위로 처리하는 언어
		: 추상화 캡슐화 상속성 다형성의 특징을 가짐
		: 함수와 객체가 있음
		: 클래스가 일급객체가 된다.
			: 일급 객체 >> 걍 일반적인 객체를 말하는 거임

	: 함수형 프로그래밍 언어, 비절차형 프로그래밍 언어
		: "순수 함수"를 사용하여 처리하는 언어. 	
			순수 함수 ) 동일 입력값에 대해 항상 동일 리턴값을 반환하며 외부 영향을 받지 않는 함수. 그러니까 side effect 가 없단 말.

		: 실행 순서를 지정할 필요가 없다
		: 함수 "자체" 가 일급 객체 가 된다.




스크립트 언어 : 이미 존재하는 소프트웨어를 제어하기 위한 용도로 사용되는 언어
	: 소스 코드를 컴파일(Compile)하지 않고도 실행할 수 있다.
	: 스크립트 언어 ⊂ 인터프리트 언어
https://velog.io/@jkijki12/%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8


전역 객체 
	: https://poiemaweb.com/js-global-object
	: 최상위 객체를 의미한다.
	: 성질
		: 전역 객체의 자식 객체를 사용할 때, 전역 객체는 생략 가능하다.  
			ex) document.getElementById( ); // window.getElementById( )  

		: 전역변수를 프로퍼티로 가진다.
			ex) 
				let a = 'AAA'; 
				console.log(a); // console.log(window.a);	

자바스크립트
	: "동적인" 웹 페이지 작성을 위한 언어
		: 동적인 속성 변경. 이벤트에 반응하는 동작 구현. 콘텐츠 동적 변경. 상호 대화적인 콘텐츠 구현.
	: "모든" 웹 브라우져는 자바 스크립트를 지원
	: 점점 중요성이 커지고 있다
	: 자바스크립트 != 자바	
		: 공통점 >> 객체 지향을 지원한다.
		: 자바
			1. jvm 위에서 실행된다
			2. 컴파일 언어  : 번역 시간과 실행 시간이 별개이다.
			3. 객체 지향 언어
			4. 변수의 타입 선언 "반드시" 필요

		: 자바스크립트
			1. 브라우저 위에서 실행된다
			2. 인터프리터 언어. 스크립트 언어 : 번역과 실행이 동시에 일어난다.
			3. 구조적 프로그래밍, 함수형 프로그래밍, 객체지향 프로그래밍 , 객체 지향 프로그래밍 "기능"을 지원
				: 객체 지향 언어 != 자바 스크립트  
				: 함수 자체를 객체로 한다
				: 람다식도 지원한다

			4. 변수의 타입 선언 없어도 사용 가능

	: BOM  Browser Object Model 브라우저 객체 모델
		: 브라우져와 관련된 객체들의 집합
		: 브라우저 환경에서의 최상위 객체,전역 객체 == window
			: 전역 객체 == 최상위 객체

	

	: DOM Doucument Object Model 문서 객체 모델
		: 웹페이지 (html , xml 문서 등)를 구조화 시켜 활용 가능한 객체(object) 형태로 만든 일종의 web api. 인터페이스.
	

		:  DOM ⊂ BOM
			: DOM 은 window 객체의 하위 객체 이다 

		: tree 자료구조를 가진다. 계층적으로 표현된다.
			document 노드 : 최상위 "루트" 노드 
				: 해당 HTML 문서 전체를 나타내는 노드. 
					: html 문서 당 하나 씩 존재
				: document 객체를 가리킴. 
					:  주의
						0. document 객체가 DOM tree 에서 최상위 노드이긴 하지만, 전역 객체인건 아니다. (전역 객체는 window 이다)
						1. html 이 루트 "요소"라고는 하지만, DOM 에서 루트 노드는 아니다!

					:  최상위 객체인 window 객체로도 접근 가능 (window.document)

				: element 노드를 자식 노드로 함

			element 노드 
				: 모든 html 요소( <html> 포함 )를 노드화 한 것.
				: attribute 노드, text 노드를 자식 노드로 함

			attribute 노드
			 
			text 노드 : 리프 노드 
				: html 문서 내의 텍스트를 노드 화 한 것



		:  JS "등"의  스크립팅 언어를 통해 조작 가능
			: 조작이 가능한거지, js 내에  DOM이 있는게 아니다
			: DOM 은 특정 프로그래밍 언어에 의존하지 않는 독립적인 인터페이스
			: js 에서는 "document " 객체를 통하여 DOM 에 접근, 사용 가능하다.
				: js 에서는 document 객체가 DOM tree 의 최상위 노드.

		: DOM 의 동적 생성과 정적 생성
			: 정적 생성 >> HTML 문서에 존재하는 태그를 노드로 생성하는 것. 
			: 동적 생성 >> 스크립팅 언어를 통해 HTML 문서에 없는 노드를 만드는 것.

		: https://www.codestates.com/blog/content/dom-javascript




: JS 삽입 위치가 렌더링에 주는 영향
	: 자바스크립트가 HTML 에 삽입되는 위치 
		(1) 인라인 자바스크립트
			: 대상 요소의 태그 내에 소스코드를 작성하는 방식
				: ' on이벤트명 '속성을 활용해 "자바스크립틈명령어" 를 할당하는 꼴로 사용
					ex) <button onClick="window.alert('jejejee');"> 버튼</button>

		(2) 내부 자바스크립트
			: 해당 HTML 문서의 <script> </script> 태그 내에 소스코드를 작성하는 방식
			: <head> 혹은 <body> 영역 에 작성 가능 

		(3) 외부 자바스크립트
			: HTML과 자바스크립트를 분리해서 외부 파일로 분리하는 방식
			:  해당 html 파일 내부에 <script src="파일명.js" ></script> 를 통해 가져온다.
			: 장점 
				1. 코드 재사용 
				2. 유지보수
			: <head> 혹은 <body> 영역 에 작성 가능 


	: 기본적인 HTML , CSS 렌더링 과정
		1. HTML 읽고 파싱(토큰화하여 parse tree 생성)하여 DOM tree 생성
		2. CSS 를 읽고 파싱하여 CSSOM tree 생성
		3. DOM 과 CSSOM 을 합쳐 Render tree 생성
		4. Render tree 를 기반으로 렌더링

	: JS 로 인한 영향
		: <head> 에 삽입한 경우 
			: parsing HTML --> fetching JS --> executing JS --> parsing HTML
			: HTML 파싱하다가 , 멈춘 후 js fetching 을 하고 excuting 이 완료 되면 , HTML 파싱을 재개한다
			: 문제점
				1. js 파일이 클 경우 파싱을 하다만 페이지를 사용자에게 오랫동안 보여주게 된다
				2. script 파일이 아직 파싱되지 않은 DOM 요소에 접근하여 문제가 발생할 수 있다

		: <body> 에 삽입할 경우 
			:  parsing HTML --> fetching JS --> executing JS
			: HTML 파싱을 먼저 진행 한 후 JS 파일을 다운로드 받고 실행
			: 장점 >> HTML 파싱이 완료된 페이지를 빠르게 볼 수 있다.
			: 담점 >>  js 에 의존적인 컨텐츠를 보는데에는 오래 걸린다.


	******: defer 속성과 함꼐 삽입할 경우 
			: parsing HTML & fetching JS --> executing JS  
			: HTML parising 과 fectcing 을 병렬로 하고, 이가 모두 끝나면 js 를 excute 하기 때문에 순서에도 문제가 발생하지 않고 비교적 빠르다

		: https://happytape.tistory.com/38.



JS 문법 기초
	: 문장 ) "브라우저"를 향한 "명령어"
		: 순차적으로 실행된다		
		: 세미콜론을 꼭 쓸 필욘 없지만 관습적으로 써준다

	: 블록 ) { } 로 묶인 뭉치

	: 주석문 ) // 혹은 /* */



	: 데이터 타입 NNOSUB
		: 주의 >> NaN Not a Number 은 하나의 자료형이 아니고,  Number 자료형에 속한다.
			:https://www.codeit.kr/community/questions/UXVlc3Rpb246NjA2ZDIzZmJjNDMwYmU2NTVlNGJkZWJk

		(1) Number : 숫자 
			: 정수 혹은 실수 혹은 NaN
				: NaN Not a Number 
					: 숫자가 아님을 나타내는 특별한 값
					: NaN 값을 확인하는 법
						: NaN 은 어떤 값과도 동등 하지 않아 NaN == NaN 혹은 NaN == NaN 하면 false 나온다. 따라서 isNaN( ) 이라는 별개의 함수를 사용하여 확인해야한다.
							ex) 
							 NaN == NaN // false
							 isNaN(NaN)  // true
							 isNaN(123)  // false
							 isNaN("Hello") // true
						

		(2) Object : 객체
			: 객체 == 사물의 속성과 동작을 묶어서 표현하는 기법
			: js 에서는 클래스 없이도 생성 가능
			: js 에서는 원래 객체라는 개념이 없지만, '딕셔너리' 를 이용하여 객체 기능을 지원한다.
			
		(3) String : 문자열
			: 줄바꿈을 표현하는 방법
				1. 웹 페이지 상 >> 문자열에 <br> 표기
				2. 콘솔 상 >> 문자열에 \n 표기

			: " 와 ' 의 구분 없음 but 백틱( ` ) 은 다름 주의
				: 일반적인 문장은 ' , " , ` 으로 모두 표현 가능하지만, 백틱의 기능을 사용하기 위해선 반드시 백틱으로 표현해야된다.
				: 백틱 `
					: 기능
						1. ${ } 를 사용해 문자열 중간에 변수 삽입을 간편하게 할 수 있게 해준다.
							: 꼭 백틱 안쓰고 + 연산자를 통해 문자열 중간에 변수 삽입을 할 수 있긴 하지만 번거로우니까..	
						2. 코드상 백틱 내에 줄바꿈이 있으면 "콘솔" 상에서 실제로 줄바꿈이 일어나게 한다.
							: \n을 사용할 필요가 없다.


		(4) Undifined : 타입이 정해지지 않았음을 의미하는 값. 
			: 값 할당이 안됬을 때의 값

		(5) null : 주소값이 정해지지 않음

		(6) Boolean : true 혹은 false


	: 리터럴 ) 값 그 자체. .

	: 변수 ) 데이터를 저장하는 상자
		: https://velog.io/@wlwl99/%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8-%EC%B4%88%EA%B8%B0%ED%99%94-%ED%95%A0%EB%8B%B9-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85
		: https://velog.io/@bathingape/JavaScript-var-let-const-%EC%B0%A8%EC%9D%B4%EC%A0%90
		

		: 변수의 단계 ) 선언 단계 > 초기화 단계 > 할당 단계
			: 초기화 단계 ) 자동으로 undifined 값을 부여 , 메모리공간을 확보하는것
			: 할당 단계 ) 실제 값을 부여

		: 호이스팅
			: 선언문을 선두로 옮긴 것 처럼 동작하는 특성. 그러니까 선언문이 뒤에있어도, 그 앞에서 쓸 수 있단 말이다.

		: scope ) 식별자 의 유효 범위.
			: 전역변수 >> 전역 스코프 가져 모든 곳에서 참조될 수 있음
			: 지역변수 >> 지역 스코프 가져 해당 지역 및 하위 지역에서만 참조 가능

		: 변수 선언 방법
			sol0. const 로 선언 
				: 변수 재선언 불가
				: immutable 하다 (변수에 값 재할당 불가)
				: 선언단계와 초기화단계와 할당단계 동시에 이뤄진다.
					: 선언과 함께 초기화 값을 주지 않으면, 에러가 난다.

			sol1 . let 으로 선언
				: mutable 하다 (변수에 값 재할당 가능)
				: 변수 재선언 불가
				: 선언단계와 초기화 단계가 분리되어 실행된다.
					: 초기화는(undfined 부여) 실제 코드에 도달했을 떄 이뤄진다.
					: 할당도 실제 코드에 도달했을 때 이뤄진다.
					: 초기화 되지 않은 변수가 호이스팅 되는거라, 변수 선언문 이전에 해당 변수의 참조를 하면 에러가 난다.
						: 참고로 변수 선언 과 초기화 사이엔 해당 let 변수는 TDZ Temporal Dead Zone 사각지대에 있어서, 못찾게 된다고 한다.
				
			sol2 . var 로 선언
				: 단점 >> 변수를 여러번 재선언 가능
				: 선언단계와 초기화단계가 동시에 실행된다.
					: 초기화된 변수가 호이스팅 되는거라  변수 선언문 이전 위치에서도 해당 변수의 참조가 가능하다

			sol3, 선언 없이 사용
				: 걍 쓰레기 아님?

		: 권장 방향 >> 변수 선언엔 기본적으로 const 를 사용하고, 재할당이 필요한 경우에만 let 을 사용한다. const 의 사용을 적극 권장하는 것은 의도치 않은 재할당을 방지해주기 떄문.



	연산자
		(1) 산술 연산자  + - * / % 
			: 몫 연산자 빼고 모두 지원 (몫 연산자는 파이썬 빼고 다 없다)
		(2) 증감 연산자 ++  -- 
		(3) 문자열 연산자 + 
			: 왼쪽부터 오른쪽으로 차례대로 더해진다.
				:  "교환법칙" 성립 안함. 그러니까 피연산자 순서 따라 문자열의 결과가 달라질 수 있다.
					document.write( '1==1 : '+ 1 == 1 )  ; // false
					document.write( '1==1 : '+ (1 == 1) )  ; // 1==1 : true

		(4) 비교 연산자  ==, ===,   != ,  > , < , >= , <= 
			: == 와 === 
				: === 를 써야하는 이유 >> 프로그래머의 혼란 방지 차원

				== equal operator 비교연산자
					: 맥락상 값이 같으면 모두 true 를 리턴한다 
						'100' == 100 // true
						'1' == true // true
						'true' == true // true
						null == undifined // true		

						: 예외 >> 객체와 NaN
							: 객체는 메모리 주소를 참조해서 그렇다.
							let a = [ 1 , 2 , 3] ; let b = [1, 2 , 3];
						 	a == b // false
							NaN == NaN // false


				=== STRICT equal operator 엄격한 비교 연산자
					: 자료형과 값이 모두 일치해야 true 를 리턴한다
						NaN === NaN // false

						'100' === 100 // false
						'1' === true // false

			: != 와 !==
				!= 
					: 자료형과 값 둘 중 모두 다르면(맥락상 다르면) true 를 리턴한다
 
				!==
					: 자료형과 값 둘 중 하나라도 다르면 true 를 리턴한다


		(5) 논리 연산자 && , || , !
			



	this
		this 에 바인딩 되는 값
			(1) 전역 공간의 this >> 전역 객체( == window 객체)
			(2) 메서드 내부의 this >> 해당 메서드를 호출한 객체
			(3) (화살표함수 제외)함수 내부의 this >> 전역객체( == window 객체)
				: 함수 내부의 this 는 존재하긴하지만, 값이 "지정"되지 않는다. this 가 지정되지 않은 경우 this 는 자동으로 전역 객체를 바라보기 때문에, 결국 함수 내부의 this는 전역 객체가 된다.

			(4) 화살표 함수 내부의 this >> 상위 scope 에서의 this 를 참조한다.
				: 화살표 함수 내부엔 this 가 "아예" 없다. js 에서는  현재 scope 에 해당 식별자가없으면 상위 scope 로 올라가서 찾는데, 그와 같은 원리이다.


		: https://velog.io/@padoling/JavaScript-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98%EC%99%80-this-%EB%B0%94%EC%9D%B8%EB%94%A9



	유명한 함수
		window.prompt( "라벨" , "입력필드에디폴트로표시할값" ) 
			: 라벨과 입력 필드가 있는 알림창을 띄워준다
			: 리턴값 >> 입력 필드에 입력한 내용을 "문자열" 타입으로 리턴
				: 입력 받은 값으로 숫자 연산을 하고 싶으면 parseInt( ) 처리는 필수다.
			: 암기 tip >> 뭔가 티키타카가 있다. 프롬프트.

		window.confirm( "라벨 ")
			: 라벨만 있는 알림창을 띄워준다
			: 리턴값 >> 알림창에서 사용자가 '확인' 버튼을 눌렀으면 true, '취소' 버튼 눌렀으면 false 를 반환한다.
			: 암기 tip >> 일방적인 통보. confirm.

		document.write( " html 형식의 문자열" ) 
			: 요약 >> 페이지 로드를 마치기 이전에 읽힌 docuemnt.wirte 는 해당 HTML 페이지에, 페이지 로드를 완료한 이후 읽힌 document.write 는 새로운 HTML 페이지에 해당 내용을 추가한다.
				: 페이지 로드 될 때 명시된 document.write(  ) 는 arg 를 해당 HTML 문서 내부에 주입한다
					: f12 눌러서 확인해보면 실제로 wirte한 내용이 html 소스상에 추가되었음을 볼 수 있다
					: <script /> 읽히는 시점에 js 가 fetch, excute 되고, 그떄 wirte( ) 도 실행되는 것이라 <script> 가 <head> 부분에 있으면 wirte( ) 내용은 해당 페이지의 가장 윗부분에 추가되고, <body> 의 가장 끝 부분에 있으면 해당 페이지의 가장 아랫 부분에 추가된다.

				: 페이지가 다 로드된( js fetch, excute 까지 다 된) 후에 document.write( ) 하면,  기존 HTML 문서를 다 밀어버리고 arg 내용으로 덮는다. (그래서 이름이 append 이런게 아니라 write( ) 인가보다 )
				: https://we-always-fight-with-code.tistory.com/39
				: https://ko.javascript.info/modifying-document

			: HTML 에 포함될 내용을 쓰는 것이라 '\n' 은 안먹히고 <br> 이 먹힌다




		console.log( " 콘솔에 출력할 내용") 
			: 주로 디버깅 용도로 많이 쓴다.


	함수 
		: 전역 변수와 지역 변수
			: 전역 변수 == 함수 외부에서 선언된 변수
			: 지역 변수 == 함수 내부에서 선언된 변수

		: 함수의 정의 방식
			(1) 함수 선언문
				: !! 반환형은 명시하지 않는다
				: function 키워드와 함수명 명시 필요
				: 호이스팅 된다

			function 함수명( 매개변수1, 매개변수2 .. ){
				. . .
				return 어쩌구;
			}
		
			(2) 익명함수
				: 변수에 함수 선언문을 할당해 사용하는 것
					: function 키워드는 필수,  함수명은 명시 불필요 
					: 변수의 호이스팅 규칙을 따른다
					: 자바의 람다식과 비슷.

				: 주의  >> 함수명은 생략 해도 (  )는 필수로 써줘야됨

				변수명 = funcition ( 매개변수1, 매개변수2 .. ){
					. . .
					return 어쩌구;
				}


			(3) 화살표 함수
				: 익명 함수 선언을 더 간단화 한 것
				: 특징/주의
					1. 변수의 호이스팅 규칙을 따른다
					2. 무조건 익명함수로만 사용가능하다
					3. 메서드나 생성자 함수로 사용 불가
				
				: 기본 형식 
					: 화살표 함수도 하나의 할당 문이므로 끝에 ; 명시 잊지 말자

					변수명 = (매개변수1, 매개변수2,  . . ) => {  
							
							. . .
							return 어쩌구; };
			
			
 
				: 표현 방법
					1. 매개변수  ( , .. , )
						(1) 매개변수가 하나만 있는 경우 : 소괄호 표시 생략 가능
						(2) 그 이외의 경우 : 소괄호 표시 필수

					2. 함수 몸체 { ... }
						(1) 문장이 리턴문만 있으면 되는 경우 
							: return 키워드를 생략 가능한데, 생략할꺼면 중괄호도 필수적으로 생략해야됨

						(2) 그 외의 경우
							: return 키워드와 중괄호를 필수적으로 사용 필요				 
				


			
	HTML 요소에서 정보 뽑기		
		: HTML 요소를 구하는 법	
			(1) document. getElementById( '아이디' );
 				:  Id 를 이용하여  접근
				: 주의 >> '아이디' 혹은 "아이디" 로 써야된다. 안그럼 변수가 되잖아.

		: 구한 객체에서 정보 뽑고, 변경하는 법 >> 변수명.속성명	
			: 주의 >> 변수.value 는 항상 String 타입을 반환한다. 
				: 숫자 계산을 원하면 parseInt 필수다.
			ex) 
			// 요소 얻어옴
				let x = document.getElementById(아이디); 
				let y = document.getElementById(아이디);
				let z = document.getElementById(아이디);

			// 정보 뽑음
				let a = x.value;
				 let b = y.value;

			// 정보 수정
				z.value=a+b;


	제어문 >> 자바와 ㅈㄴ 똑같다
		: 조건문 
			(1) if ... else if ... else 문
			(2) switch 문

		: 반복문
			: break >> 가장 가까운 '루프'를 탈출
			: continue >> 해당 반복의 나머지 부분을 건너뛰고 다음 반복으로 넘어감.
			(1) for문
				: 루프제어 변수는 되도록 for문 안에 적는다. 
					1. 번잡스럽다
					2. 변수의 사용 범위를 for 문 내부로 제한하기 위해
					: http://www.soen.kr/book/java/book/513.htm
			(2) while 문
			(3) do-while 문 << 끝에 ; 빼먹지 않기 !

	
		
