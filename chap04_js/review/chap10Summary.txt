속성과 프로퍼티 정리
	: https://ko.javascript.info/dom-attributes-and-properties
	: DOM >> html 을 자바스크립트 객체로 표현한 문서 모델
		: DOM 트리의 노드는 자바스크립트에서의 객체이다

	: Attribute >> html 의 속성
		: ex ) <div class='my-class' style="color: red;"></div> 에서 class 와 style
	****** 주의 >> 태그 내의 인라인으로 정의된 것들에 한해서만 해당 요소의 attribute로 간주된다
			: 아무리 표준 attribute라고 할 지라도 해당 태그에 인라인으로 명시되지 않았으면 js코드에서 "해당객체.프로퍼티명" 을 해도 빈 문자열만 나온다 (에러가 나진 않는다) >> 따라서 인라인으로 명시된 style 이 아닌 경우 js 코드에서 "해당객체.style.스타일규칙명" 을 했을때 빈문자열만 나온다.
				: 그럼에도 불구하고 브라우저화면상엔 해당 스타일규칙이 잘 적용이 되는 것은, 외부에 선언된 스타일을 참조하여 브라우저에 그려지는 것이지, 실제로 DOM 영역의 해당 노드들에게 속성으로 적용하는 것이 아니기 때문이다. 
			: https://helloinyong.tistory.com/284

		: 정적이다 
			: 만약 property뿐 아니라 attribute까지 수정하고 싶으면 js 코드 상에서 setAttribute 를 사용하면된다
			ex ) 유저가 체크박스에 체크를 하면 >>  attribute 의 상태는 변하지 않는다. f12 개발자 툴의 html 소스 코드는 변하지 않는다.

		: 대소문자를 구분하지 않는다
		: 값은 대부분 문자열이다

		: attribute 의 종류
			(1) 표준 >> 기본적으로 정의되어있는 html 속성 
				: 표준 속성이라고 해서 모든 요소가 해당 속성을 가지진 않는다
					ex ) input 태그의 type 속성은 표준이지만, div 태그에 type 속성이 존재하진 않는다
			(2) 비표준 >> 사용자가 직접 만든 html 속성 
				: 몰랐는데, 태그에 아무문자열 쓰면, 그 문자열은 사용자 정의 속성이 된다

		: 표준 Attribute 의 경우 "대부분" dom 의 property 로 등록되어있다
			: 이름에 '-' 가 들어가는 Attribute 명에 대응되는 property명은 대부분 Camel case 가 적용된다
				: 특수한 프로퍼티명)  class 속성의 경우 property 명이 className 이다
			: 자바스크립트 코드상에선 표준 Attribute 대해 " 해당요소객체명.프로퍼티명 " 으로 해당 attribute 로의 접근 및 사용이 가능하다

		: 비표준 html attribute 는 dom의 내장 property도, 사용자정의 property도 아니다.
			: 비표준 attribute 의 경우 자바스크립트 코드 상에선 아래의 함수로 접근 및 조작이 가능하다
				: 내부 arg 로 들어가는 속성명은 대소문자를 구분하지 않아도 된다
			******: 이 함수들은 비표준 속성이 아니더라도, HTML attribute 와 DOM property 의 동기화를 하기 위해서 사용할 수도 있다
				1. 대상객체.hasAttribute( '속성명' ) : 대상객체에 해당 속성이 있는지 확인
				2. 대상객체.getAttibute( '속성명' ) : 대상객체에서 해당 속성값을 가져옴
				3. 대상객체.setAttribute( '속성명', 속성값 ): 대상객체에 해당 속성의 값을 설정한다
				4. 대상객체.removeAttribute( '속성명' ) : 대상객체에허 해당 속성을 삭제한다
	

	: Property >> dom 의 속성
		: ex )  document.querySelector('div').className; 에서 className
		: 동적이다. 
			: ex ) 유저가 체크박스에 체크를 하면 >> property 의 상태는 checked 로 변한다.  값의 변경 이후 console 에 해당 프로퍼티의 값을 찍어보면 실제로 바뀐 값이 찍힌다
		: 대소문자를 구별한다
		: 값으로는 다양한 타입의 값을 가질 수 있다
		: property 의 종류
			(1) 내장 >> html 의 표준 attribute에 대해서는 해당요소객체명.프로퍼티명 으로 직방 접근이 및 사용이 가능하다

			(2) 사용자 정의 
				:  해당 객체를 대상으로 , 존재하지않는 프로퍼티명에 값을 할당하면 해당 프로퍼티가 해당 객체에 생성된다
				ex ) 
				document.body.sayTagName = function() {
  				alert(this.tagName);
				};

				document.body.sayTagName();


			******: 개꿀팁 >> " 어떤객체.새로운프로퍼티명" 이 아닌,  "어떤객체.prototype.새로운프로퍼티명" 을 사용하여 새로운 값을 할당하는 경우, 내방프로토타입을 수정시키는거라 해당 객체에서뿐아니라 다른 객체에서도 해당프로퍼티의 사용이 가능해진다
					: https://www.nextree.co.kr/p7323/




html 의 style 과 js 의 style 의 주의할 점
	: https://helloinyong.tistory.com/284
	: 인라인으로 직접적으로 명시된 style 규칙에 한해서만, js에서 style 객체의 property 로써 접근했을때 값이 (문자열의 형태로) 제대로 나온다. style 태그나 , 아예 바깥 css 파일에서 적용된 style 규칙의 경우 style 객체의 프로퍼티로 접근했을때 빈문자열만 나온다.

-----------------------------------------------------------------------------------------------------------

JS 의 함수와 메서드 주의 >> 객체 내부에서 선언된 함수라고 해서 다 메서드인게 아니라, 직접적으로 객체 내부에서 선언된 함수만 메서드이다
	: 메서드의 내부에서 선언된 함수는 메서드가 아니라 걍 함수이다.

-----------------------------------------------------------------------------------------------------------

생성자 함수 constructor 
	: 일반적인 function 을 호출할 떄 new 키워드 앞에 붙이고 호출하면 그 함수는 생성자 함수 취급된다.	
	: 생성자 함수는 되도록 첫 글자를 대문자로.

	function Person(name) { this.name = name; }
	var me = new Person('Lee'); // Person은 생성자 함수
	console.log(me); // Person&nbsp;{name: "Lee"}

-----------------------------------------------------------------------------------------------------------


JS 의 this 바인딩 정리
	(0) this가 지정되지 않은 경우, this는 자동으로 전역 객체를 바라본다
	(1) 전역 공간의 this : 전역 객체	
	(2) function 으로 선언된 함수 내부의 this : 해당 함수가 메서드냐 아니냐 따라 동적 바인딩 된다.
		1. 메소드 내부의 this >>  해당 메소드를 호출한 ( 해당 메서드가 속한 ) 객체		 
		2. 메서드가 아닌 함수 내부의 this 
			: function 키워드로 선언된 익명 함수도 이 케이스에 해당한다
			(1) 이벤트 리스너의 콜백 함수로 사용되는 경우 >> addEventListener 을 적용시킨 객체에 바인딩된다
			(2) 이벤트 리스너의 콜백 함수로 사용되는게 아닌 경우 >>  this 가 지정되지 않기 떄문에  (0) 에 의해 자동적으로 전역 객체를 가리키게된다.

	
	(4) 화살표 함수 내부의 this : 선언 시점에 상위 스코프가 this 로 바인딩된다.
		: 화살표 함수에는 this 가 아예 없어서 가능한 것
			: function으로 선언된, 메서드가 아닌 함수의 경우 this가 존재하긴 하지만 값이 지정되지 않기 때문에 전역 객체를 가리키게 되는건데 , 화살표 함수로 선언한 함수에는 this가 아예 없다.
			: JavaScript에서는 어떤 식별자를 찾을 때 현재 scope에 그 변수가 없으면 , 변수를 찾거나 가장 상위 환경에 도달 할 때까지 가까운 상위 환경 순으로 탐색한다. 화살표 함수에서의 this 바인딩 방식도 이와 마찬가지로,  화살표 함수에는 this라는 변수 자체가 존재하지 않기 때문에 그 상위 환경에서의 this를 참조하게 되는거다.
		: 주의 >> "해당 함수를 호출한" 객체를 가리키는게 아니라(동적바인딩이 아니라) , 선언 시점의 상위 스코프 객체를 가리키게되는거다
		: 일반 함수가 아닌 화살표 함수를 활용하면 좋은 경우 >>  함수 내부에서 해당 함수가 간접적으로 속한 객체를 this 를 이용해서 참조하고 싶을 때.
		: 화살표 함수를 활용하면 안되는 경우 >>  addEventListener 의 콜백함수인데 내부적으로 this 를 포함하는 경우
			: 화살표 함수가 아닌 function 으로 선언된 함수의 경우 addEventListner 이 적용된 객체를 this 에 바인딩 시키지만, 화살표는 여전히 상위 scope 객체를 가리켜 착각의 여지가 있다
		button.addEventListener('click', () => {
 			 console.log(this);	// Window
  			this.innerHTML = 'clicked';
			});


	: https://developer-talk.tistory.com/884
	: https://velog.io/@padoling/JavaScript-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98%EC%99%80-this-%EB%B0%94%EC%9D%B8%EB%94%A9






-----------------------------------------------------------------------------------------------------------


이벤트 : 상호작용이 발생하는 것

이벤트타입명 != 이벤트속성명
	: 이벤트속성은 onXXXX 꼴이고, 이벤트타입은 on 을 제외한 XXXX 부분이다.
		: 이벤트 속성은 
			인라인에선 >> 태그 내부의 속성명  	
				ex )  <div onclick="alert('클릭했습니다1.')">클릭</div>

			스크립트문에선 >> 대상 객체의 속성명  
				ex )  객체.onclick =  function view() { alert("클릭했습니다!!!"); }


		: 이벤트 타입은 addEventListener 혹은 removeEventListener 에서 arg 로 대입된다
			
	

	: 이벤트 타입 종류
	(1) 마우스 관련
		1.  mouseover 과  mouseout
			: 이벤트 발생 시 버블링이 일어난다
			: preventDefault 메서드를 호출하여 이벤트의 기본 동작을 취소할 수 있다
			: https://velog.io/@commi1106/MouseOver%EC%99%80-MouseEnter%EC%9D%98-%EC%B0%A8%EC%9D%B4-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B2%84%EB%B8%94%EB%A7%81
				: 그러니까  mouseOver/mouseOut과 mouseEnter/mouseLeave 의 차이점은 
					(1) 이벤트 전파 여부
					(2) 취소 가능
					(3) 이건 사실인지 모르겠는데 mouseEnter/mouseLeave 은 explorer 전용이라고 한다

			(1) mouseover : 마우스가 영역내에 위치
			(2) mouseout : 마우스가 영역을 벗어남

		0. mouseenter 와 mouseLeave
			: 이벤트 발생시 버블링이 일어나지 않는다  
			: preventDefault 메서드를 호출하여 이벤트의 기본 동작을 취소할 수 "없다"
			(1) mouseenter : 마우스가 영역내에 위치
			(2) mouseLeave : 마우스가 영역을 벗어남

		4. mousedown :  마우스를 클릭하고 떼지않은 상태
		5. mouseup : 마우스를 똄
		1. click  : 마우스 버튼을 누르고 + 떼는 동작이 모두 완료된 후에 발생
		******: 그러니까 순서 >> mousedown -> mouseup -> click
		6. mousemove : 마우스를 움직임
			 
	(0) 마우스 휠 관련 
		: : wheel 이벤트와 scroll 이벤트는 다른거 주의
		1. wheel : 마우스 휠을 움직임임을 감지
			: mousewheel 이란 이벤트도 있는데 그건 비표준이고, wheel 을 보통 사용한다
			: https://m.blog.naver.com/a_ugust/221982749023

	(2) 키보드 관련	
		1. keydown : 사용자가 키를 눌렀을떄
		2. keyup : 사용자가 누른 키 뗏을 때

	(3) form 관련
		: https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%ED%8F%AC%EC%BB%A4%EC%8A%A4-%EC%A0%9C%EC%96%B4-focus-blur


		0. focus  : 입력요소가 포커스를 받을 때. 해당 필드에 입력을 시도할 때 (아직 누른건 아님)
			: 그러니까 입력 필드 클릭하고 입력하라고 깜빡깜빡이는 시점에 발생한다
			: 버블링 일어나지 않는다

		1. focusin : focus 와 같은 기능을 하는데 버블링을 곁들인...

	******2. blur  : 입력요소가 포커스를 잃었을떄
			: 그러니까 입력 필드를 클릭해서 포커스를 줬었다가, 외부 영역을 클릭해서 해당 영역이 깜빡이는게 멈추게 되면 발생한다
		******: 그러니까 focus 이벤트가 선행된 경우에만 발생할 수 있는거다
			: 버블링이 일어나지 않는다

		3. focusout : blur 와 같은 기능을 하는데 버블링을 곁들인...

		4. submit  : 사용자가 입력 양식을 제출할떄
		5. change : 사용자가 입력 요소의 값을 변경할때

	(4) 페이지로딩관련
		: https://velog.io/@qwe8851/DOM-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC-load-%EC%9D%B4%EB%B2%A4%ED%8A%B8
		0. loadeddata : 비디오나 오디오가 다 로드된 후 발생한다.
		1. load : 문서(이미지)나 전체 페이지가 완전히 다 로드되었을 때 발생하는 이벤트 	
			: 주의 >> 비디오와 오디오에 대해서는 load 이벤트가 발생하지 않고, loadeddata 이벤트가 발생한다.
			: https://blog.naver.com/sgj4958/222022912143
			: load 이벤트 발생 가능 대상 >> window 객체와 img 요소 
			: 주의 >> 전체 페이지 다 로딩 시( DOM 트리 완성 뿐 아니라, 이미지 와 스타일 시트 같은 외부 자원도 모두 불러오는 것이 끝났을 때) load 이벤트가 발생되는건,  window 객체를 대상으로 사용했을때만 그런거다. 
				: 만약 특정 img 태그 요소를 대상으로 적용하면 해당 이미지가 다 로드 되었을떄 load 이벤트가 발생한다
				: 특정 객체에 적용할 경우, 해당 객체의 하위 요소들까지 모두 load 됬을때 load 이벤트가 발생한다
			: 필요한 이유 
				: 특정 html 요소를 사용하는 코드를 내포한 script 태그를 해당 html 요소가 선언된 위치보다 더 앞에서 선언하면 ( 랜더링 자체는 최종적으로 잘 되긴 하는데 ) 콘솔 창 보면 Uncaught TypeError 라고 뜬다. ( 이는 브라우저가 html 문서를 파싱하여 dom 트리를 구성할 때, 위에서부터 차례대로 읽어들이는데, 읽는 중간에 scirpt 문을 만나면 해당 script 문을 바로 fetch 및 실행시키기게 되고, script 코드 상에 포함된 객체를 DOM 트리에서 읽어오게 되는데, 아직 해당 객체가 DOM 트리에 존재하지 않아 UncaughtError 가 발생하게되는것이다 ) 
				ex ) 
   				 <body>
      				  <script>
       				     let a = document.getElementById('name');
         				   a.style.color = "blue"
        				</script>
      				  <p id="name">hello</p>
    				</body>

 
		2. beforeunload : 사용자가 페이지를 떠나려 할 때, 즉 x 버튼을 눌러서 나가겠다는 의사표시를 하는 경우 발생됨
			: x 버튼 눌렀을 때 alert "창으로 나가시겠습니까??" 이런 메시지 주려는 경우 beforeunload 를 사용하면된다
			: window 객체에서 발생 가능한 이벤트
			: 바인딩되는 이벤트 핸들러의 조건	
				: 결과적으로는 사용자가 페이지 나가기를 시도 할 때 해당 문자열을 메시지로 하는 alert 창을 알아서 띄워준다.
				조건 1. window.event 의 returnValue 프로퍼티에 alert 창에 띄울 문자열을 할당해야된다.
				조건 2. 앞서 window.event.returnValue 에 할당했던 문자열을 함수가 반환하게 해야된다. 
				: 주의 >> 이 이벤트 핸들러에서 직접 alert 를 호출하는 것은 blocking 되어있다.
				: https://ironpapa.tistory.com/30
				
		3. unload : 사용자가 현재 웹 페이지를 떠나기 직전에 발생. 그러니까 나가는거 확정되서 나가기 바로 직전(단순 x 버튼 눌렀다고 발생(이건 beforeunload 이다)하는게 아니라 찐으로 나가는 상황에서)에 발생됨.
			: window 객체에서 발생 가능한 이벤트
			:  주로 페이지를 떠나기 전에 추가 정리 작업이나 자원을 해제하는 데 사용됨
		
		4. resize : 사용자가 윈도우 크기를 조절할때 

		



이벤트 함수 vs 이벤트 핸들러 vs 이벤트 리스너
	: 노션에 교수님이 이벤트 핸들러 == 이벤트 리스너라고 하셨는데, 완전 똑같은 개념은 아님
	: 누가 네이밍한지 모르겠는데, ㅈㄴ 헷갈리게 이벤트 핸들러의 경우 이벤트 함수 자체를 지칭하는 용어이기도 하고,  addEventListener( ) 없이 대상 객체와 이벤트 함수를 바인딩 시키는 방식을 지칭하는 용어이기도 함.

	: 헷갈리는거 정리
		인라인방식이벤트함수바인딩 >> 태그의 onXXXX 속성에 .  "함수" 를 할당  .
		addEventListner( ) 없이 이벤트 함수 바인딩 >> 요소 객체의 onXXXX속성에. "함수명"을 할당
		addEventListner( ) 로 이벤트 함수 바인딩 >> addEventListner( ) 의 첫번째 arg 로 "XXX" 즉 이벤트타입을.  두번째 arg 로 "함수명"을


	: 이벤트 함수 == 이벤트 핸들러 >> 이벤트 발생 시 호출 시킬 함수
		: 익명 함수로도 구현 가능
		: 주의 >> 익명함수가 아니냐 || 익명함수 중에서도 화살표 함수냐 || 그냥 익명함수냐 따라서 나타나는 현상이 다르다
			

	: 이벤트 핸들러 >> addEventListener( ) 를 사용하지 않고 이벤트와 함수를 연결 시킴 . 한 이벤트 타입에 대해 하나의 이벤트 함수만 바인딩 가능.
		: 한 이벤트타입에 대해 여러번 함수 바인딩 할 시 가장 마지막으로 바인딩된 함수가 이벤트 발생 시 호출됨.
		: 구현 방법
			(1) 인라인 : 태그의 이벤트 속성(onXXX)을 사용하여 특정 이벤트 타입과 함수(혹은 실행내용)을 바인딩 함
				<button id="btn" onclick="console.log('버튼 클릭')">

			****** 주의 >> 함수를 할당하는 경우 "함수명" 을 할당하면 안되고, "함수명( )" 을 할당해야된다 

			(2) 스크립트문 
				step1. 이벤트 발생 감지 대상 객체 얻기 
					const btnNode = document.getElementById("btn");
				step2. 객체의 이벤트 속성에 함수 할당
					btnNode.onclick = ( ) => console.log("버튼 클릭") ;

				******: 쥬의 >> 
					1. "이벤트함수명( )" 을 할당하면 안된다 ! 이러면 함수를 할당하는게 아니라 함숫값을 할당하는게 된다!! >> arg 를 요구하는 이벤트함수를 할당하고 싶으면 미리 선언한걸 할당하는게 아니라 익명함수로 할당해야된다
					2. 이벤트명을 대상으로 쓰는게 아니라 이벤트속성명( "on어쩌구") 에 할당하는거다
					ex ) <div id="special"> Hello World! </div>
					<script>
					function changeColor() {
 					 document.getElementById("special").style.backgroundColor='blue';
					}

					document.getElementById("special").onmouseover = changeColor; 
					// document.getElementById("special").mouseover하면안된다
					// changeColor( ) 할당하면안된다. 
					</script>



	: 이벤트 리스너 >> addEventListener( ) 를 사용하여 이벤트와 함수를 연결 시킴. 한 이벤트 타입에 대해 여러 이벤트 함수들을 바인딩 가능.
		: 쉽게 생각하면 "이벤트타입 + 이벤트 함수 + 옵션" 이 이벤트 리스너를 구성한다고 보면 된다
		: 구현 방법
			step1. 이벤트 발생 감지 대상 객체 얻기 
				const btnNode = document.getElementById("btn");

			step2. 객체를 대상으로 addEventListner(  이벤트타입명 , 추가할이벤트함수 , 옵션 )을 사용 
			******: 주의 >>  
					1. 이벤트명을 대상으로 쓰는거다 !!! ( "on어쩌구" 할당하는게아니다) 
					2. "이벤트함수명( )" 을 할당하면 안된다 ! 이러면 함수를 할당하는게 아니라 함숫값을 할당하는게 된다!!

				: ex ) 
				let obj = document.getElementById("special");
				obj.addEventListener("mouseover", func1 );
				obj.addEventListener("mouseover", func2 );
				obj.addEventListener("mouseover", func3 );

				: 이벤트 함수로 익명함수도 가능하다	
					주의 >> 이벤트 함수를 익명함수로 줄 경우 나중에 removeEventListener( 이벤트타입명 , 제거할이벤트함수명 , 옵션)로 해당 함수를 제거할 수 없게 된다

				: 옵션 : "캡쳐"를 쓸 건지의 여부 << 생략 가능하다
					true : 이벤트 캡처가 활성화됨
					false : 버블링이 활성화됨 << ******디폴트

				btnNode.addEventListener( 'click', ( ) => console.log("버튼 클릭") );	

		: 이벤트 리스너 제거 방법 >> 이벤트 리스너 추가했던 객체를 대상으로 removeEventListener( 이벤트타입명 , 제거할이벤트함수명 , 옵션)
			: 이벤트타입 >> 제거하려는 이벤트 함수와 함께 바인딩 됬었던 이벤트 타입

			: 제거할이벤트함수명
				: 이름을 명시해야되기 때문에 익명 이벤트 함수는 삭제 불가한다

			: 옵션 >>  제거하려는 이벤트 함수와 함께 바인딩 됬었던 옵션
				: 이벤트 리스터 생성 당시 바인딩되었던 옵션과 다른 옵션을 주면 해당 이벤트 리스너는 삭제되지 않는다.









이벤트 객체 event object 
	: 해당 이벤트에 관련된 모든 정보를 저장하고 있는객체
		: 주의 >> 이벤트 감지 당하는 객체가 이벤트 객체인게 아니라, 이벤트 감지 당하는 객체의 이벤트에 바인딩된 이벤트 함수에 자동 주입되는 객체를 이벤트 객체라고 하는거다.
	: 이벤트가 발생하면, 이벤트 객체는 동적으로 생성되어, 이벤트 핸들러에 인자로 암묵적으로 주입된다
	: 이벤트 객체가 어떤 속성을 갖느냐는 해당 이벤트 객체가 어떤 타입의 이벤트냐에 따라 달라진다
	: 상속 구조
		Object
		      ▼ Event 
				▼ AnimationEvent  
				▼ UIEvent 
					▼ FocusEvent
					▼ MouseEvent : mousedown, mouseup, click , mouseover , mouseout ... 
						▼ DragEvent
						▼ WheelEvent : wheel 이벤트 
					▼ KeyboardEvent
					▼ InputEvent

				▼ ClipBoardEvent 
				▼CustomEvent 

	: 이벤트 함수가 가질 수 있는 파라미터는 event객체 하나뿐.
	: Event 객체의 속성
		: https://aboveimagine.tistory.com/96
		: 공통적인 속성
			(1) type : 발생한 이벤트 타입명. (String 값)
			(2) target :  이벤트가 실제로 발생된 정확한 DOM 요소 (Object값)
				: 해당 이벤트를 실제로 트리거 시킨 대상
					ex ) 버블링 되는 이벤트 대해 이벤트 핸들러가 부모에 바인딩되있는 상태에서, 자식에서 해당 이벤트가 일어나면(자식에는 해당 이벤트 대해 바인딩된 이벤트 핸들러가 없다 할 지라도) 부모에서 해당 이벤트 핸들러가 실행된다. 이때 target 은 자식 요소이며, currentTarget 은 부모 요소이다. 
			(3) currentTarget  : 이벤트 핸들러가 바인딩된 DOM 요소  (Object값)
				target vs currentTarget
					: 아래의 경우 <li id="1">item1</li>를 클릭했을떄  e.tarage 으로는 딱 클릭했었던 <li id="1">item1</li> 이 나오고, e.currentTarget 으로는 이벤트 핸들러가 실제로 바인딩되어있는 <ul id="list"> 가 출력된다.

					<body>
 					 <ul id="list">
  					  <li id="1">item1</li>
   				 	<li id="2">item2</li>
 					 </ul>
  					<script>
   					 const list = document.querySelector('#list');

  					  list.addEventListener('click', (e) => {
    					  console.log(e.target);
    					  console.log(e.currentTarget);
    					});
 					 </script>
					</body>
		
			(4) bubbles : 이벤트가 버블링 떄문에 상위 요소로 전파되어 발생된건지 검사 (boolean 값)
			(5) timeStamp  : 이벤트가 발생한 ,  "페이지 로드 시간"으로부터의 경과 시간값 (ms단위)
			(6) cancelable :브라우저 기본 이벤트 취소를 가능하게 할껀지 정한다
				: 이게 true 여야 preventDefault( ) 를 할 수 있다


	: Event 객체의 메서드 
		: 공통 메서드 
			stopPropagation( ) :  부모엘리먼트에게 이벤트전달을 중단할 때 사용. 딱 이벤트 핸들러에 바인딩된 요소에서 이벤트가 일어나야 함수를 실행한다.
		
		******preventDefault( ) : 이벤트의 기본 동작을 취소. 브라우저 고유의 동작을 중단시켜줌
				: 이 메소드는 cancelable 속성이 true일 때만 효과가 있다.
				: 주로 사용되는 경우 >> 페이지 전환 방지 목적
					1. a 태그를 눌렀을때도 href 링크로 이동하지 않게 할 경우
					2. form 안에 submit 역할을 하는 버튼을 눌렀어도 새로 실행하지 않게 하고싶을 경우 ( !!submit은 작동됨!! )
				: https://programming119.tistory.com/100


	: 이벤트 타입에 따른 속성들
		(1) 마우스이벤트
			: https://mong-blog.tistory.com/entry/clientX-offsetX-pageX-screenX-%EC%B0%A8%EC%9D%B4
			1. clientX , clientY : 클라이언트 영역( 보여지는 브라우저 페이지,화면 기준.  스크롤이 얼마나 되있는지 그런거 계산 없이  )의 상단과 왼쪽사이드를 0으로 잡고 가로, 세로 좌표 제공 ( 아래, 오른쪽으로 갈수록 각각 y, x 값 증가한다 ) 	
			0. offsetX , offsetY : "이벤트 대상"( 브라우저 화면이 기준이 아니다 )의 상단과 왼쪽 사이드를 0으로 잡고, 가로, 세로 좌표를 제공한다
			2. pageX, pageY: 전체 "문서"( 스크롤영역까지 고려하여 )의 상단을 0으로 잡고 x,y 좌표를 반환한다
			3. screenX, screenY :  "모니터"( 브라우저 그런거 상관 없이 컴퓨터)의 상단을 0으로 잡고 x,y 좌표를 제공한다
				: 브라우저를 움직여도 값은 같다

			4. layerX, layerY : position 을 적용한 요소를 기준으로  x,y 좌표를 반환한다
			5. button : 마우스 버튼의 종류에 따라 값 반환 ( 왼쪽 : 0, 휠 : 1 , 오른쪽: 2 ) 
			6. buttons : 

		(3) wheel 이벤트 
			: mouse 이벤트를 상속하는 이벤트 타입이다
			: https://blog.naver.com/how2frontend/222306472981
			1. deltaX , deltaY , deltaZ : 마우스 휠의 가로 , 세로, z 축 스크롤 "양"을 리턴
			2. deltaMode : delta 값의 측정 단위를 나타내는 숫자 반환
			3. wheelDelta? >> https://bejerry.tistory.com/8

		(2) 키보드 이벤트 
			: https://hyeonseok.com/blog/897
			1. key : "논리적인" 키 값(= 실제로 입력되는 값 )을 문자열로 반환
				: A를 눌렀으면 "A" 를 반환한다 . shift 를 누르면 "escape" 를 반환한다. 
				: 참고 >> keyCode 는 해당 키의 아스키코드값을 반환한다. 그리고 현제 depreceated 되었다

			2. code : "물리적인" 키 값(= 논리적키값+ 위치를나타내는접두/미사 )을 문자열로 반환
				: A 를 눌렀으면 "keyA"를 반환한다. shift 를 누르면 왼쪽이냐 오른쪽이냐 따라서 "shiftLeft", "shiftRight" 가 반환된다.
				: 해당 키와 연결된 문자 뿐 아니라, 해당 키의 물리적 위치까지 고려하여 정미란 작업을 처리하려는 경우 유용하다 

			3. altKey , ctlrKey ,  shiftKey : 각각 alt 키 || crtl 키 || shift 키 가 눌린건지 booelan 값으로 여부를 표시한다




이벤트 위임
	: 




 이벤트 전파 propagation  : 부모에 바인딩된 이벤트 핸들러에 대응하는  이벤트가 자식에서 일어나면, 해당 이벤트는 부모에서"도" 일어난 것으로 간주된다.
	: 이벤트 전파를 적용하는게 특별한게 아니라, 이벤트 전파를 적용하지 않는게 특별한 케이스인거다.
		: 그러니까 브라우저는 버블링이든, 캡쳐링이든 이벤트 전파의 사용이 기본적으로 적용되고, 전파 시키지 않고 싶다면 일단 적용이된 이후에서야 이를 막는 방식으로 별도 처리를 해줘야된다.

	: addEventListener( ) 로 바인딩한 이벤트는
		: 버블링 방식 전파 - 디폴트  
		: 캡쳐링 방식 전파 - addEventListener( ) 의 arg 로 true 옵션 
		: 버블링 방식과 캡쳐링 방식을 동시에-  한 이벤트 핸들러 대해 한번은 옵션을 주고 바인딩하고 , 또 한번은 옵션을 주지 않고 바인딩하면 된다
			child.addEventListener("click", (e) => { console.log('child clicked'); })
			child.addEventListener("click", (e) => { console.log('child clicked'); }, true)

		: 전파를 하지 않게 - 등록되는 이벤트 핸들러 내부에 stopPropagation( ) 명시
 
	: 요소간 포함 관계(계층관계)가 있는 경우 일어난다
	: 전파가 일어나지 않는다 == target 과 currentTarget 이 항상 일치한다 == 자기 자신만이 이벤트를 받을 수 있다
	: 왜 이런 기능이 있는걸까 >>  자식 요소가 부모 요소 영역 안에 위치하고 있기 때문에 자식 요소만을 클릭하였다 하더라도 논리적으로 보면 부모 요소도 클릭한 셈이 되기 때문이다. 그러니까 논리적인 사람의 관점을 반영하는 것이다.


	: 종류
		(1) 버블링 bubbling : 자식에서 이벤트 발생 시 , 자식에서 먼저 자식에 바인딩됬었던 이벤트 핸들러가 먼저 호출된 후, 해당 이벤트 대해 부모에 바인딩됬었던 이벤트 핸들러가 호출된다( 안쪽 --> 바깥쪽 )

			: 버블링이 적용된 이벤트 발생시 target과 currentTarget 
				: 부모와 자식 모두에 해당 이벤트 대해 이벤트 함수 바인딩 해놓은 경우
					: 부모에서 발생 시 : target-부모 , curTarget-부모 . 부모에 바인딩된 이벤트 함수만 호출된다
					: 자식에서 발생 시 : target-자식 , curTarget-자식 먼저 일어난 후 ,  target-자식 , curTarget-부모  .자식에 바인딩된 이벤트 함수가 호출된 후 자동적으로 부모에 바인딩된 이벤트 함수도 호출된다

				: 부모에만 해당 이벤트 대해 이벤트 함수 바인딩 해놓은 경우
        				: 부모에서 발생 시 :  target-부모 , curTarget-부모 . 부모에 바인딩된 이벤트 함수만 호출된다
        				: 자식에서 발생 시 : target-자식 , curTarget-부모. 부모에 바인딩된 이벤트 함수만 호출된다
				: 자식에만 해당 이벤트 대해 이벤트 함수 바인딩 해놓은 경우
        				: 부모에서 발생 시 : 아무 일도 안 일어난다
        				: 자식에서 발생 시 : target-자식 , curTarget-자식. 자식에 바인딩된 이벤트 함수만 호출된다

			: 암기 tip >> 버스는 안쪽 부터 앉아야된다




		(2) 캡쳐링 capturing :  자식에서 이벤트 발생 시 , 해당 이벤트 대해 부모에 바인딩됬었던 이벤트 핸들러가 먼저 호출된 후, 자식에 바인딩됬었던 이벤트 핸들러가 호출된다 (바깥쪽 --> 안쪽)


브라우저 객체 모델(BOM: Browser Object Model): 웹 브라우저가 가지고 있는 모든 객체
	▼ window
		: 자바스크립트의 모든 전역 함수는 window 객체의 메서드
		: window 객체는 생략 가능
		▼***document  >> DOM DocumentObjectModel
			▼ forms 
			▼ anchors 
			▼ layers
			▼ forms 
 		▼ navigator 
		▼screen 
		▼ history 
		▼ location 
		▼frames 

-----------------------------------------------------------------------------------------------------------
Tip
	1. css 에서는 snake case 비슷했던 것이, js 상의 속성명으로는 camel case 이다
		ex ) 객체.style.backgroundColor

	2. js 파일 연결할 떄 <script src="indexScript.js" /> 처럼 축약형식으로 사용하면 잘 안된다. <script src="indexScript.js"></script> 로 제대로 해줘야된다.

	3. html 에서 정의한 스타일 값을 불러올 때는 해당 스타일규칙에 대응하는 프로퍼티명을 사용해서 가져오지 말고, getComputedStyle( ) 를 사용해라
		: 인라인으로 정의된 스타일 규칙이 아닌 이상은 프로퍼티로는 스타일 규칙이 불러와지지 않는다
		: https://kin.naver.com/qna/detail.naver?d1id=1&dirId=1040202&docId=361349219&enc=utf8&kinsrch_src=pc_tab_kin&qb=7J6Q67CU7Iqk7YGs66a97Yq4IOqwneyytCDsho3shLEg67mIIOusuOyekOyXtA%3D%3D&rank=16&search_sort=0&section=kin.qna_ency_cafe&spq=0

-----------------------------------------------------------------------------------------------------------



	

	
