생성자 함수
	: 일반적인 function 을 호출할 떄 new 키워드 앞에 붙이고 호출하면 그 함수는 생성자 함수 취급된다.	
	: 생성자 함수는 되도록 첫 글자를 대문자로.

	function Person(name) { this.name = name; }
	var me = new Person('Lee'); // Person은 생성자 함수
	console.log(me); // Person&nbsp;{name: "Lee"}



자바스크립트에서의 this
	: 함수의 블록 스코프내에서 사용 가능
	: js 의 전역위치, 일반적인(메서드 혹은 생성자함수 혹은 이벤트 함수가 아닌) 함수 내에서 사용하면 >> window 객체를 가리킴
		: doucmnet 아님 주의
	: js 의 "메서드 내" 혹은 "생성자함수 내" 혹은 "이벤트 함수 내"에서 사용하면 >> 해당 인스턴스를 가리킴
	******: 주의 >> 객체 내부의 함수에서 사용됬다고 해서 그게 다 메서드는 아닌 것처럼 this 도 항상 해당 인스턴스를 가리키는게 아니다. 메서드 내부의 arg로들어간 콜백함수에서의 this 는 해당 메서드의 객체를 가리키지 않고  window 객체를 가리킨다.

	: this 바인딩 >> 함수 호출 방식에 따라 this 에 바인딩될 객체가 동적으로 결정된다
		:  함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되는 것이 아니고, 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다.
	******:  js의 메서드를 꺼내서 다른 변수에 할당하면 더이상 그 객체에 속한 함수가 아닌 일반함수가 되기 떄문에 다시 this 는 window 객체를 가리키게된다.
		: https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-this-%EC%B4%9D%EC%A0%95%EB%A6%AC
​

-----------------------------------------------------------------------------------------------------------

이벤트 : 상호작용이 발생하는 것


이벤트타입명 != 이벤트속성명
	: 이벤트속성은 onXXXX 꼴이고, 이벤트타입은 on 을 제외한 XXXX 부분이다.

JS 의 함수와 메서드 주의 >> 객체 내부에서 선언된 함수라고 해서 다 메서드인게 아니라, 직접적으로 객체 내부에서 선언된 함수만 메서드이다
	: 메서드의 내부에서 선언된 함수는 메서드가 아니라 걍 함수이다.

JS 의 this 바인딩 정리
	(0) this가 지정되지 않은 경우, this는 자동으로 전역 객체를 바라본다
	(1) 전역 공간의 this : 전역 객체	
	(2) function 으로 선언된 함수 내부의 this : 해당 함수가 메서드냐 아니냐 따라 동적 바인딩 된다.
		1. 메소드 내부의 this >>  해당 메소드를 호출한 ( 해당 메서드가 속한 ) 객체		 
		2. 메서드가 아닌 함수 내부의 this 
			: function 키워드로 선언된 익명 함수도 이 케이스에 해당한다
			(1) 이벤트 리스너의 콜백 함수로 사용되는 경우 >> addEventListener 을 적용시킨 객체에 바인딩된다
			(2) 이벤트 리스너의 콜백 함수로 사용되는게 아닌 경우 >>  this 가 지정되지 않기 떄문에  (0) 에 의해 자동적으로 전역 객체를 가리키게된다.

	
	(4) 화살표 함수 내부의 this : 선언 시점에 상위 스코프가 this 로 바인딩된다.
		: 화살표 함수에는 this 가 아예 없어서 가능한 것
			: function으로 선언된, 메서드가 아닌 함수의 경우 this가 존재하긴 하지만 값이 지정되지 않기 때문에 전역 객체를 가리키게 되는건데 , 화살표 함수로 선언한 함수에는 this가 아예 없다.
			: JavaScript에서는 어떤 식별자를 찾을 때 현재 scope에 그 변수가 없으면 , 변수를 찾거나 가장 상위 환경에 도달 할 때까지 가까운 상위 환경 순으로 탐색한다. 화살표 함수에서의 this 바인딩 방식도 이와 마찬가지로,  화살표 함수에는 this라는 변수 자체가 존재하지 않기 때문에 그 상위 환경에서의 this를 참조하게 되는거다.
		: 주의 >> "해당 함수를 호출한" 객체를 가리키는게 아니라(동적바인딩이 아니라) , 선언 시점의 상위 스코프 객체를 가리키게되는거다
		: 그러니까 활용하면 좋은 경우는 함수 내부에서 해당 함수가 간접적으로 속한 객체를 this 를 이용해서 참조하고 싶을 때.
		: 이는 해당 화살표 함수를 이벤트 함수로써 사용할 때도 적용된다. 
		button.addEventListener('click', () => {
 			 console.log(this);	// Window
  			this.innerHTML = 'clicked';
			});


	: https://developer-talk.tistory.com/884
	: https://velog.io/@padoling/JavaScript-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98%EC%99%80-this-%EB%B0%94%EC%9D%B8%EB%94%A9




이벤트 함수 vs 이벤트 핸들러 vs 이벤트 리스너
	: 노션에 교수님이 이벤트 핸들러 == 이벤트 리스너라고 하셨는데, 완전 똑같은 개념은 아님
	: 누가 네이밍한지 모르겠는데, ㅈㄴ 헷갈리게 이벤트 핸들러의 경우 이벤트 함수 자체를 지칭하는 용어이기도 하고,  addEventListener( ) 없이 대상 객체와 이벤트 함수를 바인딩 시키는 방식을 지칭하는 용어이기도 함.

	: 이벤트 함수 == 이벤트 핸들러 >> 이벤트 발생 시 호출 시킬 함수
		: 익명 함수로도 구현 가능
		: 주의 >> 익명함수가 아니냐 || 익명함수 중에서도 화살표 함수냐 || 그냥 익명함수냐 따라서 나타나는 현상이 다르다
			

	: 이벤트 핸들러 >> addEventListener( ) 를 사용하지 않고 이벤트와 함수를 연결 시킴 . 한 이벤트 타입에 대해 하나의 이벤트 함수만 바인딩 가능.
		: 한 이벤트타입에 대해 여러번 함수 바인딩 할 시 가장 마지막으로 바인딩된 함수가 이벤트 발생 시 호출됨.
		: 구현 방법
			(1) 인라인 : 태그의 이벤트 속성(onXXX)을 사용하여 특정 이벤트 타입과 함수(혹은 실행내용)을 바인딩 함
				<button id="btn" onclick="console.log('버튼 클릭')">

			(2) 스크립트문 
				step1. 이벤트 발생 감지 대상 객체 얻기 
					const btnNode = document.getElementById("btn");
				step2. 객체의 이벤트 속성에 함수 할당
					btnNode.onclick = ( ) => console.log("버튼 클릭") ;


	: 이벤트 리스너 >> addEventListener( ) 를 사용하여 이벤트와 함수를 연결 시킴. 한 이벤트 타입에 대해 여러 이벤트 함수들을 바인딩 가능.
		: 쉽게 생각하면 "이벤트타입 + 이벤트 함수 + 옵션" 이 이벤트 리스너를 구성한다고 보면 된다
		: 구현 방법
			step1. 이벤트 발생 감지 대상 객체 얻기 
				const btnNode = document.getElementById("btn");

			step2. 객체를 대상으로 addEventListner(  이벤트타입명 , 추가할이벤트함수 , 옵션 )을 사용 
				: 이벤트 함수로 익명함수도 가능하다	
					주의 >> 이벤트 함수를 익명함수로 줄 경우 나중에 removeEventListener( 이벤트타입명 , 제거할이벤트함수명 , 옵션)로 해당 함수를 제거할 수 없게 된다

				: 옵션 >> 생략 가능하고, true 할당시 이벤트 캡처가 활성화됨
					: 디폴트값 false

				btnNode.addEventListener( 'click', ( ) => console.log("버튼 클릭") );	

		: 이벤트 리스너 제거 방법 >> 이벤트 리스너 추가했던 객체를 대상으로 removeEventListener( 이벤트타입명 , 제거할이벤트함수명 , 옵션)
			: 이벤트타입 >> 제거하려는 이벤트 함수와 함께 바인딩 됬었던 이벤트 타입

			: 제거할이벤트함수명
				: 이름을 명시해야되기 때문에 익명 이벤트 함수는 삭제 불가한다

			: 옵션 >>  제거하려는 이벤트 함수와 함께 바인딩 됬었던 옵션
				: 이벤트 리스터 생성 당시 바인딩되었던 옵션과 다른 옵션을 주면 해당 이벤트 리스너는 삭제되지 않는다.




: event 와 그에 따른 event handler||event Listner 속성 의 종류
	: tip >> 'on'+이벤트명== event handler||event Listner 속성
	(1) 마우스 관련
		2. mouseover && onmouseover : 마우스를 영역내에 위치
			: mouseenter는 explore 전용임 주의
		3. mouseout && onmouseout: 마우스를 영역 밖에 위치
		1. click && onclick : 마우스로 딱 눌린 그 찰나
		4. mousedown && onmousedown:  마우스를 클릭하고 떼지않은 상태
		5. mouseup && onmouseup: 마우스를 똄
		6. mousemove && onmousemove: 마우스를 움직임 

	(2) 키보드 관련	
		1. keydown && onkeydown : 사용자가 키를 눌렀을떄
		2. keyup && onkeyup : 사용자가 누른 키 뗏을 때

	(3) form 관련
		1. focus && onfocus : 해당 필드에 입력을 시도할 때 (아직 누른건 아님)
		2. submit && onsubmit : 사용자가 입력 양식을 제출할떄
	******3. blur && onblur : 입력요소가 포커스를 잃었을떄
		4. change && onchange: 사용자가 입력 요소의 값을 변경할때

	(4) 페이지로딩관련
		1. load && onload : 브라우저가 페이지 로드를 완료하면
		2. unload && onunload: 사용자가 현재 웹 페이지를 떠날떄
		3. resize && onresize : 사용자가 윈도우 크기를 조절할때 







이벤트핸들러(이벤트 함수) : 특정요소의 이벤트핸들속성에 할당,추가되는 함수
	: 꼭 일반적인 함수일 필요는 없고 익명함수여도 괜찮다
	: 이벤트 함수의 경우 일반적인 함수와 다르게 내부적으로 this가 자신이 할당된 요소를 참조하게 해준다!!! 
		: 일반적으로 할당된 함수는 window 객첼 가리킨다.
			ex) document.body.onclick = function() { console.log(this);  }



event handler , event listener >> 이벤트를 처리하는 코드. 특정 이벤트와 특정 함수를 맵핑하여 특정이벤트발생시 특정 기능을 수행하도록 하는 얘.
	: https://developer-talk.tistory.com/884
	: 대체로 둘이 혼용되어 불린다. 
		: 근데  addEventListner( )를 사용하여 만든 경우 "event Listner" 이라고 하고, event handler 이라곤 못한다.

	: 만드는 법
		sol(1) 이벤트핸들러속성에 이벤트함수할당  >> 한번에 하나의 이벤트 함수만 가리킬 수 있다. 새로 할당하면 기존것은 참조를 잃어버린다

			sol1 . HTML 요소의 이벤트핸들러속성에 코드를 직접 추가( 인라인 방식 ) 
				: 태그 내부에서 this 를 사용하여 요소 자기자신을 쉽게 구할 수 있다
				ex ) <div onmouseover='this.style.backgroundColor="blue"'>hehehehe</div>

			sol 2. script문에서  요소 객체의 이벤트핸들러속성에 함수를 대입 : 
				: 해당요소객체.이벤트핸들러속성명 = 이벤트함수"명" 혹은 익명함수;
			******: 쥬의 >> 
					1. "이벤트함수명( )" 을 할당하면 안된다 ! 이러면 함수를 할당하는게 아니라 함숫값을 할당하는게 된다!! >> arg 를 요구하는 이벤트함수를 할당하고 싶으면 미리 선언한걸 할당하는게 아니라 익명함수로 할당해야된다
					2. 이벤트명을 대상으로 쓰는게 아니라 이벤트속성명( "on어쩌구") 에 할당하는거다
				ex ) <div id="special"> Hello World! </div>
				<script>
				function changeColor() {
 				 document.getElementById("special").style.backgroundColor='blue';
				}

				document.getElementById("special").onmouseover = changeColor; 
				// document.getElementById("special").mouseover하면안된다
				// changeColor( ) 할당하면안된다. 

				</script>


		sol (2) script문에서 addEventListner( "이벤트명", 이벤트함수명||익명함수 ) 함수를 사용 >> 하나의 이벤트에 여러개의 이벤트함수를 맵핑할 수 있다. "추가"되는 개념이다. 
		******: 주의 >>  
				1. 이벤트명을 대상으로 쓰는거다 !!! ( "on어쩌구" 할당하는게아니다) 
				2. "이벤트함수명( )" 을 할당하면 안된다 ! 이러면 함수를 할당하는게 아니라 함숫값을 할당하는게 된다!!

			: ex ) 
			let obj = document.getElementById("special");
			obj.addEventListener("mouseover", func1 );
			obj.addEventListener("mouseover", func2 );
			obj.addEventListener("mouseover", func3 );



이벤트 객체 event object : DOM과 관련된 모든 이벤트를 저장하고있는 객체
	: 상속 구조
		Object
		      ▼ Event 
				▼ AnimationEvent  
				▼ UIEvent 
					▼ FocusEvent
					▼ MouseEvent
						▼ DragEvent
						▼ WheelEvent
					▼ KeyboardEvent
					▼ InputEvent

				▼ ClipBoardEvent 
				▼CustomEvent 

	: 이벤트 함수가 가질 수 있는 파라미터는 event객체 하나뿐.
	: 이벤트 핸들러 내부의 this는 항상 currentTarget와 값이 일치하며 target에는 이벤트의 실제 타깃만 포함
	: Event 객체의 속성
		: 공통적인 속성
			(1) type : 발생한 이벤트 타입명. (String 값)
			(2) target :  이벤트가 실제로 발생된 정확한 DOM 요소 (Object값)
			(3) currentTarget  : 이벤트 핸들러가 바인딩된 DOM 요소  (Object값)
				target vs currentTarget
					: 아래의 경우 <li id="1">item1</li>를 클릭했을떄  e.tarage 으로는 딱 클릭했었던 <li id="1">item1</li> 이 나오고, e.currentTarget 으로는 이벤트 핸들러가 실제로 바인딩되어있는 <ul id="list"> 가 출력된다.

					<body>
 					 <ul id="list">
  					  <li id="1">item1</li>
   				 	<li id="2">item2</li>
 					 </ul>
  					<script>
   					 const list = document.querySelector('#list');

  					  list.addEventListener('click', (e) => {
    					  console.log(e.target);
    					  console.log(e.currentTarget);
    					});
 					 </script>
					</body>
		
			(4) bubbles : 이벤트가 버블링 떄문에 상위 요소로 전파되어 발생된건지 검사 (boolean 값)
			(5) timeStamp  : 이벤트가 발생한 ,  "페이지 로드 시간"으로부터의 경과 시간값 (ms단위)
			(6) cancelable :브라우저 기본 이벤트 취소를 가능하게 할껀지 정한다
				: 이게 true 여야 preventDefault( ) 를 할 수 있다


	: Event 객체의 메서드 
		: 공통 메서드 
			stopPropagation( ) :  부모엘리먼트에게 이벤트전달을 중단할 때 사용. 딱 이벤트 핸들러에 바인딩된 요소에서 이벤트가 일어나야 함수를 실행한다.
		
		******preventDefault( ) : 이벤트의 기본 동작을 취소. 브라우저 고유의 동작을 중단시켜줌
				: 이 메소드는 cancelable 속성이 true일 때만 효과가 있다.
				: 주로 사용되는 경우 >> 페이지 전환 방지 목적
					1. a 태그를 눌렀을때도 href 링크로 이동하지 않게 할 경우
					2. form 안에 submit 역할을 하는 버튼을 눌렀어도 새로 실행하지 않게 하고싶을 경우 ( !!submit은 작동됨!! )
				: https://programming119.tistory.com/100


 Event 전파
	: 요소간 포함 관계가 있는 경우 일어난다
	: 종류
		(1) 버블링 bubbling : 안쪽 --> 바깥쪽
		(2) 캡쳐링 capturing
			: 
-----------------------------------------------------------------------------------------------------------

까먹지 말아야할것
	: 단순 함수를 선언한다고 실행되는게 아니라 실제로 호출해야된다;;
	function a() { console.log(this); };
	a(); //이거 안하면 걍 쌩 난리친것

-----------------------------------------------------------------------------------------------------------

헷갈리는코드
	(1) 이벤트속성에 이벤트함수 할당할떄 ' 함수명( ) ' 이 아닌 '함수명' 을 할당하는거고, addEventListener 의 arg 로 "이벤트속성명" 이 아닌 "이벤트명"이 들어가는거다

<!DOCTYPE html>
<html>
  <body>
    <div id="ging">
      마우스를 올려주세요!
    </div>

    <script>
     let obj = document.getElementById("ging");
      console.log(obj);

      function mouseOver() {
        this.innerHTML = '감사합니다.'
      }
      function mouseOut() {
        this.innerHTML = '마우스를 올려주세요!'
      }
      obj.addEventListener('mouseover',mouseOver);
      obj.addEventListener('mouseout',mouseOut);


      function mouseClick() {
        this.innerHTML = 'yyyyyyyyyyyyyy.'
      }
      function mouseOut2(jj) { // 이벤트함수로써 적절하지 않다. 이벤트속성에 함수명만 할당해야되는데 따로 arg 를 요구하는 함수이기 떄문
        jj.innerHTML = 'tert tetrettret!'
      }
      obj.onmousedown = mouseClick; // 함수명을 할당해야된다. 함수명( ) 으로 하면 값이 할당되는거라 안된다.
      obj.onmouseout = mouseOut2; 


    </script>
  </body>
</html>
