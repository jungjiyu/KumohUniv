인텔리제이 커뮤니티 + JSP >> https://blog.naver.com/hong227/221427027109


웹 서버와 jsp 

웹 서버와 클라이언트의 상호작용
	: 클라이언트 > 서버에 특정 웹페이지를 request
	: 서버 > 해당 웹페이지를 response

정적 페이지 : 
	: 서버에 미리저장되어있다
	: 주로 HTML , CSS , JS ,이미지 로 구성되어있다

동적 (웹) 페이지 : 서버에 미리 저장된 파일이 아닌, 서버에 있는 데이터들(db에서 읽어서)로 가공해 새로 생성되는 페이지. 
	: ex ) 이메일 , 게시판 ... 
	: 구현 위해 필요한 것 >>  데이터베이스 : 사용자의 정보를 읽어오기 위해선 DB 가 필요
	: 대부분의 웹 페이지는 "동적 페이지" 이다.



 
서버사이드  server-side : 서버 측에서 수행하는 처리
	: 서버사이드 스크립트 언어 : Java, PHP , Python .. 
	: SSR Server Side Rendering : 페이지 랜더링을 서버 쪽에서 다 해서 response 함

클라이언트사이드  client-side : 클라이언트 측에서 수행하는 처리
	: 클라이언트사이드 스크립트 언어 : JS
	: CSR Client Side Rendering : 최종적인 페이지 랜더링을 클라이언트 쪽에서 함


SEO Search Engine Optimization 검색엔진 최적화 : 사용자들에게 양질의 검색 결과를 상위 노출 시키는 것.



웹 서버 : "동시"에 "여러" 사용자를 서비스 한다


웹 서버쪽에서 자바 언어가 주로 채택되는 이유
	1. 플랫폼에 독립적이다( WORA ) == "이식성" 이 있다 .
	2. 스레드를 활용할 수 있다
	3. 제공 라이브러리가 풍부함.	



CGI  와 서블릿 servlet  >>둘 다 사용자의 요청에 따라 "서버사이드"에서 동적인 웹 페이지를 생성하거나 데이터를 처리하는 데 사용됨
	: https://velog.io/@suhongkim98/CGI%EC%99%80-%EC%84%9C%EB%B8%94%EB%A6%BF-JSP%EC%9D%98-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0
	: https://live-everyday.tistory.com/197

    : CGI Common Gateway Interface
	: "웹 서버"와 "외부 프로그램(CGI 스크립트)" 간의 통신을 할 수 있게 해주는 규약 혹은 인터페이스
	    : CGI 자체로는 프로그램이 아니다! 
	    : CGI 스크립트 ( CGI 프로그램 ) >>  CGI 규약을 따라 웹 서버와 상호작용하게되는 외부 프로그램
		: Perl, Python, C 등 다양한 프로그래밍 언어로 작성될 수 있음
		: DB 접근 등의 역할을 수행함

	: 문제점 >> CGI "프로그램" 단위로 처리가 이뤄짐으로,   request 마다 "프로세스" 를 생성하게 되어 부하가 매우 크다.
	******해결방안: "프로세스" 가 아닌 "쓰레드"를 사용하자 >> 그래서 나온게 servlet
			: 그러니까 옛날 서버사이드 랜더링 방식은 CGI 였고, 요즘은 servlet 이다.


	: 처리 흐름
		1. 클라이언트가 Http Request를 서버로 보냄
		2. 서버가 이를 받고, CGI 스크립트 호출
		3. 호출된 CGI 스크립트가 DB 등에 접근하여 정보얻어내고, 서버에 결과를 반환함
		4. 서버는 반환된 결과를 클라이언트에게 HttpResponse 로 보냄

    : CGI vs Servlet
	: 공통점 >> 둘다 동적인 컨텐츠를 생성하기 위해 사용됨
	: 차이점 >>
		: CGI --> 다양한 언어로 작성 가능. 요청마다 프로세스 단위 처리.
		: servlet -->  자바 언어로만 작성 가능. 요청마다 쓰레드 단위 처리.


   : Servlet >> 자바를 사용하여  멀티스레드 개념을 통해 웹페이지를 동적으로 생성하는 서버측 프로그램.
	: 각 요청에 대해 프로세스가 아닌, "스레드"를 생성하여 멀티 스레드로 처리한다
	: CGI 와 완전히 다른 개념은 아니다. 내부적으로는 CGI 통신 규약을 지킨다.
	: 서블릿 클래스는 HttpServlet 을 extends 하고, 내부적으로 init( ) ,  service( ) ,  doGet( ) , doPost( ) 같은 메서드를 오버라이딩한다.

	: 서블릿 컨테이너 >> 서블릿 클래스를 통해 객체를 생성하여, 싱글톤으로 관리한다.

	: 서블릿의 생명주기 life-cycle 및 주요 메서드
		1. init( ) : 서블릿이 메모리에 로드 될때 "한번만" 호출
		2. service( ) : request 가 들어오면 호출됨
		3. doGet( ) 혹은 doPost( ) :  service( ) 에 의해 내부적으로 호출됨
		4. destroy(  ) :  서블릿이 메모리에서 해제될 떄 "한번만" 호출

	: 서블릿 형식
		: doGet( request , response ) ,  doPost( request, response ) >>  get 방식 || post 방식 요청에 대한 처리하는 메서드 

	****** 헷갈리는 인코딩 타입 관련 설정 
			: https://cbw1030.tistory.com/62
			request.setCharacterEncoding("UTF-8"); : request 된 내용을 해당 방식으로 디코딩하라고 서버에게 알려주는 것
			response.setCharacterEncoding("UTF-8"); : 실제로 해당 방식으로 인코딩하여 response
			response.setContentType("text/html; charset=utf-8"); : 해당 방식으로 인코딩하였으니, 클라이언트에게 이 방식으로 디코딩하라고 알려주는 것. MIME 타입 결정하는 것.


		: 출력하기
			: PrintWriter out = response.getWriter() >>클라이언트와 연결된 출력 스트림 얻기 
				: HttpServletResponse 의 getWriter( ) 는 java.io 의 PrintWriter 클래스를 리턴한다. 그리고 그 인스턴스의 스트림은 클라이언트와 연결되어있다.
					: PrintWriter 클래스 >> 해당 데이터를 간편하게 출력 스트림에 출력해준다
						: 이 클래스의 인스턴스를 대상으로 print( ) , write( ) 메서드의 사용이 가능하다.
							: out.println( ) vs out.write( )
								: 어쩄뜬 서블릿에선 out.println 을 더 쓴다.
								: print( ) >> 해당 데이터를 텍스트 형식으로 출력. 데이터 포맷을 해준다.
								: write( ) >> 해당 데이터를 그대로 (바이너리 형식으로) 출력
								: ex ) write(49) == "1" ,  print(49) == "49"

						: 자바에서 제공되는 System.out 도 PrintWriter 클래스의 인스턴스인데, 이 인스턴스의 경우 클라이언트와 연결되있는 것이 아니고 서버쪽(콘솔)에 연결되있는거라 출력하면 콘솔에 뜨지, 클라이언트에게 가진 않는다
			

			: out.println("HTML코드")  >>클라이언트에게 반환될 HTML코드 출력



		public class Hello extends HttpServlet {
    
			protected void doGet( HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

	// request 객체에서 클라이언트 request 정보 뽑기
		// getParameter 사용
		String name = request.getParameter("username");
		String id = request.getParameter("userid");
		int area = Integer.parseInt(request.getParameter("area"));
		
	// response 객체로 클라이언트에게 response 하기
		// 1. response MIME type 설정 
		response.setContentType("text/html;charset=utf-8");

		// 2. 출력 스트림 get
		PrintWriter out = response.getWriter();

		// 3. 출력 스트림을 활용하여 html 코드 출력
		out.println("<html> <body>");
		out.println("	<h2>안녕하세요. " + name + "(" + id + ")님!!!</h2>");
		out.println("	</body> </html>");


	}

	
}

	: 단점 >> 자바 언어 내부에 HTML 언어가 삽입되는 방식이다. 번거롭다
		: 보완 >> HTML 언어 내부에 자바 언어를 삽입하지 해서 나온게 JSP 



preprocessor 전처리기 >> 특정 작업(주로 컴파일 작업) 이전에 작업을 수행하는 도구.
	: 대표적으론 c언어의 #include , #define 같은거. 얘네는 컴파일 이전에 다른 파일을 불러오고, 상수를 정의하여 문제 없이 코드를 컴파일 시킬 수 있게 한다.


스크립트 언어 : 인터프리터를 통해 실행되며 , 주로 동적인 작업을 하기 위해 사용되는 언어.
	: 클라이언트 측 스크립트 언어와 서버 측 스크립트 언어가 모두 있다.
		: 서버 측 스크립트 언어 >> PHP, JSP, ASP 
		: 클라이언트 측 스크립트 언어 >> JS 



JSP 와 ASP 와 PHP >> 서버사이드 스크립트 언어로 , 동적 웹 페이지를 생성하기 위해 사용된다.
    : https://ts2ree.tistory.com/21
    : 전처리기st 이다. >>  클라이언트에게 response 되기 전에 .asp , .jsp, .php 파일은 HTML 파일로 변환되기 떄문에, 클라이언트 측의 response 결과에는 asp , jsp, php 코드가 포함되어있지 않다. 



   : PHP Hypertext PreProcessor >> HTML 내부에 PHP 코드를 삽입하는 형식의 스크립트 언어
	: 하이퍼텍스트 "전처리기".
	: 확장자가 .php


    : ASP Active Server Pages >> HTML 내부에 VBScript 코드를 삽입하는 형식의 스크립트 언어
	: MS사에서 서비스한다
	: 확장자는 .asp



   : JSP Java Server Pages >> 서블릿과 반대로 HTML 내부에 자바 코드를 삽입하는 형식의 스크립트 언어
   	: ASP 의 영향을 받아 만들어졌고, 서블릿의 단점( 자바 코드 속 HTML 코드 )을 보완하였다.
	: JSP 코드는 내부적으로 서블릿으로 변환된다. Servlet 과 완전히 다른 개념이 아니다.
	: Oracle 사에서 서비스한다
	: JSP 페이지 처리 과정
		1. JSP 페이지 대한 request 가 들어옴
		2. web server 가 해당 요청을 web container 에게 위임
		3. 이미 요청 받은 적 있는 JSP 파일인지 체크 >> 즉, 해당 JSP 파일에 대한 서블릿 클래스가 있는지 검사. 
			3-1. 처음 요청 >>   "JSP 컨테이너" 에서 해당 JSP 파일을 Servlet 파일로 파싱하여 클래스 파일을 생성(컴파일)시켜줌
				: JSP 의 스크립틀릿에 작성된 코드는 Servlet 으로 변환될 때
					: 표현식의 경우 out.println( ) 으로 변환되어 들어간다
					: 선언문의 경우 멤버 메서드로 변환된다.
					: 일반 HTML 태그들은 out.write( ) 로 변환된다
					: page 디렉티브의 속성값들은 Servlet 으로 변환 시 참고할 정보로 활용된다

			3-2. 이미 요청됬었음 >> 바로 다음 단계로 넘어감
		
		4. "서블릿 컨테이너"에서 ( 해당 JSP 파일에 대한) 서블릿 클래스를 실행시켜 동적 웹 페이지를 생성하고, 이를 web server에게 반환한다
		5. web server 가 해당 페이지를 클라이언트에게 response 한다

	; JSP 문법
		: 

	: 톰캣 디렉터리 구조 ( JSP 구동 관련 ) 
		: https://velog.io/@ovan/Tomcat-%EA%B5%AC%EC%A1%B0
		: 톰캣 프로그램 디렉터리 ( C:\Program Files\Apache Software Foundation\Tomcat 10.1  )
			▼ bin  : 톰캣 실행/종료 역할을 하는 스크립트(.bat, .sh) 파일을 저장

			▼ conf  :  톰캣 서버의 설정에 대한 파일들을 저장 
			******▶  server.xml : Tomcat의 주 설정 파일. 
					: 서버설정 (커넥션명, 호스트명, 포트번호 등의 설정) 내용을 담음.

			▼ work  : jsp 파일을 Servlet 형태로 변환된 .java 파일과 .class 파일이 저장되있는 디렉터리
		******▼ webapps : 톰캣이 관리하는 웹 애플리케이션들이 위치하는 폴더
				: webapps 디렉터리의 자식 디렉터리는 한 애플리케이션이라 보면 되고, 이 자식디렉터리명은 contextPath 로 사용되어, URL 로 접근이 가능하다 . 각 자식 디렉터리마다 , URL 로 접근이 불가하여 금고 느낌으로 사용되는 "WEB-INF" 라는 디렉터리를 필수적으로 가진다. 그리고 이 WEB-INF 디렉터리는 "web.xml" 이란 파일을 꼭 가진다. 					:
				▼ ROOT : URL 상으로 "/" 경로일 떄 접근 가능하다.
					▼ WEB-INF : URL 로 접근이 불가한 톰캣의 금고
						▶ web.xml : 애플리케이션 별 "설정" 파일
							:  Servlet-mapping 등을 담음
							: 얘가 server.xml 처럼, 전역적으로 적용되는건 아니더라도, 엄연히 설정하는 역할을 한다.

				▼ 내가정한프젝폴더명 
					▶ 내가작성한파일명.jsp
					▼ WEB-INF 
						▶ web.xml



	: JSP 실습
		: 그냥 쓰면 한글이 깨지는 이유 >> <%@page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%> 를 축가하지 않았기 때문. 
			: 



WAS Web Application Server : Web Server + Web Container 
	: 웹 서버의 정적 데이터 처리 기능과, 웹 컨테이너의 동적 데이터 처리 기능을 모두 가진다.
	: 필요한 이유 >> 동적 컨텐츠를 만들기 위함
	: Web Server 
		1. 클라이언트와 통신하는 역할 . request 를 받고, 최종적인 response 를 하는 부분 
		2-1. 동적인 웹 페이지 생성이 필요할 시, request 를 Web Container 에게 위임하고, 결과를 반환받아 클라이언트에게 response 한다.다
		2-5. 정적인 웹 페이지의 경우 Web Server 가 바로 response 한다.

	: Web Container  >> Servlet Containter , JSP Container 
		: Servlet, JSP를 실행할 수 있는 소프트웨어. 즉, 동적 데이터 처리 기능을 보유.
		: JSP 컨테이너 >> JSP 파일을 서블릿으로 변환 및 컴파일 까지 담당한다.  이후에는 Servlet 컨테이너가 담당한다.
		: Sevelt 컨테이너 >>Servlet 파일을 실행하여 , 동적 웹 페이지를 생성해낸다.


Apache Tomcat : WAS 역할 수행.
	: 동적인 데이터 처리를 위해 자바 서블릿이 실행될 수 있는 웹 컨테이너(서블릿 컨테이너) 환경을 제공. 
	






CPU 와 IO
	: CPU 는 빠르고, I/O 는 느리다. >> CPU 의 속도는 I/O의 100만배이다.
	: CPU Central Processing Unit
		: 컴퓨터의 중앙 처리 장치로, 모든 연산과 명령어 실행을 담당. 컴퓨터의 '두뇌'.
		: CPU는 프로세"서" 라고도 칭한다.
			: 멀티 프로세서 >> n 개의 cpu 가 사용됨.
			: 사장님느낌

		: '코어 core' >> 실제로 연산을 수행하는, 물리적인 연산회로유닛
			: CPU 와 Core 는 (1:1에서) 1:n 으로 발전함, 그러니까 CPU 하나당 core 는 여러개.
			: 멀티 코어 프로세서 >> n 개의 코어를 가지는 하나의 cpu.
			: 직원 느낌

		: ( cpu 측면에서의 . 하드웨어 측면에서의. ) thread >> 논리적으로 core 가 할 수 있는 최소 단위의 작업 혹은 그 작업을 처리 할 수 있는 도구. 
			: 하나의 core 마다 기본적으로 1개의 thread 를 보유
			: 하이퍼 스레딩 hyper-threading >> 하나의 코어가 n 개의 thread 를 보유
			: 직원의 모니터 느낌

		:https://iosdevlime.tistory.com/entry/iOSCombine-CPU%EC%99%80-%EC%BD%94%EC%96%B4-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EA%B0%9C%EB%85%90


 		: 구성 >> 레지스터(고속메모리)+ ALU + CU
		: 작업 단위>> 프로세스나 쓰레드 단위
		: 작업 속도 >> 매우 빠르게 동작.
			: CPU 바운드 작업은 주로 계산과 관련된 작업이지, I/O 작업이 거의 필요하지 않기 떄문.
				:  CPU 바운드 작업 == CPU 에 큰 부하를 주는 작업

	: I/O Input/Output 
		: 컴퓨터와 외부 환경 간의데이터 교환을 담당하는 장치 및 시스템으로. CPU에게 처리해야 하는 데이터를 제공하고, CPU의 처리 결과를 사용자에게 전달한다.
		: 입력장치는 키보드같은거. 출력 장치는 모니터 같은거.
		: 작업 단위 >> 데이터 블록 단위로
		: 작업 속도 >> 매우 느리게 동작.
			: I/O 바운드 작업 주로 데이터 읽기/쓰기와 관련된 작업이라, 속도가 많이 느림.
				:  I/O 바운드 작업 == I/O 에 큰 부하를 주는 프로그램

******: CPU와 I/O의 속도 차이 국복 >> 멀티"쓰레딩"을 통해 CPU가 I/O 대기 시간 동안 다른 연산을 수행하도록 할 수 있다.







프로세스와 쓰레드
	: 프로세스 process >> 운영체제로부터 자원을 할당받은 "작업의 단위" . 컴퓨터에서 돌아가고 있는 프로그램 하나.
		: (정적) 프로그램 Static Program >> 컴퓨터에서 실행 할 수 있는, 하지만 현재 실행 중이진 않은(= 파일이 저장 장치에 있지만 메모리에는 올라가 있지 않은 ) 파일. 그러니까 코드 덩어리.


		: 프로세스 >> 컴퓨터에서 작업 중인, 돌아가고 있는 (= 메모리에 적재되고 CPU 자원을 할당받아 실행되고 있는) 프로그램. 그러니까 코드 덩어리를 실행한 것.
			: 작업관리자에서 확인가능
			: 모든 프로그램은 메모리 공간을 할당해 줘야 실행될 수 있다 >>  프로그램 파일이 컴퓨터 메모리에 올라가고, 운영체제로부터 시스템 자원(CPU)을 할당받고서야 실행된다.

		
		: 프로세"서" >> CPU 와 같은 하드웨어. 프로세스를 실행시키는 주체.

		: 프로세스의 자료 구조 >> 
		    : 코드/데이터 영역은 "정적"영역  이지만, 스택/힙영역은 "동적"영역(=프로그램이 실행되는 동안 늘었다 줄었다 한다 .) 이다.
		    : 암기 tip >> SHCD 씁하시다
			(1) 코드 영역 : 작성한 프로그래밍 코드가 기계어의 형태(= cpu가 해석 가능한 형태)로 저장되어있다
			(2) 데이터 영역 : 코드가 실행 중 사용되는 전역 변수 또는 static 변수 등의  각종 데이터가 저장되어있다.
			(3) 스택 영역 :  속한 함수의 종료와 함께 삭제시킬, 지역 변수와 같은, 임시적인 자료를 저장하는 공간
				: stack 은 함수 호출마다 할당(생성)되며, 함수 소멸과 함께 소멸됨.
				: stack 영역 초과 시 stack overflow 에러 발생

			(4) 힙 영역 : 프로그래머가 필요할 때마다 사용하는 메모리 영역. 객체 같은 데이터가 저장되는 공간.
				: 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨

		:  각 프로세스는 별도의 메모리에서 실행되기 때문에, 기본적으론 프로세스 끼리는 다른 프로세스와 공유하는게 없고, 서로의 메모리에 직접 접근할 수는 없다.


	: 스레드 thread >> 하나의 프로세스 내에서 동시에 진행되는 작업 갈래, 흐름의 단위. 하나의 프로세스가 할당 받은 자원을 이용하는 실행의 단위.
		: 크롬의 경우 노래 감상과 파일 다운등의 서로 다른 작업을 동시에 진행할 수 있다. 
		: 멀티(다중) 스레드  >> 하나의 프로세스 안에 여러 스레드가 존재하는 것.

		: 자료 구조 >>  스레드 마다 별도의 stack 영역을 가진다. 
		******: 스레드에게 code, data , heap 영역은  따로 없고, 자신이 속한 프로세스의 영역을 사용한다. 그러니까 같은 프로세스에 속한 스레드 끼리는 , 프로세스의 자원( code, data , heap )을 공유하게 된다.
		******: 독립적인 stack 을 가진다 == 독립적인 함수 호출이 가능하다 == 스레드별로 독립적인 실행 흐름을 가질 수 있다. >> 자원의 생성과 관리의 중복성을 최소화하여 수행 능력이 향상된다.
		: 주의 ) CPU의 쓰레드 != 프로세스의 쓰레드
			:  CPU의 쓰레드 >> 하드웨어적 스레드
			: 프로세스의 쓰레드 >> 소프트웨어적 스레드



멀티 프로세싱 vs 멀티 태스킹 vs 멀티 스레딩
	: https://sorjfkrh5078.tistory.com/56
	: 멀티 프로세싱 >> 여러 프로세"서"(cpu) 를 사용하여 하나의 프로세"스"를 병렬 처리하는 것.
	: 멀티 태스킹 >> 하나의 CPU에서 여러 프로세스(프로그램)을 동시에 실행하는 것.
		:  운영체제의 스케줄링에 의해 "번갈아 가며" 수행하여 다수의 task 를 처리 하는 것처럼 보여지게 된다.
	: 멀티 스레딩 >> 하나의 프로세스 내부에서 여러 스레드가 돌아가는 것.


멀티 태스킹 multi tasking :  하나의 CPU에서  여러 프로세스를 동시에 실행하는 것.
	: 하이퍼스레딩(Hyper-Threading) 기술 >> 하나의 유닛이 논리적으로는 n개의 유닛 역할을 수행하는 것. 멀티 태스킹을 구현하는 방법.
		ex ) 4코어 8쓰레드 CPU : 물리적으로는 코어를 4개를 가지지만, 논리적으로는 8개의 코어를 가지는 CPU. 그러니까 하나의 물리적 코어가 2개의 코어 역할을 수행하는 CPU.
		: 코어 >> 명령어를 메모리에서 뽑아 해석하고 실행하는 반도체 유닛

	:  수십수백개의 프로세스들을 고작 n개의 논리적인 스레드도 어떻게 처리하는 걸까 >> CPU 의 특성인 병렬성(Parallelism) 과 동시성(Concurrency) 때문
	1. 병렬성 Parallelism >> 각 코어는 병렬적으로 작업을 수행. (정말로) 동시에 처리.
	2. 동시성 Concurrency >> 둘 이상의 작업이 동시에 실행되는 것"처럼"보이도록 작업들을 스위칭 하며 처리.
		: CPU 자체는 한번에 하나의 프로세스만 실행 가능하다.
	ex ) 1개의 코어가 있고 4개의 작업이 있다고 가정: 하나의 코어가 프로세스들을 ​계속 번갈아가면서 조금씩 처리함으로써, 마치 4개의 프로그램이 동시에 실행되는 것 처럼 보임. 





컨텍스트 스위칭 Context Switching : CPU가 한 프로세스에서 다른 프로세스로 전환할 때 발생하는 일련의 과정
	:  동작 중인 프로세스를 중지하고 다른 프로세스를 실행하기 전,  해당 프로세스의 상태(Context)를 보관하고, 실행할 다른 프로세스를 실행하기 위해 context 에 보관해두었던 해당 프로세스의 상태를 복구하는 작업.

	: PCB Proccess Control Block 이란 자료 구조로 보관(저장)이 된다.
		: PCB >> Pointer( 프로세스의 현재 위치) + Process state + PID ... 등의 구성으로 이뤄짐.

	: Context Switching Overhead >> 프로세스 스위칭 하는데 비용이 많이 드는 것.
	


스레드 컨텍스트 스위칭 Thread context switching : 멀티 스레딩 환경에서, 하나의 프로세스 내의 스레드들의 실행을 전환하는 기술
	: 스레드는 TCB Thread Control Block 이란 자료구조로 보관 (저장) 이 된다.
		: TCB 는 PCB 안에 들어있다. 스레드가 프로세스 내에 위치한 것처럼.
		: 컨텍스트에 저장할 때 뿐 아니라, 스레드 간의 자원 공유 및 동기화 할 때도 해당 자료구조를 하용한다.




동시성 프로그래밍 과 Queue 
	: 동시성 프로그래밍 Concurreny Programming >> CPU 가 그의 특성인 parallelism 과 concurrency 에 따라서 동시에 작업을 하는 것처럼 보이게 처리 하는 것
		: 필요성 >> 수백 , 수천 개의 코어를 직접 CPU 에 탑재할 순 없으니, 한정된 수의 코어로 동시에 처리하는 것과 같은 효과를 내는 것이다. 그리고 중간중간 context switching 하는 것은, switching 없이 테스크를 쭉 처리하게 되면, 앞의 무거운 테스크를 수행하느라 뒤의 가벼운 테스크가 수행되지 못하는 비효율적인 상황이 발생할 수 있게 되기 때문이다.


	: Queue
		: 동시성 프로그래밍에서 하드웨어적 스레드에게 테스크를 분배해주는. 그러니까 스케줄링을 담당하는 주체.
		: 선입선출(FIFO) 방식으로 동작한다 
			: 주의 >> 먼저 배치된 테스크라고, 먼저 "종료" 되는것은 아니다
		
	: https://iosdevlime.tistory.com/entry/iOSCombine-%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1%EA%B3%BC-Queue%ED%81%90%EC%9D%98-%EC%97%AD%ED%95%A0






인터프리터 기반 서버 프로그래밍
	: 서버에서 소스 코드를 실행할 때, 미리 컴파일 하지 않고 실행할 때 한 줄 씩 해석하면서 실행하는 방식
		: python , php , js 등 이 인터프리터 언어이다

	: 교수님이 뭔 의미로 노션에 굳이 '인터프리터 기반 서버 프로그래밍'을 언급하면서 '하나의 인터프리터 프로세스' 로 처리하자는지는 모르겠으나 , 어쨌뜬 확실히 전하고자 하시는 바는 최대한 다중 프로세스가 아닌 "단일 프로세스"를 지향하자는 거다. 



	

----------------------------- ▼ 살짝 오버 내용 


프로세스 상태 : 프로세스가 생성되고, 실행 종료하기까지 크게 다음과 같은 5가지 상태를 가진다.
	: OS 의 "프로세스 스케줄링"에  의해 상태가 전이되게 된다. 
		: 운영체제 >> 프로세스와 스레드의 생명주기를 관리하여, 시스템 자원을 효율적으로 사용하게 한다.
		: 프로세스 스케줄링 >>  운영체제가 프로세스를 선택하여, CPU 를 할당하는 작업
			: CPU 를 할당하는 순서는 다양한 알고리즘을 통해 정해짐

	(1) 생성 new : 프로세스가 생성된 상태.
	(2) 준비 ready: 프로세스가 실행 대기 중인 상태. 언제든지 CPU를 할당 받을 수 있는 상태.
	(3) 실행 running: 프로세스가 CPU를 할당받아 실행 중인 상태
	(4) 대기 waiting : 프로세스 실행 중 특정 작업이 끝나기를 대기하는 상태
		: 그러니까 "입출력요청" 과 같은 "특정이벤트" 가 발생하여 대기타는 상태
		: 이 상태 동안은 CPU 를 할당 받지 못한다
		: 해당 이벤트를 마치면, 다시 ready 상태로 전환된다. (다시 cpu 할당 받기를 대기타게된다.)
	(5) 종료 terminate : 프로세스 실행을 완료하고 종료된 상태. 메모리에서 제거되는 상태




스레드 상태 : 스레드가 생성되고, 소멸되기 까지 크게 담과 같은 4가지 상태를 가짐
	: OS 의 "스레드 스케줄링"에  의해 상태가 전이되게 된다. 
		: 스레드 스케줄링 >>  운영체제가 스레드를 선택하여, CPU 를 할당하는 작업
			: 스레드 스케줄링은 하나의 프로세스 내에서 다수의 스레드가 동작하는 형태이기 때문에, 프로세스 스케줄링과는 다르게 스레드 간의 상호작용과 동기화 문제까지 고려해야 한다

	(1) new : 스레드가 생성되고 아직 호출되지 않은 상태 
	(2) runnable : 스레드가 실행 대기 중인 상태 . 언제든지 cpu 를 할당 받을 수 있는 상태
	(3) blocked : 스레드 실행 중 특정 작업이 끝나기를 대기하는 상태
		: "입출력요청" 과 같은 "특정이벤트" 가 발생하여 대기타는 상태
		: 이 상태 동안은 CPU 를 할당 받지 못한다
		: 해당 이벤트를 마치면, 다시 runnable 상태로 전환된다. (다시 cpu 할당 받기를 대기타게된다.)
	(4) terminate : 스레드가 실행 완료하고 종료된 상태. 메모리에서 제거된다.



