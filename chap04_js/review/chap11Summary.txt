비트맵 Bitmap 과 벡터 Vector
	: Bitmap >> 서로 다른 점(픽셀)들의 조합으로 그려지는 이미지 표현 방식
		: 확대하면 깨지지만, 복잡한 그림 표현해도 컴퓨터에 부담이 덜 하다
		: .jpg, .jpeg, .png, .gif 등이 비트맵 방식의 파일

	: Vector >>  점과 점을 연결해 수학적 원리로 그림을 그려 표현하는 방식
		: 확대해도 깨지지 않지만, 복잡한 그림 표현하면 컴퓨터에 부담이 많이간다
		:  .svg  등이 벡터 방식의 파일

-------------------------------------------------------------------------------------------------------

베지어 곡선 : 4개의 제어점 안에 그려지는 3차 곡선
	: https://www.youtube.com/watch?v=pnYccz1Ha34

-------------------------------------------------------------------------------------------------------


웹에서 그래픽을 표현하는 기술 
    1. canvas 
	: HTML 의 <canvas> 요소로 생성되고, 이 자체는 사각 형태의 영역. 이 영역에 그리는 것은 JS 코드로 처리.
	:  비트맵 기반 렌더링 >>  "복잡한" 프레임을 "빠르게" 렌더링 가능

	: 캔버스 좌표계 >>  "캔버스 영역"의 좌측상단이 ( 0, 0 )이고 아래로 갈수록 y 가 증가하고, 오른쪽으로 갈수록 x 가 증가한다

	: JS 로 캔버스에 그리기
		: 컨텍스트 객체 context >> canvas 요소에 그림 그리는 역할을 한다
			: 얻는 법 ) 
				1. 일단 canvas 요소 객체를 얻는다 
				2. 얻은 canvas 요소 객체를 대상으로 getContext("2d") 를 사용한다
					: 2d 인건 브라우저 화면이 2d 이지 3d 는 아니니까... 
					: ex ) 
						let canvas = document.getElementById("myCanvas");
						let context = canvas.getContext("2d");

			:  속성
				(1) fiiStyle :  채울 색상을 결정한다
					ex ) 
       					 context.fillStyle = "orange";
     					 context.fillRect(50, 50, 100, 50);

				(2) storkeStyle : 윤곽선 색 결정
					: 참고로 stroke 는 뇌졸중 뿐 아니라 , '획' 이라는 뜻도 가지고 있다
				(3) lineWidth : 직선  너비 설정
				(4) lineDashOffset : 현재 위치에서 얼마나 떨어진 곳에서 직선 그리기를 시작할건가 결정

 			: 함수
			    1. cavas 위에 직접 그리는 것 관련
				(1) fillRect( x, y, width , height) : 채워진 직사각형 그린다 	
				(2) strokeRect( x, y , width, height ) : 직사각형의 윤곽선만 그린다 
				(3) clearRect( x, y, width , height) : 해당 직사각형 영역을 지운다
 
			    2. path 사용해 그리는 것 관련
				(-3) beginPath( ) : 새로운 경로 생성
					: 이전에 그린 내역 이제 싹 다 버리고, 새롭게 그릴 준비한다. 
					: 어떤 점에서 그릴지까지 결정 가능한건 아니고, 이 이후에 moveTo(x , y) 를 통해 그리기 시작할 점을 잡아준다.
				(-2) setLineDash( [ 선의길이, 공백길이 ] ) : 직선 모양 설정
				(-1) lineTo( x, y ) : 펜을 떼지 않고, (직선모양으로 ) 해당 좌표로 이동
				(0) arc( x, y , radius, startAngle, endAngle, antiClockwise여부 ) : 펜을 떼지 않고, (곡선 모양으로 ) 해당 좌표로 이동
					: radius(반지름) >> 
					: startAngle, endAngle >> 곡선 시작||종료 각도 
						: 주로 n *  Math.PI 꼴
							2.0 * Math.PI >> 360º
							1.5 * Math.PI >> 270º
							1* Math.PI >> 180º
							Math.PI >> 90º

					: antiClockwise >> 반시계로 그릴 지
				(1) bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) : 펜을 떼지 않고, (베지어 곡선 모양으로, 그러니까 3차 곡선모양으로 ) 해당 좌표로 이동
					: 현재 지점을 시작지점 으로 하고, arg 로 넣은 첫번째 두번쨰 좌표를 Control point 로, 마지막에 넣은 좌표를 끝 지점으로 하여 삼차 베지어 곡선을 그린다
					
				(2) rect( x, y, width , height ) :  펜을 떼지 않고, (직사각형 모양으로 ) 해당 좌표로 이동
					: 이것 자체로는 그린게 보이지 않고, stroke( ) 나 fill( ) 필요
				(3) moveTo( x,y ) : 펜을 떼고(== 아무것도 그리지 않고 ), 해당 좌표로 이동
				(4) closePath( ) : 현재 경로의 시작 부분( == 처음으로 그려지기 시작한 점 != beginPath( ) 부분 )과 끝부분(== 마지막으로 그려진 점 )을 "직선" 으로 연결하여 경로를 닫는다
				******:  fill() 메서드 사용 시 자동으로 닫히게되어 closePath() 하든 안하든 상관 없지만 , stroke( ) 활용하는데 경로를 닫고 싶다면(=시작과 끝을 잇고 싶다면) closePath( ) 를 해주어야된다. ( 물론 시작과 끝을 잇기 싫음 걍 안함 된다.)
						: https://blog.naver.com/phlox__/221223871826
						: https://stackoverflow.com/questions/22852071/what-does-beginpath-and-closepath-do-exactly

				(5) stroke( ) : 경로로 만들어진 도형을 윤곽선만 그린다.
				******: 그러니까 stroke( ) 하지 않으면 , 아무리 열심히 그렸어도 그린게 보이지 않는다
				(6) fill( ) : 경로로 만들어진 도형을 채워서 그린다
 

			: 그리는 법
				(1) 도형을 직접 그리기 >> fillStyle & fillRect  || strokeRect 을 이용
				****** : 주의 - 사각형만 가능하고, 이외 도형은 모두 방법 (2) 를 사용해야됨

				(2) 빈 경로(path) 를 만들고, 그리기 명령을 축적한 후 한번에 캔버스에 그리기
					: 경로 path >> 점들의 집합. 그러니까 도형과 (곡)선을 포함하는 개념


	: Canvas API >> canvas 요소 기반 그래픽을 제공하는 "라이브러리"	

	: 추천 사례
		1. 실시간으로 업데이트가 많이 필요 (== 동적임)
		2. 상호작용 많음
		3. "많은" 그래픽 요소를 빠르게 그려야 할 때(== 고성능의 그래픽처리)

    2. svg ( Scalable Vector Graphics ) 
	: XML 기반의 "벡터" 그래픽을 정의하기 위한 "언어"	
	: 확대해도 안깨진다 >> 도형의 크기 조정/변경/회전 등이 용이
	: DOM 의 일부로 작동한다 
		: CSS 스타일링 및 JS 언어를 사용한 조작이 가능 >> 개별 요소 접근이 가능
	: 추천하지 "않는" 사례 >> 고성능의(=복잡한) 그래픽 처리가 필요한 경우. ( svg 요소가 많으면 성능 저하를 일으킬 수 있다. )



