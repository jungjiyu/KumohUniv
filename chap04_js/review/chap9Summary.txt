--- 9장 복습 ---


[ ] vs { } 
	 {}는 객체(Object)를 생성
	 []는 배열(Array)을 생성

Truthy 값 : 참으로 간주되는 값. 
	: 그러니까 if 문 내부 넣었을 때 해당 if 문이 실행되게 하는 값
	: 0 아닌 숫자 << 음수도 ok
	: 객체  << { } , [ ] 같은 빈 배열도 ok 
******: 비어있지 않은 문자열 << 'false' 도 참이다



falsy값 : 거짓간주값
******: 빈 문자열  << null 이 아니라고 해서 true 가 아님 주의 . 자바스크립트에선 문자열 자체는 기본적으로 객체가 아니다 !!!!!
	: 숫자 0



BOM Browser Object Model
	: 웹 브라우저를 객체로 표현한 것
	: 얘도 DOM 처럼 트리구조
	: 최상위 노드는 "window"
		: 그 밑으로 "document" , history 등등이 있다



DOM(Document Object Model) 
	: 자바스크립트로 간편하게 HTML 문서에 접근하여 수정할 수 있도록 HTML 요소를 "객체화"해놓은것
		: 자바스크립트가 조리도구, DOM/BOM 은 요리재료
	: HTML 문서의 계층적 구조를 트리로 표현한 것
	: 웹 페이지가 로드 >> DOM 생성 >> DOM 을 순회하며 렌더링
	: 최상위 노드는 "document" << "<HTML>" 이 아님!
		: 그 밑으로 <html> , <head>, <body>, <h1> 등의 요소를 나타내는 노드가 있음

주의 >> window. 은 명시 안해도 되지만 document. 는 명시해야된다








NodeList 와 HTMLCollection
    : NodeList >> 모든 타입의 노드들
    : HTMLCollection  >> html 요소 타입의 노드들
	: 노드 변경사항이 실시간 반영

Node
    : https://velog.io/@km2535/%EA%B0%95%EC%9D%98Javascript-document%EA%B0%9D%EC%B2%B4-%EB%85%B8%EB%93%9C-%ED%8F%BC-%EA%B0%9D%EC%B2%B4-%ED%8F%BC%EC%9D%98-%EC%A0%91%EA%B7%BC-input-%ED%83%9C%EA%B7%B8-%EC%A0%91%EA%B7%BC
    : 종류. 타입.
	(1) 문서 노드(document)
	(2) 요소 노드(element) : HTML 요소는 요소 노드이며 attribute 노드를 가질 수 있는 유일한 노드 
	(3) 속성 노드(attribute) : HTML 요소의 속성에 대한 노드
	(4) 텍스트 노드(text) : HTML 문서의 모든 텍스트
		: innerHTML "이외"의 텍스트. 그러니까 특정 태그로 감싸지지 않은, 코드상에 혼자 돌아다니는 텍스트들
	********: 코드의 가독성을 높이기 위한 엔터 또한 텍스트 노드로 간주된다
	(5) 주석 노드(comment) : HTML 문서의 모든 주석

   : 노드 객체 자체 >>  [object Text] ,  [object HTMLLIElement] 와 같이 불친절하게 나온다
   : 노드 객체의 프로퍼티
	.nodeType >> 노드의 타입을 숫자로 반환. 읽기 전용이고, 수정은 불가
	    : 요소 노드 - 1
	    : 속성 노드 - 2
	    : 텍스트 노드 - 3
	    : 주석 노드 - 8
	    : 문서 노드 - 9
	   
 	.nodeName >> 노드의 고유이름( '#document' , '태그명' , '속성명', '#text' )을 반환.  읽기 전용이고, 수정은 불가.
	    : 솔직히 걍 nodeType 의 문자열 버전이라 봄 될 듯

  	.nodeValue >>  노드의 값을 반환한다
	    : 모든 노드가 가지는 프로퍼티지만, document 노드와 주석 노드 같은 경우는 undefined 로 딱히 알아도 쓸모없는 값ㅇ르 반환한다
	    (1) 속성노드 - 해당속성에 할당된 값 반환
	    (2) 텍스트 노드 - 해당 텍스트 문자열



JS에서 부모, 자식, 형제 노드/요소 단위 탐색 가능하게 하는 속성들
    : 부모
	(1) parentNode :  부모 노드들을 반환
		: 그러니까 html 요소로 정의되있지 않더라도 dom 트리 상에 존재하는 부모 노드면 ok 란 말이다
	(2) parentElement : 부모 "요소" 노드들을 반환
		: 그러니까 html 의 요소로 존재하는 노드들만 부모로 취급된다는 말이다

    : 자식
	(1.0) childNode"s" :  자식 노드들을 반환 >> NodeList 타입으로
	(1.1) firstChild , lastChild : 첫 , 마지막 자식 노드  
	(2.0) children : 자식 "요소" 노드들 반환 >> HTMLCollection 타입으로
	(2.1) firstElementChild , lastElementChild : 첫, 마지막 자식 "요소" 노드

    : 형제 
	(1) previousSibling , nextSibling : 형제 노드를 반환
	(2) previousElementSibling , nextElementSibling : 형제 "요" 노드를 반환



js 변수의 타입 확인하는 법 >> typeof(변수명)


JS 로 HTML 요소 찾는법
	1. ID로 >> document.findeElementById("id명")
	2. 태그명으로 >> document.getElement"s"ByTagName("찐태그명")
		: 해당 태그를 사용하는 모든 요소를 "배열"에 넣어서 반환한다
		: 받은 건 변수명[0] 과 같이 사용 가능하다
	3. 클래스명으로 >> 
	4. css 선택자로 >>찐으로 #아이디명, 태그명.클래스명 이런거 쓸 수 있다. 
		: id 바꿀때 "#id명" 인거 잊지 x
		(1)document.querySelector("css선택자") >> 해당 선택자를 만족하는 요소 단 하나만 반환. (여러개 있어도 첫번째 것만 get)
		(2) document.querySelectorAll("css선택자") >> 해당 선택자 만족하는 요소 모두 가져옴. "배열" 형태로






form 에서 < input type="button"> 과 <button> 과 <input type="submit">
	: https://365kim.tistory.com/64
	: <button> 의 경우 <input> 과 마찬가지로 type 속성을 가진다
		: <form> 태그의 자식 태그로 쓰일 경우 type 은 디폴트로 "submit"으로 지정된다. button 을 단순 button 의 용도로만 쓸 것이라면, 별도로 type="button" 을 명시해줘야된다
		: 클릭시 발생할 이벤트를 바인딩할 수 있는건 type="button" 일때만 가능하다. ( <input type="submit"> 이건 <button type="submit"> 이건 onXXX 속성은 명시 불가하다 )
	: <button> 의 경우 <input> 과 달리 끝태그가 필수적으로 필요하다
		ex)   <button type="button" name="btn" /> 으로 쓰면 안되고 <button type="button" name="btn">버튼에표시할내용</button> 으로 써야된다
	: <button> 의 경우 <input> 과 달리 value 속성이 없다
		: 버튼상에 표시하고 싶은 내용은 시작태그와 끝태그 사이에 적는다

	: <input type="button"> 의 경우 value 속성이 있다




<select> 와 <option>
    : 드롭다운박스. 
    : option 의 속성으로 selected 을 명시하면 초기에는 해당 옵션이 선택된걸로 간주된다



특정 form 객체 얻는 법 >> 어케해서 form 객체를 구하든, 구한 form 객체를 대상으로 .내부자식명 으로 자식요소를 얻어낼 수 있다. !  ( 일반 객체에선 자식 요소 이렇게 함부로 못구하는거 주의 )
	sol(1) 직접 id 로 읽어오기
	sol(2) forms 객체 활용
		: document 객체에는 form "태그", 즉 document 객체 내부 모든 form 요소"들"에 대응되는 form"s" 라는 "배열" 객체가 있다. 
		sol1. 찐 배열처럼 사용 >> document.forms[ n ] 
		sol2. 얼추 배열처럼 사용 >> document.forms[ '해당폼요소의name명' ]
		sol3. form 의 "name"으로 접근 >> document.forms.폼네임
			ex)  
				<form name="my">
					...
				</form>

	sol(3) 사실 form 의 name 을 직방으로 해서 구할 수도 있다
		ex ) 
			<form name="myform">
			. . . 
			</form>
			
			일때
			
			document.formname명으로 form 객체 얻을 수 있다



form 객체에서 내부 자식 요소 뽑아내는 법 
    : form 객체를 나타내는 경우 this에도 적용 가
    (1) 구한폼객체명.elements.자식name명 
    (2) 구한폼객체명.자식name명
    (3) 구한폼객체명["자식name명"]
	

form 객체의 자식 요소 값 얻는 방법 >> 대부분의 form 자식 태그들은 value 속성에 값을 담게 되므로 .vlaue 를 이용하여 get 가

기타 form 관련
	: : https://ko.javascript.info/form-elements
	(1) textarea 의 요소 값 구할 때도 .value 쓴다
		ex)  let s = document.getElementById('textArea').value

	(2) 체크박스나 라디오의 경우 .checked 속성 사용가능
		ex )
		if (document.getElementById('myCheckBox').checked) {
		document.getElementById('result').value = '동의하셨습니다.' } 


	(3) selectedList(드롭다운 박스)에서 .selectedIndex 속성으로 체크된 인덱스를 구할 수 있다	
		ex ) let selected = document.getElementById('myList').selectedIndex;


	(4) selectedList 는 배열이고, 특정 요소에 .options[인덱스]로 접근 가능
		ex) let s = elt.options[2].value





HTML 요소 "변경"하기
	: 변경 가능한 것 >> 주의 : 해당 HTML 문서 자체가 바뀌는게 아니라 "DOM"만 수정되는거다. 원본은 그대로다. 
		(1) 요소 내부 내용 >>  .innerHTML , .innerText, .textContent 
		.innerHTML vs .innerText vs .textContent
			innerHTML >> 해당 요소 사이의 문자열을 HTML 문장 취급
				: innerHTML은 요소 생성도 가능하다
			innerText >>해당 요소 사이의 문자열을 일반 텍스트 문장 취급 && 사용자에게 보여지지 않으면 빈문자열 추출됨
			textContent >> 해당 요소 사이의 문자열을 일반 텍스트 문장 취급 && 사용자에게 보여지지 않아도 해당 문자열 추출됨

		(2) 요소의 속성 >> .속성명
			ex ) .value : 해당 요소의 value 속성 값을 가져온다.

		(3) 요소의 스타일 >> .style.스타일속성명
			ex ) document.getElementById('hehe').style.color = 'blue';

	******(4) 요소의 클래스 >> 
			sol1. .className = "클래스명1 클래스명2 .. "
				: 주의 >> 기존에 할당되었던 클래스는 삭제된다. wirte 느낌
			******: 모든 클래스 한번에 없애기 >> .className = ''
			sol2. classList.add("클래스명1 클래스명2 .. ")
				: 이건 기존에 할당되었던걸 유지한다. append 느낌

			sol3.classList.remove("특정클래스명")
 				: 특정 클래스 삭제

			sol4. .classList.toggle("특정클래스명")
				: 있으면 없애고 없으면 추가하고

HTML 요소 생성하기 
	(1) 특정 요소 껍데기만 생성: document.createElement('태그명');
		ex ) let newNode=document.createElement('p'); // <p></p> 생성

	(2) (요소 안에 들어갈 구체적인 내용까지)전체적으로 생성 : document.write('어쩌구')

HTML 요소 추가하기 >> 특정요소1.appendChild( 특정요소2) 
		: 특정요소1의 자식으로 arg 노드를 추가한다.
		ex) 
		let parent = document.getElementById('target');
		parent.appendChild(newNode);
 
기존 HTML 요소 삭제하기 >> 특정요소1.removeChild( 특정요소2 );
	: 기존 특정요소1 내부에 있던 arg요소를 삭제한다

기존 HTML 요소 대체하기 >> 특정요소1. replaceChild( 특정요소2, 새요소);
	: 기존 특정요소1 내부에 있던 특정요소2 를 새요소로 대체한다
	

유명한속성값
	.length >> 배열, 문자열의 길이

-----------------------------------------------------------------------------------------------------
	
헷갈릴만한 코드
	(1) for 문 헤드 부분에 변수 여러개 선언 가능
	    for ( let i = 0, length = allItems.length ; i < length; i++) {
   	       alert( allItems[i].innerHTML )
  	      }


	(2) alert창이 "먼저" 뜨고 최종적으로 화면에 그려진다. (리스트가)
<!DOCTYPE >
<html>
<body>
  <ul>
    <li>List item 1</li>
    <li>List item 2</li>
    <li>List item 3</li>
    <li>List item 4</li>
    <li>List item 5</li>
  </ul>
  <script>
    let list = document.getElementsByTagName('ul')[0]
    let allItems = list.getElementsByTagName('li')

    for (let i = 0, length = allItems.length; i < length; i++) {
      alert(allItems[i].innerHTML)
    }
  </script>
</body>
</html>


	(2)  html 내부에 문자열을 주입 가능하다 && 요소 내부에 들어가는 문자열을 HTML 문장 취급하려면 .innerHTML 을 써야지, innerText 나 .textContent 를 쓰면 안된다.

<!DOCTYPE html>
<html lang="ko">
<head>
  </head>
<body>
  <h1>childNodes 사용법</h1>
  <div id="container">
    <p>First paragraph</p>
    <p>Second paragraph</p>
    <p>Third paragraph</p>
  </div>

  <button id="showChildren">Show childNodes</button>
  <div id="output"></div>

  <script>
    function listChildNodes() {
      const container = document.getElementById('container')
      const output = document.getElementById('output')
      let htmlContent = '<ul>' // 문자열 스따뚜

      container.childNodes.forEach(node => {
        let textContent = node.textContent.trim( ) // 이걸 textContent 가 아니라 innerHTML 로 해도되긴 한데 그럴 경우 innerHTML 은 아무 내용 없을 떄 빈 문자열이 아니라 아예 undfined 를 반환하므로 밑에 if 문 내부에 집어넣어야됨.
        if (textContent) {
          htmlContent += `<li>${node.textContent}</li>` // 문자열 연산
        }
      })

      htmlContent += '</ul>' // 문자열 끝
      output.innerHTML = htmlContent // 문자열 삽입 . 이떄 꼭 innerHTML 이어야됨 주의!
    }

    document
      .getElementById('showChildren')
      .addEventListener('click', listChildNodes)
  </script>
</body>
</html>



	(3) form 요소 객체에선 자식 요소name 명으로 쉽게 접근 가능하지만 일반 요소객체에선 자식요소 그렇게쉽게 못구한다
<!DOCTYPE >
<html>
<head>
  <script>
    function process() {

     let obj = document.getElementById('mymy'); // ==  document.myform.text1 == document.forms['myform'].text1;  == document.myform.text1; 
     console.log(obj);
    obj = obj.text1;
      alert(obj.value);

  //    obj = document.getElementById('hoho').jaja.value; 는 안된다.
      alert(obj);
    }
  </script>
</head>
<body>
  <form name="myform" id="mymy">
    <input type="text" id="target" name="text1" />
    <input type="submit" value="제출" onclick="process()" />
  </form>

  <div id="hoho">
    <span id="jaja"></span>
  </div>
</body>
</html>


	(4) selectList (dropdownlist) 에는 selectedIndex 라는 속성이 있다
<!DOCTYPE html>
<html lang="en">
  <head>
    <script>
      function getValue() {
        let elt = document.getElementById('myList')

        let selected = elt.selectedIndex
        let s = elt.options[selected].value
        document.getElementById('result').value = s
      }
    </script>
  </head>
  <body>
    <select id="myList">
      <option value="학생">학생</option>
      <option value="직장인" SELECTED>직장인</option>
      <option value="전문직">전문직</option>
      <option value="무직">무직</option>
    </select>
    <input type="button" onClick="getValue()" value="클릭" />
    <input type="text" id="result" value="" />
  </body>
</html>


	
