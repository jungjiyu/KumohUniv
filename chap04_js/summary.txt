요즘엔 var 로 변수 선언 잘 안한다. let 이란걸 사용해야된다
const : 상수 선언
변수 선언 보다는 상수 선언을 추천한다. 상수 선언이 불가한 경우 let 을 이용해 변수 선언해라

  console.log( 어쩌구 ) ; >> 다른 언어의 print 와 유사한 기능

innerHTML  , outerHTML 
	: outerHTML >> 태그를 감싸는 것까지 같이 본다

딱히 type cast 없다. 
동적인거 >> assign 할 수 있다
undefined : 초기화 안된거
typeof : 변수의 타입을 명시

수치형 : 정수, 실수, non 모두 가능
	NaN : Not A Number
		: parseInt("안녕하세요"), 100/0 같은거 해도 프로그램이 죽지 않고 NaN 이라는 값이 들어간다
		: isNaN( ) 을 활용하여 해당 값이 NaN 인지 아닌지 알 수 있다


문자열 연산 + 를 사용할 수 있다

백틱 `
	: esc 밑에 있는 거
	: f 를 앞에 쓰고 `문자열{ 변수} 어쩌구{ 변수}  ` 하면 printf 처럼 format 할 수 있다. ? ${ } 로 구성된다? 
	: 일반적인 따옴표(' ") 와 방향이 반대라서 백 틱이라고 한다


객체
	: 사물의 속성attribute 와 동작을 묶어서 표현
	: 객체.속성명 으로 접근 가능
	: js 는 원래 객체 라는 개념이 없는데 (딕셔너리를 사용하여) 객체를 사용하는 거다

연산자 : 다 쓸 수 있다
	: 그런데 + 연산자의 경우 주의해야한다. 일반적인 + 의 경우 교환법칙이 성립해야하지면 여기선 안그렇다. 문자열과 붙어있는 얘들은 먼저 변한다
		: 문자열+ 숫자1 + 숫자2 == "문자열숫자1숫자2"
		:숫자1 + 숫자2+ 문자열 ==


비교연산자	
	: == 와 ===
		== : 맥락상 값이 같으면 참
			ex) '1' == 1 >> true

		=== : 타입과 값이 모두 일치해야 참<< 우리는 이걸 써야된다. == 는 기존의 의미와 벗어나기 떄문에 헷갈릴 수 있어 사용을 지양해야된다
			ex) '1' === 1 >> false
		
	: != 와 !== 도 마찬가지다

prompt( )  : prompt("메시지", "디폴트값"); >> 문자열 반환
confirm() >>> true 혹은 flase 반환

parseInt >> 문자열을 "파싱" 해서 정수형으로 변환해주는거

 write( ) 를 하면 그전에 해당 페이지에 출력했던 내용이 다 사라진다.

getElementById( ) 
	: id를 기반으로 접근
	: 얘 자체는 해당 객체를 가져오는거고 그 객체의 값을 얻기 위해선 value 를 사용해야됨
	: 참고 >> getElementByTagname 같은건 div.ramen 같은걸 대상으로 할때 편하다

자바 스크립트의 함수
	: 함수 안에서 선언된 변순 함수의 생성과 함꼐 생성되고 종료와 함께 종료된다
	: 로컬 변수 같은 경우는 변수명 대충 지어도 되는데 전역 변수의 경우 정성껏 지어라


console.log( ) >> f12-console 선택해서 봐라


반복문
        let i = 0;
        for (i = 0; i < 10; i++)  과 같이 분리해서 적으면 안되고 
 	for (let i = 0; i < 10; i++) 와 같이 한꺼번에 써줘야된다

continue 문장: 가장 가까운 루프의 조건식을 다시 수행

***무명함수 :   함수 이름을 주지 않고 만들어서 한 번만 사용하는 경우도 많다.
	: 자바의 람다함수와 비슷
	: 이름 없는 변수를 선언하는 법 >> 이름 없이 함수를 선언하고 특정 변수에 그 함수를 할당함.

**화살표함수
	: 역사는 수업시간에 다루지 않음.
	: 익명 함수를 더 간단하게 쓰기 위해 도입한 것
	: 이것도 자바의 => 와 비슷한 거임
	: function sub (a,b){	== ( a, b ) => {return a+b; } ==  (a.b) => a+b;
		return a+b;
	}

	: 매개변수가 하나밖에 없으면 괄호 생략 가능
	: 리턴값을 화살표 다음에 쓴다
: 함수를 만들면서 호출하는 것.
((name) => console.log(`Hello, ${name}!`))('World');


지역변수와 전역 변수
	: 전역변수 >> 함수 외부에서 선언된 변수
	: 지역변수의 경우 let 은 정상적으로 지역변수처럼 작동이 되는데 var 은 ㅈㄴ 널널해서 지역변수라도 밖에서 접근 가능하다



객체 지향

자바스크립트에서의 객체
	1. 내장객체
		(1) DOM
		(2) BOM
	2. 사용자 정의 객체>> 자바의 클래스. c의 구조체 같은거

객체 생성할 떄 new 연산ㄴ자 사용
객체를 대상으로 접근 위해 도트 연산자 사용

자바스크립트에서는  기존 기능을 재활용해서 객체지향 흉내를 내는거지, 실제로 객체지향이 아니다. 
	: 원리 >> 파이썬의 dictionary 의 사용법.
	: 자바스크립트에서 완벽하게 객체지향 학습을 하려고 하지 말것

	: Index addressable array .vs. content addressable array
		:  Index addressable array >> [값1, 값2 값3 ... ]
			: 인덱스를 기반으로 찾ㅈ는다
		:  content addressable array >> { "키1":"값1","키2": "값2","키3": "값3" ... }	
			:  { 키1 :"값1", 키2 : "값2",키3: "값3" ... }	로 해도 되긴 한다. 그러면 자동으로 " " 붙여준다
			: 컨텐츠(키) 를 기반으로 찾느다.
			: 어떻게 지가 알아서 탁 갈까? >> hash function 을 사용한다.
			: 입력이 있으면 결과값이 있다. hash("mother") 의 갑을 get 해서 해당 값으로 배열에 접근한다.
			: 주의 ) 변수[키] 가 아닌 변수["키"] 로 찾아야된다
			: 변수.키 로도 접근 가능하다. >> 그러니까 객체의 속성을 정의하는 것이다.
				c에서 ary[1] 을 *(a+1) 로 내부적으로 수식해서 계산하는거랑 비슷하게 사실 변수["키"] 는 내부적으로 변수.키 라는 것이다.
 			: 이렇게 하는 경우 인덱스로 접근 못 함 주의


		: 사실 Object( ) 는 딕셔너리가 들어가ㅡㄴ거다

생성자 흉내내기 : this

대문자로 시작하는 함수 >> 클래스 이다.
	function User(name, isAdmin) >> User 은 클래스이다.


Date 객체
	: 많이 쓰인다
	: Date(2023, 7, 21, 18, 30, 0, 0); 에서 마지막은 ms


****2개의 날짜 비교하기
	: 2개의 날짜를 계산하는건 생각보다 어렵다
	: 

컴퓨터에서 시간을 재는 법 : 유닉스 시간. 타임
	: 유닉스 시간은 1970년 1월 1일을 기준으로 얼마나 많은 밀리초가 흘렀는지를 기준으로 한다.
	: 현재ms - 이전ms 한 값을 1000/24/60 .. 해서 얻는다.
	: floor >> 버림.
	: 재귀호출을 사용하여 계속 업데이트 한다


자바스크립트 디버깅하기
	: 여기서 수정하면 실제로 수정된다
	: f12- source - 작업공간-폴더추가 
		: 외부에서 로컬에 access 하는거라 별도의 허용이 필요
 
플레이 버튼 : 중간점까지 계쏙 실행
다음 단계로 넘어가라 : 함수 하나씩 수행
그함수안으로 들어가라
함수벗어나서다음으로가라


대부분의 버그는 단순 오타인 경우가 많다.

10만라인 짜리 코드라도 중단점 6~7 번만 찍어보면 에러 잡을 수 있다.
	: Binary serach >> 1/2 씩 감소
	: 구글에서는 binary tree 를 사용하여 0.xx 초 만에 결과를 찾는다.


-----------------------------------------------------------------------------------------------------------------------------------

== 쓰지 말고 === 써라

콘솔에 변수 치면 타입을 확인할 수 ㅇ있다

reg ex 의 결과로는 배열이 나온다

random( ) 은 0~1 난수임

round( ) 는 대충 뭐 그정도란 뜻으로 반올림

리터럴 : 직접적인 값

배열은 언제 쓰는가? >> 서버에서 데이터를 가지고 와서 어느 위치에다 그려준다. 목록의 형태로

중간중간 값이 정의되지 않으면 undifned 값이 들어간다

자바스크립트에선 배열 크기의 제한이 딱히 없다

배열에서 각각 다른 자료형의 요소를 넣을 수 있따


concatintate : 붙이는거
+ 연산자 자체는 문자열에 먹히지만 ary 에는 안먹히기 때문에 배열과 배열을 연결할 때는 concat  사용해야된다

push , pop : 삽입과 삭제
	: 스택처럼 쓰는거

shift( ) : 젤 앞에 추가
unshift( ) : 젤 앞에 추가

자바 스크립트의 sort 는 멍청하게 작동한다. 문자처럼 인식하고 정렬한 것이기 때문이다. 따로 숫자로 변환해서 정렬해야된다. 그래도 유용하다. 뭐든지 정렬할 수 있다. 괜히 sort 프로그램 따로 작성하지 ㅏ라.

filter( 조건 ) 해서 쓴다.

this 사용시 자동적으로 일어나는것
	1.  this = { } 생성
	2. return this

js 는 딕셔너리이기 대문에 기존 객체에 속성을 자유롭게 추가할 수 있고, 생성자도 그렇게 변경된다.

속성을 그냥 도트 연산자를 사용해서 추가 가능하단
 
 


 
상속
	: extends 키워드 사용해 상속한다
	: 상속 받은 것처럼 흉내낸다
	: 자바스크립트가 가비지 컬렉션 기반의 언어이기 때문에 'destructor'가 없다.
	: 다형성 polymorphism
		: 부모로 다양한 자식 받는거

Try-Catch 구조
	: runtime 오류 >> 실행하다 죽음
	: 오류처리
	: 일단 돌아야 방지를 하건 뭘 하건 할  수 있다.
	: 문장 별로 try  - catch 를 작성하는게 아니라 문제 있을만한거 몰빵한 다음에 catch 에서 if 로 세분화하는거


throw
	: 중첩 호출된 상황에서 당장 예외처리 안하면 다른 곳에서 처리 가능하다
	: catch 문 내부에서도 throw 사용 가능하다

eval( ) :  x=3*7 같은 수식을 계산해서 value 를 끄집어낸다


----------------------------------------------------------------------------------------------------------------------------

파싱 : 스트링 분석하는것

html 은 자식 2개 가진다. >> head, body


window 의 자식으로 document 가 있기 때문에 BOM 에 DOM 이 포함된다



HTML 요소 찾기
    ID로 HTML 요소 찾기 getElementById( )
    태그 이름으로 HTML 요소 찾기 getElementsByTagName() 
	: Element 가 아니라 Element"s" 임을 주의
	: 결과가 여러개라 배열로 받는게 좋다

    CSS 선택자로 HTML 요소 찾기 querySellectorAll( ) 
	: p.containter1 같은 것도 검색 가능해진다
		: # 이랑 . 기호 뺴먹지 마라
	: 젤 좋다. 이걸로 다 커버칠 수 있다.

    클래스 이름으로 HTML 요소 찾기 
    기타 childNodes[ ], nextSibling[ ], parentNode[ ]


Truthy 값.. >> true 비슷한 거

false 가 0 인건 c 따라한것

입력양식은 forms[i].elements[j] 혹은 form이름.input태그이름 으로도 접근 가능하다
	 form"s" 라는 객체
		: 해당 document 에 있는 form 들이 목록으로 되어있는거다
		: forms[0] == 0번째 form


그림으로 그리라하면 딕셔너리로 화살표 써서 그리는거다

checked 속성 같이 구체적인건 안내겠지만 어케 쓰는지는 알아야징


라디오는 [i] 처럼 인덱스적 접근이 가능하다


HTML 요소 변경하기
    요소의 내용( 시작 태그와 끝 태그 사이의 내용 ) 변경하기 >> innerHTML
    요소의 속성 변경하기 >> 객체.속성명
    요소의 스타일 변경하기 >> 객체.style.스타일속성명
    요소의 클래스 변경하기 >> 
	객체.className >> 클래스 통으로 적용됨
	객체.classList.add("특정클래스") >> 특정 클래스 추가
	객체.classList.remove("특정클래스") >> 특정 클래스 삭제
	객체.classList.toggle("특정클래스") >> 있으면 없애고 없으면 추가하고
 

-------------------------------------------------------------------------------------------------------------


디버그 하는 법 >> f12 - 소스 - 파일 추가
	: 안잡힐때는 코드에 직접 debugger 를 추가한다
	: 버그 잡을 떄 젤 중요한 것 >> 중간에 변수값이 잘 셋팅되나 보는 것
	: 버그 >> 내가 원하는 아웃풋이 안나오는 것
	: 문제 일어나는 부분을 잡아야된다 >> 중간에 잡고 점점 앞으로 범위를 좁힌다 (binary search 처럼 ). 라인 하나까지
	: 내가 굳이 일일이 print 안해도 옆에 떠서 확인이 편하다



Math.random()  >> 0~1 부동소수점범위

이벤트 >> ui 에서 사용자가 뭐 하는거
	: 이벤트는 큐에 쌓이고, 이벤트 헨들러한테 던져주면 실행된다
	: 생긴게 os 랑 비슷하다

blur >> focus 가 떠나는 것


이벤트 리스너 == 이벤트 헨들러


스크립트 내부에서 설정하는 방법
	1. 속성값으로 함수할당 >> 기존것은 사라진다. (가리키던 얘를 더이상 참조를 못하니까) . 여러개 설정 불가하다.
	2. addEventListener( ) 함수 사용 >> EventLister 를 "추가" 한다 . 기존 것은 사라지지 않는다. 여거래 설정 가능하다



이벤트 객체 >> 해당 이벤트에 관련된 모든 정보를 포함하는 객체
        alert(`${x} ${y} ${e.type} ${e.target}`) // e.type >> 이벤트 종류,  e.target>> 발생된 위치

비슷하다고 뭉쳐서ㅓ 만드는게 아니라, 비슷한 속성을 모아서 부모클래스로 만들고 그걸 상속받게 한다

UIEvent >> 화면관한
clipboard >> 복붙관한거

customEvent >> 사용자 정의 이벤트


target >> 사용자의 동작이 일어난 장소
currentTarget>> 이벤트 처리가 적용된 장소

stopPropagation >> 전파 금지. 다른 요소에게 까지 영향을 미치지 않는다
preventDefault >> 기본값 금지

screenX >> 스크린 전체 기준
clientX >> 요소 위치 기준

key >> 키 명 같은거
code >> 해당 키보드의 id 값 같은거

bubbling 과 capturing >> propagation 순서에 관한 것
	bubbling >> 안 -> 밖 . defualt 값
	capturing >> 밖 -> 안


-------------------------------------------------------------------------------------------------------------

자바스크립트와 파이썬에선 eval( ) 로 계산 가능하다
	: 인터프리터라서 가능

인라인으로 호출할 떄 사용하는 this는 해당 객체(요소)를 의미한다

mousedown : 누르는 과정
click : 클릭이 일어남
mouseup : 떼는 과정

mouseleave : 마우스 포인터가 해당 영역을 벗어남
mouseenter : 마우스 포인터가 해당 영역으로 들어옴

onmousemove : 여러번 일어나고 매번 (움직임의) 개수가 다르다


*****load 이벤트
	: 전체가 다 읽어왔을 떄 발생한다

IO 에서 읽어오는데 vs 메모리에서 읽어오는ㄷ ㅔ >>  100 만배 차이가 난다. ms 과 ns 간의 차이가 100만배이기 떄문 


사실 예제에서 script 문을 뒤로 옮겨도 잘 된다 >> 나중에 로드되니까


change 바뀐다의 기준 >> 포커스가 바깥으로 벗어났을 때




 

 


