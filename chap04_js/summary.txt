요즘엔 var 로 변수 선언 잘 안한다. let 이란걸 사용해야된다
const : 상수 선언
변수 선언 보다는 상수 선언을 추천한다. 상수 선언이 불가한 경우 let 을 이용해 변수 선언해라

  console.log( 어쩌구 ) ; >> 다른 언어의 print 와 유사한 기능

innerHTML  , outerHTML 
	: outerHTML >> 태그를 감싸는 것까지 같이 본다

딱히 type cast 없다. 
동적인거 >> assign 할 수 있다
undefined : 초기화 안된거
typeof : 변수의 타입을 명시

수치형 : 정수, 실수, non 모두 가능
	NaN : Not A Number
		: parseInt("안녕하세요"), 100/0 같은거 해도 프로그램이 죽지 않고 NaN 이라는 값이 들어간다
		: isNaN( ) 을 활용하여 해당 값이 NaN 인지 아닌지 알 수 있다


문자열 연산 + 를 사용할 수 있다

백틱 `
	: esc 밑에 있는 거
	: f 를 앞에 쓰고 `문자열{ 변수} 어쩌구{ 변수}  ` 하면 printf 처럼 format 할 수 있다. ? ${ } 로 구성된다? 
	: 일반적인 따옴표(' ") 와 방향이 반대라서 백 틱이라고 한다


객체
	: 사물의 속성attribute 와 동작을 묶어서 표현
	: 객체.속성명 으로 접근 가능
	: js 는 원래 객체 라는 개념이 없는데 (딕셔너리를 사용하여) 객체를 사용하는 거다

연산자 : 다 쓸 수 있다
	: 그런데 + 연산자의 경우 주의해야한다. 일반적인 + 의 경우 교환법칙이 성립해야하지면 여기선 안그렇다. 문자열과 붙어있는 얘들은 먼저 변한다
		: 문자열+ 숫자1 + 숫자2 == "문자열숫자1숫자2"
		:숫자1 + 숫자2+ 문자열 ==


비교연산자	
	: == 와 ===
		== : 맥락상 값이 같으면 참
			ex) '1' == 1 >> true

		=== : 타입과 값이 모두 일치해야 참<< 우리는 이걸 써야된다. == 는 기존의 의미와 벗어나기 떄문에 헷갈릴 수 있어 사용을 지양해야된다
			ex) '1' === 1 >> false
		
	: != 와 !== 도 마찬가지다

prompt( )  : prompt("메시지", "디폴트값"); >> 문자열 반환
confirm() >>> true 혹은 flase 반환

parseInt >> 문자열을 "파싱" 해서 정수형으로 변환해주는거

 write( ) 를 하면 그전에 해당 페이지에 출력했던 내용이 다 사라진다.

getElementById( ) 
	: id를 기반으로 접근
	: 얘 자체는 해당 객체를 가져오는거고 그 객체의 값을 얻기 위해선 value 를 사용해야됨
	: 참고 >> getElementByTagname 같은건 div.ramen 같은걸 대상으로 할때 편하다

자바 스크립트의 함수
	: 함수 안에서 선언된 변순 함수의 생성과 함꼐 생성되고 종료와 함께 종료된다
	: 로컬 변수 같은 경우는 변수명 대충 지어도 되는데 전역 변수의 경우 정성껏 지어라


console.log( ) >> f12-console 선택해서 봐라


반복문
        let i = 0;
        for (i = 0; i < 10; i++)  과 같이 분리해서 적으면 안되고 
 	for (let i = 0; i < 10; i++) 와 같이 한꺼번에 써줘야된다

continue 문장: 가장 가까운 루프의 조건식을 다시 수행

***무명함수 :   함수 이름을 주지 않고 만들어서 한 번만 사용하는 경우도 많다.
	: 자바의 람다함수와 비슷
	: 이름 없는 변수를 선언하는 법 >> 이름 없이 함수를 선언하고 특정 변수에 그 함수를 할당함.

**화살표함수
	: 역사는 수업시간에 다루지 않음.
	: 익명 함수를 더 간단하게 쓰기 위해 도입한 것
	: 이것도 자바의 => 와 비슷한 거임
	: function sub (a,b){	== ( a, b ) => {return a+b; } ==  (a.b) => a+b;
		return a+b;
	}

	: 매개변수가 하나밖에 없으면 괄호 생략 가능
	: 리턴값을 화살표 다음에 쓴다
: 함수를 만들면서 호출하는 것.
((name) => console.log(`Hello, ${name}!`))('World');


지역변수와 전역 변수
	: 전역변수 >> 함수 외부에서 선언된 변수
	: 지역변수의 경우 let 은 정상적으로 지역변수처럼 작동이 되는데 var 은 ㅈㄴ 널널해서 지역변수라도 밖에서 접근 가능하다



객체 지향

자바스크립트에서의 객체
	1. 내장객체
		(1) DOM
		(2) BOM
	2. 사용자 정의 객체>> 자바의 클래스. c의 구조체 같은거

객체 생성할 떄 new 연산ㄴ자 사용
객체를 대상으로 접근 위해 도트 연산자 사용

자바스크립트에서는  기존 기능을 재활용해서 객체지향 흉내를 내는거지, 실제로 객체지향이 아니다. 
	: 원리 >> 파이썬의 dictionary 의 사용법.
	: 자바스크립트에서 완벽하게 객체지향 학습을 하려고 하지 말것

	: Index addressable array .vs. content addressable array
		:  Index addressable array >> [값1, 값2 값3 ... ]
			: 인덱스를 기반으로 찾ㅈ는다
		:  content addressable array >> { "키1":"값1","키2": "값2","키3": "값3" ... }	
			:  { 키1 :"값1", 키2 : "값2",키3: "값3" ... }	로 해도 되긴 한다. 그러면 자동으로 " " 붙여준다
			: 컨텐츠(키) 를 기반으로 찾느다.
			: 어떻게 지가 알아서 탁 갈까? >> hash function 을 사용한다.
			: 입력이 있으면 결과값이 있다. hash("mother") 의 갑을 get 해서 해당 값으로 배열에 접근한다.
			: 주의 ) 변수[키] 가 아닌 변수["키"] 로 찾아야된다
			: 변수.키 로도 접근 가능하다. >> 그러니까 객체의 속성을 정의하는 것이다.
				c에서 ary[1] 을 *(a+1) 로 내부적으로 수식해서 계산하는거랑 비슷하게 사실 변수["키"] 는 내부적으로 변수.키 라는 것이다.
 			: 이렇게 하는 경우 인덱스로 접근 못 함 주의


		: 사실 Object( ) 는 딕셔너리가 들어가ㅡㄴ거다

생성자 흉내내기 : this

대문자로 시작하는 함수 >> 클래스 이다.
	function User(name, isAdmin) >> User 은 클래스이다.


Date 객체
	: 많이 쓰인다
	: Date(2023, 7, 21, 18, 30, 0, 0); 에서 마지막은 ms


****2개의 날짜 비교하기
	: 2개의 날짜를 계산하는건 생각보다 어렵다
	: 

컴퓨터에서 시간을 재는 법 : 유닉스 시간. 타임
	: 유닉스 시간은 1970년 1월 1일을 기준으로 얼마나 많은 밀리초가 흘렀는지를 기준으로 한다.
	: 현재ms - 이전ms 한 값을 1000/24/60 .. 해서 얻는다.
	: floor >> 버림.
	: 재귀호출을 사용하여 계속 업데이트 한다


자바스크립트 디버깅하기
	: 여기서 수정하면 실제로 수정된다
	: f12- source - 작업공간-폴더추가 
		: 외부에서 로컬에 access 하는거라 별도의 허용이 필요
 
플레이 버튼 : 중간점까지 계쏙 실행
다음 단계로 넘어가라 : 함수 하나씩 수행
그함수안으로 들어가라
함수벗어나서다음으로가라


대부분의 버그는 단순 오타인 경우가 많다.

10만라인 짜리 코드라도 중단점 6~7 번만 찍어보면 에러 잡을 수 있다.
	: Binary serach >> 1/2 씩 감소
	: 구글에서는 binary tree 를 사용하여 0.xx 초 만에 결과를 찾는다.


-----------------------------------------------------------------------------------------------------------------------------------

== 쓰지 말고 === 써라

콘솔에 변수 치면 타입을 확인할 수 ㅇ있다

reg ex 의 결과로는 배열이 나온다

random( ) 은 0~1 난수임

round( ) 는 대충 뭐 그정도란 뜻으로 반올림

리터럴 : 직접적인 값

배열은 언제 쓰는가? >> 서버에서 데이터를 가지고 와서 어느 위치에다 그려준다. 목록의 형태로

중간중간 값이 정의되지 않으면 undifned 값이 들어간다

자바스크립트에선 배열 크기의 제한이 딱히 없다

배열에서 각각 다른 자료형의 요소를 넣을 수 있따


concatintate : 붙이는거
+ 연산자 자체는 문자열에 먹히지만 ary 에는 안먹히기 때문에 배열과 배열을 연결할 때는 concat  사용해야된다

push , pop : 삽입과 삭제
	: 스택처럼 쓰는거

shift( ) : 젤 앞에 추가
unshift( ) : 젤 앞에 추가

자바 스크립트의 sort 는 멍청하게 작동한다. 문자처럼 인식하고 정렬한 것이기 때문이다. 따로 숫자로 변환해서 정렬해야된다. 그래도 유용하다. 뭐든지 정렬할 수 있다. 괜히 sort 프로그램 따로 작성하지 ㅏ라.

filter( 조건 ) 해서 쓴다.

this 사용시 자동적으로 일어나는것
	1.  this = { } 생성
	2. return this

js 는 딕셔너리이기 대문에 기존 객체에 속성을 자유롭게 추가할 수 있고, 생성자도 그렇게 변경된다.

속성을 그냥 도트 연산자를 사용해서 추가 가능하단
 
 


 











