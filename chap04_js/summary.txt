요즘엔 var 로 변수 선언 잘 안한다. let 이란걸 사용해야된다
const : 상수 선언
변수 선언 보다는 상수 선언을 추천한다. 상수 선언이 불가한 경우 let 을 이용해 변수 선언해라

  console.log( 어쩌구 ) ; >> 다른 언어의 print 와 유사한 기능

innerHTML  , outerHTML 
	: outerHTML >> 태그를 감싸는 것까지 같이 본다

딱히 type cast 없다. 
동적인거 >> assign 할 수 있다
undefined : 초기화 안된거
typeof : 변수의 타입을 명시

수치형 : 정수, 실수, non 모두 가능
	NaN : Not A Number
		: parseInt("안녕하세요"), 100/0 같은거 해도 프로그램이 죽지 않고 NaN 이라는 값이 들어간다
		: isNaN( ) 을 활용하여 해당 값이 NaN 인지 아닌지 알 수 있다


문자열 연산 + 를 사용할 수 있다

백틱 `
	: esc 밑에 있는 거
	: f 를 앞에 쓰고 `문자열{ 변수} 어쩌구{ 변수}  ` 하면 printf 처럼 format 할 수 있다. ? ${ } 로 구성된다? 
	: 일반적인 따옴표(' ") 와 방향이 반대라서 백 틱이라고 한다


객체
	: 사물의 속성attribute 와 동작을 묶어서 표현
	: 객체.속성명 으로 접근 가능
	: js 는 원래 객체 라는 개념이 없는데 (딕셔너리를 사용하여) 객체를 사용하는 거다

연산자 : 다 쓸 수 있다
	: 그런데 + 연산자의 경우 주의해야한다. 일반적인 + 의 경우 교환법칙이 성립해야하지면 여기선 안그렇다. 문자열과 붙어있는 얘들은 먼저 변한다
		: 문자열+ 숫자1 + 숫자2 == "문자열숫자1숫자2"
		:숫자1 + 숫자2+ 문자열 ==


비교연산자	
	: == 와 ===
		== : 맥락상 값이 같으면 참
			ex) '1' == 1 >> true

		=== : 타입과 값이 모두 일치해야 참<< 우리는 이걸 써야된다. == 는 기존의 의미와 벗어나기 떄문에 헷갈릴 수 있어 사용을 지양해야된다
			ex) '1' === 1 >> false
		
	: != 와 !== 도 마찬가지다

prompt( )  : prompt("메시지", "디폴트값"); >> 문자열 반환
confirm() >>> true 혹은 flase 반환

parseInt >> 문자열을 "파싱" 해서 정수형으로 변환해주는거

 write( ) 를 하면 그전에 해당 페이지에 출력했던 내용이 다 사라진다.

getElementById( ) 
	: id를 기반으로 접근
	: 얘 자체는 해당 객체를 가져오는거고 그 객체의 값을 얻기 위해선 value 를 사용해야됨
	: 참고 >> getElementByTagname 같은건 div.ramen 같은걸 대상으로 할때 편하다

자바 스크립트의 함수
	: 함수 안에서 선언된 변순 함수의 생성과 함꼐 생성되고 종료와 함께 종료된다
	: 로컬 변수 같은 경우는 변수명 대충 지어도 되는데 전역 변수의 경우 정성껏 지어라


console.log( ) >> f12-console 선택해서 봐라


반복문
        let i = 0;
        for (i = 0; i < 10; i++)  과 같이 분리해서 적으면 안되고 
 	for (let i = 0; i < 10; i++) 와 같이 한꺼번에 써줘야된다

continue 문장: 가장 가까운 루프의 조건식을 다시 수행

***무명함수 :   함수 이름을 주지 않고 만들어서 한 번만 사용하는 경우도 많다.
	: 자바의 람다함수와 비슷
	: 이름 없는 변수를 선언하는 법 >> 이름 없이 함수를 선언하고 특정 변수에 그 함수를 할당함.

**화살표함수
	: 역사는 수업시간에 다루지 않음.
	: 익명 함수를 더 간단하게 쓰기 위해 도입한 것
	: 이것도 자바의 => 와 비슷한 거임
	: function sub (a,b){	== ( a, b ) => {return a+b; } ==  (a.b) => a+b;
		return a+b;
	}

	: 매개변수가 하나밖에 없으면 괄호 생략 가능
	: 리턴값을 화살표 다음에 쓴다
: 함수를 만들면서 호출하는 것.
((name) => console.log(`Hello, ${name}!`))('World');


지역변수와 전역 변수
	: 전역변수 >> 함수 외부에서 선언된 변수
	: 지역변수의 경우 let 은 정상적으로 지역변수처럼 작동이 되는데 var 은 ㅈㄴ 널널해서 지역변수라도 밖에서 접근 가능하다



객체 지향

자바스크립트에서의 객체
	1. 내장객체
		(1) DOM
		(2) BOM
	2. 사용자 정의 객체>> 자바의 클래스. c의 구조체 같은거

객체 생성할 떄 new 연산ㄴ자 사용
객체를 대상으로 접근 위해 도트 연산자 사용

자바스크립트에서는  기존 기능을 재활용해서 객체지향 흉내를 내는거지, 실제로 객체지향이 아니다. 
	: 원리 >> 파이썬의 dictionary 의 사용법.
	: 자바스크립트에서 완벽하게 객체지향 학습을 하려고 하지 말것

	: Index addressable array .vs. content addressable array
		:  Index addressable array >> [값1, 값2 값3 ... ]
			: 인덱스를 기반으로 찾ㅈ는다
		:  content addressable array >> { "키1":"값1","키2": "값2","키3": "값3" ... }	
			:  { 키1 :"값1", 키2 : "값2",키3: "값3" ... }	로 해도 되긴 한다. 그러면 자동으로 " " 붙여준다
			: 컨텐츠(키) 를 기반으로 찾느다.
			: 어떻게 지가 알아서 탁 갈까? >> hash function 을 사용한다.
			: 입력이 있으면 결과값이 있다. hash("mother") 의 갑을 get 해서 해당 값으로 배열에 접근한다.
			: 주의 ) 변수[키] 가 아닌 변수["키"] 로 찾아야된다
			: 변수.키 로도 접근 가능하다. >> 그러니까 객체의 속성을 정의하는 것이다.
				c에서 ary[1] 을 *(a+1) 로 내부적으로 수식해서 계산하는거랑 비슷하게 사실 변수["키"] 는 내부적으로 변수.키 라는 것이다.
 			: 이렇게 하는 경우 인덱스로 접근 못 함 주의


		: 사실 Object( ) 는 딕셔너리가 들어가ㅡㄴ거다

생성자 흉내내기 : this

대문자로 시작하는 함수 >> 클래스 이다.
	function User(name, isAdmin) >> User 은 클래스이다.


Date 객체
	: 많이 쓰인다
	: Date(2023, 7, 21, 18, 30, 0, 0); 에서 마지막은 ms


****2개의 날짜 비교하기
	: 2개의 날짜를 계산하는건 생각보다 어렵다
	: 

컴퓨터에서 시간을 재는 법 : 유닉스 시간. 타임
	: 유닉스 시간은 1970년 1월 1일을 기준으로 얼마나 많은 밀리초가 흘렀는지를 기준으로 한다.
	: 현재ms - 이전ms 한 값을 1000/24/60 .. 해서 얻는다.
	: floor >> 버림.
	: 재귀호출을 사용하여 계속 업데이트 한다


자바스크립트 디버깅하기
	: 여기서 수정하면 실제로 수정된다
	: f12- source - 작업공간-폴더추가 
		: 외부에서 로컬에 access 하는거라 별도의 허용이 필요
 
플레이 버튼 : 중간점까지 계쏙 실행
다음 단계로 넘어가라 : 함수 하나씩 수행
그함수안으로 들어가라
함수벗어나서다음으로가라


대부분의 버그는 단순 오타인 경우가 많다.

10만라인 짜리 코드라도 중단점 6~7 번만 찍어보면 에러 잡을 수 있다.
	: Binary serach >> 1/2 씩 감소
	: 구글에서는 binary tree 를 사용하여 0.xx 초 만에 결과를 찾는다.


-----------------------------------------------------------------------------------------------------------------------------------

== 쓰지 말고 === 써라

콘솔에 변수 치면 타입을 확인할 수 ㅇ있다

reg ex 의 결과로는 배열이 나온다

random( ) 은 0~1 난수임

round( ) 는 대충 뭐 그정도란 뜻으로 반올림

리터럴 : 직접적인 값

배열은 언제 쓰는가? >> 서버에서 데이터를 가지고 와서 어느 위치에다 그려준다. 목록의 형태로

중간중간 값이 정의되지 않으면 undifned 값이 들어간다

자바스크립트에선 배열 크기의 제한이 딱히 없다

배열에서 각각 다른 자료형의 요소를 넣을 수 있따


concatintate : 붙이는거
+ 연산자 자체는 문자열에 먹히지만 ary 에는 안먹히기 때문에 배열과 배열을 연결할 때는 concat  사용해야된다

push , pop : 삽입과 삭제
	: 스택처럼 쓰는거

shift( ) : 젤 앞에 추가
unshift( ) : 젤 앞에 추가

자바 스크립트의 sort 는 멍청하게 작동한다. 문자처럼 인식하고 정렬한 것이기 때문이다. 따로 숫자로 변환해서 정렬해야된다. 그래도 유용하다. 뭐든지 정렬할 수 있다. 괜히 sort 프로그램 따로 작성하지 ㅏ라.

filter( 조건 ) 해서 쓴다.

this 사용시 자동적으로 일어나는것
	1.  this = { } 생성
	2. return this

js 는 딕셔너리이기 대문에 기존 객체에 속성을 자유롭게 추가할 수 있고, 생성자도 그렇게 변경된다.

속성을 그냥 도트 연산자를 사용해서 추가 가능하단
 
 


 
상속
	: extends 키워드 사용해 상속한다
	: 상속 받은 것처럼 흉내낸다
	: 자바스크립트가 가비지 컬렉션 기반의 언어이기 때문에 'destructor'가 없다.
	: 다형성 polymorphism
		: 부모로 다양한 자식 받는거

Try-Catch 구조
	: runtime 오류 >> 실행하다 죽음
	: 오류처리
	: 일단 돌아야 방지를 하건 뭘 하건 할  수 있다.
	: 문장 별로 try  - catch 를 작성하는게 아니라 문제 있을만한거 몰빵한 다음에 catch 에서 if 로 세분화하는거


throw
	: 중첩 호출된 상황에서 당장 예외처리 안하면 다른 곳에서 처리 가능하다
	: catch 문 내부에서도 throw 사용 가능하다

eval( ) :  x=3*7 같은 수식을 계산해서 value 를 끄집어낸다


----------------------------------------------------------------------------------------------------------------------------

파싱 : 스트링 분석하는것

html 은 자식 2개 가진다. >> head, body


window 의 자식으로 document 가 있기 때문에 BOM 에 DOM 이 포함된다



HTML 요소 찾기
    ID로 HTML 요소 찾기 getElementById( )
    태그 이름으로 HTML 요소 찾기 getElementsByTagName() 
	: Element 가 아니라 Element"s" 임을 주의
	: 결과가 여러개라 배열로 받는게 좋다

    CSS 선택자로 HTML 요소 찾기 querySellectorAll( ) 
	: p.containter1 같은 것도 검색 가능해진다
		: # 이랑 . 기호 뺴먹지 마라
	: 젤 좋다. 이걸로 다 커버칠 수 있다.

    클래스 이름으로 HTML 요소 찾기 
    기타 childNodes[ ], nextSibling[ ], parentNode[ ]


Truthy 값.. >> true 비슷한 거

false 가 0 인건 c 따라한것

입력양식은 forms[i].elements[j] 혹은 form이름.input태그이름 으로도 접근 가능하다
	 form"s" 라는 객체
		: 해당 document 에 있는 form 들이 목록으로 되어있는거다
		: forms[0] == 0번째 form


그림으로 그리라하면 딕셔너리로 화살표 써서 그리는거다

checked 속성 같이 구체적인건 안내겠지만 어케 쓰는지는 알아야징


라디오는 [i] 처럼 인덱스적 접근이 가능하다


HTML 요소 변경하기
    요소의 내용( 시작 태그와 끝 태그 사이의 내용 ) 변경하기 >> innerHTML
    요소의 속성 변경하기 >> 객체.속성명
    요소의 스타일 변경하기 >> 객체.style.스타일속성명
    요소의 클래스 변경하기 >> 
	객체.className >> 클래스 통으로 적용됨
	객체.classList.add("특정클래스") >> 특정 클래스 추가
	객체.classList.remove("특정클래스") >> 특정 클래스 삭제
	객체.classList.toggle("특정클래스") >> 있으면 없애고 없으면 추가하고
 

-------------------------------------------------------------------------------------------------------------


디버그 하는 법 >> f12 - 소스 - 파일 추가
	: 안잡힐때는 코드에 직접 debugger 를 추가한다
	: 버그 잡을 떄 젤 중요한 것 >> 중간에 변수값이 잘 셋팅되나 보는 것
	: 버그 >> 내가 원하는 아웃풋이 안나오는 것
	: 문제 일어나는 부분을 잡아야된다 >> 중간에 잡고 점점 앞으로 범위를 좁힌다 (binary search 처럼 ). 라인 하나까지
	: 내가 굳이 일일이 print 안해도 옆에 떠서 확인이 편하다



Math.random()  >> 0~1 부동소수점범위

이벤트 >> ui 에서 사용자가 뭐 하는거
	: 이벤트는 큐에 쌓이고, 이벤트 헨들러한테 던져주면 실행된다
	: 생긴게 os 랑 비슷하다

blur >> focus 가 떠나는 것


이벤트 리스너 == 이벤트 헨들러


스크립트 내부에서 설정하는 방법
	1. 속성값으로 함수할당 >> 기존것은 사라진다. (가리키던 얘를 더이상 참조를 못하니까) . 여러개 설정 불가하다.
	2. addEventListener( ) 함수 사용 >> EventLister 를 "추가" 한다 . 기존 것은 사라지지 않는다. 여거래 설정 가능하다



이벤트 객체 >> 해당 이벤트에 관련된 모든 정보를 포함하는 객체
        alert(`${x} ${y} ${e.type} ${e.target}`) // e.type >> 이벤트 종류,  e.target>> 발생된 위치

비슷하다고 뭉쳐서ㅓ 만드는게 아니라, 비슷한 속성을 모아서 부모클래스로 만들고 그걸 상속받게 한다

UIEvent >> 화면관한
clipboard >> 복붙관한거

customEvent >> 사용자 정의 이벤트


target >> 사용자의 동작이 일어난 장소
currentTarget>> 이벤트 처리가 적용된 장소

stopPropagation >> 전파 금지. 다른 요소에게 까지 영향을 미치지 않는다
preventDefault >> 기본값 금지

screenX >> 스크린 전체 기준
clientX >> 요소 위치 기준

key >> 키 명 같은거
code >> 해당 키보드의 id 값 같은거

bubbling 과 capturing >> propagation 순서에 관한 것
	bubbling >> 안 -> 밖 . defualt 값
	capturing >> 밖 -> 안


-------------------------------------------------------------------------------------------------------------

자바스크립트와 파이썬에선 eval( ) 로 계산 가능하다
	: 인터프리터라서 가능

인라인으로 호출할 떄 사용하는 this는 해당 객체(요소)를 의미한다

mousedown : 누르는 과정
click : 클릭이 일어남
mouseup : 떼는 과정

mouseleave : 마우스 포인터가 해당 영역을 벗어남
mouseenter : 마우스 포인터가 해당 영역으로 들어옴

onmousemove : 여러번 일어나고 매번 (움직임의) 개수가 다르다


*****load 이벤트
	: 전체가 다 읽어왔을 떄 발생한다

IO 에서 읽어오는데 vs 메모리에서 읽어오는ㄷ ㅔ >>  100 만배 차이가 난다. ms 과 ns 간의 차이가 100만배이기 떄문 


사실 예제에서 script 문을 뒤로 옮겨도 잘 된다 >> 나중에 로드되니까


change 바뀐다의 기준 >> 포커스가 바깥으로 벗어났을 때




 --------------------------------------------------------------------------------------------------------------
\d===[0-9]

정규식 쓸 떄 앞 끝에 / /만 있으면 되지 ' 랑 " 가 있을 필욘 x


*** 이벤트 리스너
1. HTML 요소 내에 직접 이벤트 핸들러를 정의하는 방식
	: 장점 > 쓰기 쉽다
	: 단점 > html 과 js 가 분리되지 않는다.

 <button onclick="greetUser()">인사하기</button>

2. DOM 요소의 이벤트 핸들러 속성에 함수를 할당
	: 장점 > html 과 js 분리
	: 단점 > 여러 핸들러를 동시에 할당할 수 없음

        var button = document.getElementById('myButton');
        button.onclick = function() {
            alert('버튼이 클릭되었습니다!');
        };



3. addEventListener 메소드를 사용하여 이벤트 리스너를 추가하는 방식

        var button = document.getElementById('myButton');
        button.addEventListener('click', function() {
            console.log('버튼이 클릭되었습니다!');
        });


4. DOMContentLoaded를 사용하여 이벤트 리스너 등록
: DOMContentLoaded 이벤트 리스너는 HTML 문서가 완전히 로드되고 파싱이 완료된 직후에 실행
	: 이미지 다 다운되지 않아도 DOM 만 다 되면 실해ㅐㅇ한다는말
중간에 이미지 만나면 이미지 다운 받는 스레드 돌린다. 이미지가 로드 되건 안되건 DOM 은 계속 만들어진다. 그러닠까 이미지 로딩 되기 이전에 DOM 이 만들어질 수 있따



5.  load 이벤트를 사용하여 이벤트 리스너 등록
	 ; 이미지 같은 것 까지 다 다운되야 실행

  <body onload="changeColor();"> >> onload >> 초기화 하는 내용이주로..

## 결론
- 일반적으로 load를 사용할것

일반적으로 우린 속도 고려할 필요 없고 , 크게 느리면 그때 튜닝해라



템플릿 : 
load 라는 함수는 로드 이후에 필요한 이벤트들을 붙인다 


보일러플레이트 boiler plate > 효율적인 코드 분리





# **브라우저 객체 모델**

naviagtor : 브라우져 자체에 대한 정보
location : 나의 로케이션. 경로



window 객체는 BOM에서 최상위 객체. 루트 객체
	:: 자바스크립트의 모든 전역 함수는 window 객체의 메소드
	: 모든 전역변수는 window 에 저장됨


setInterval()
	: interval >> 반복되는 것.
	: 일정한 시간마다 주기적으로 함수를 호출
	: 직접 clear 필요
    function stopTextColor() {
        clearInterval(id)
      }



DOM 은 내부에 있는 것만 조정하기 떄문에 창 자체의 위치를 움직이려면 BOM 의 window 를 사용해야된다


    for (let key in screen) {
      value = screen[key]
      s += key + ':' + value + '\n'
    }

에서  screen[key] 를 screen.key 로 쓰면 안된다


http 의 기본 포트는 80 이다


geolocation : 현재위치


--------------------------------------------------------------------------------------------------------------

비트맵 >> 픽셀별로 잡아주는 것. 확ㄷㅐ 하면 계단처럼보인다(계단현상)
vector >> 선으로 그림. 확대 해도 계단처럼 안보인다


SVG : 하나의 요소이다. 태그로 되어있으니까. >>요소니까 이벤트를 붙일 수 있다.
	: 돔(DOM)의 일부로 작동하므로 CSS 스타일링 및 JavaScript 조작이 가능


캔버스



context >> 문맥. 맥락
	: 시작 좌표, 색깔 같은 걸 다 저장해두는 곳
	: 그전에 얘기 했었잖아. 한번 설정하면 이후에도 유지
	: 처음에는 default 값이 들어가있다
	: 


context.fillRect(0, 0, 100, 50); // 시작지점 끝지점


모든 그래픽은 context 를 쓴다

fill : 안에 채움
fillStyle == 채우는색상
		let gradient = context.createLinearGradient(0, 0, 500, 0)  >> 그라데이션 색상
	:     context.fillStyle = gradient
 

stroke : 안에는 비우고 경계만]]
,storkeStyle == 경계색상

arc ==호



​
곡선그리기
베지어 곡선
	: 컨트롤포인트

      context.beginPath()
      context.moveTo(90, 130)
      context.bezierCurveTo(140, 10, 288, 10, 288, 130)
      context.lineWidth = 10
      context.strokeStyle = 'black'
      context.stroke()


은 시작점 포함해 점이 4개




      for (let i = 0; i < 6; i++) {
        for (let j = 0; j < 10; j++) {
          context.fillStyle =
            'rgb(' + (255 - 20 * i) + ', ' + (255 - 20 * j) + ', 0)'
          context.fillRect(j * 50, i * 30, 45, 25)
        }
      }

r 과 g 만 바꿔줬다



-------------------------------------------------------------------------------------------------------
웹서버
******:  동시에 여러 사용자를 서비스해야한다.
	:  CGI(Common Gateway Interface)
	: 하나의 요청에 대해 하나의 프로세스를 일일이 만들어서 수행하면 , 그 프로그램은 디스크에 실행시키고 또 없애야된다. (메모리에서 처리하는거랑 100만배 차이난다), 그래서 
		(1)스레드 기반으로 한다. << 자바가 선택 (서블릿)
		(2) 인터프리터 방식으로 한다
	: 사용자 수가 많아질 수록 서버의 가격은 기하급수적 증가
	: OS (운영체제)에서는 프로그램이 여러개 돌아간다. queue 에 쌓고 cpu가 이를 해결한다. cpu는 os 에서, 컴퓨터에서 논리적으로 실제로는 하나이다(프로그램은똑같아야되니까).  근데 n코어라고 물리적으로 여러개 있는 것처럼사용된다.
		: c언어의 ppt 에서 나온거랑 비슷하게 생겼다
	: 하나의 돌아가는 프로그램을 프로세스라고 한다. 프로세스에는 code + data + stack + heap 으로 이루어져있다
	: 스레드 당 하나의 stack. 
	: 프로세스가 queue 에 들어갈 수 있는 것처럼 스레드도 queue 에 들어갈 수 있다.
	: 스레드가 훨씬 싸다
	: php , python, node.js 도 인터프리팅방식


JSP
	: ASP > JSP
	: 작성한 내용을 서블릿으로 변환시켜준다
	: JSP 로 쓴 내용을 서블릿으로 바꿔봐라


실제적인 웹 서버 구조
	: 뭉쳐서 두지 않고 웹서버(request , response 처리) ,was, db이런식으로 분리한다
	: db를 웨이드로 구축해서 병렬적으로 한번에 읽히게한다
	: 캐쉬도 둬서 속도를 높인다
	: 광케이블을 사용한다
	: 클라우드를 사용한다

인코딩 설정해야 안꺠진다 : <%@page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>


프리프로세스 : JSP 가 서블릿으로 바꿔주는거. 소스코드를 다른 소스코드로 바꿔주는것.
	: c언어는 사실 #def 못읽고 컴파일러가 프리프로세스 해서 읽을 수 있게 되는것.


<%! .. %> 는 전역 변수
<%@ %> 는 지시어, import 할 떄 사용

스크립틀릿 내부에서 외부 html 문으로 print 할려면 내부에서 out.print 하면 된다
스크립틀릿 내부에서 request 그냥 쓰면 rquest 객체인거고, form 데이터의 name 을 기준으로 request.getParameterValues("name명"); 으로 얻을 수 있다

세션 
	: state-less >> 정보 유지를 못한다
	
요즘에는 SPA 로 한다 . CSR 이랑 비슷한거인듯? 


미디어 쿼리 : 현재 사용하고 있는 디바이스의 크기
	: 장치의 해상도를 파악할 수 있다.
	: 장치 크기 따라 결정해준다.
@media screen and (min-device-width: 375px) and (orientation: landscape) {
		...
	}
screen 이 아니라 print (종이 출력) 같은것도 있기 떄문에 screen 을 명시해줘야된다. 습관적으로 screen 꼭=오오옥 써라


화면의 방향
	세우는거 >> portrait
	눕히는거 >> landscape

유동레이아웃: 너비같은거 따라 자동적으로 "레이아웃" 바뀌게 하는것
유동이미지: 너비같은거 따라 자동적으로 이미지 사이즈 바뀌게 하는 것

픽셀말고 퍼센트로 해라. 그래야 유동적으로 움직인다.

스마트폰으로 직접 접속해서 볼려면 로컬 컴퓨터와 스마트폰이 동일한 공유기를 사용하고 있어야 한다.

뷰포트 : 보이는 영역.
가상 뷰포트 :: 가상의 보이는 영역 > 그대로 줄이면 넘 작아지니까 적당히 줄여서 보여주는가

******<meta name="viewport" content="width=device-width, initial-scale=1.0"> 이 한줄로 뷰포트 설정 가능하다










JWT (JSON Web Tokens)

json JavaScript Object Notation: 직렬화 stringify 와 역직렬화 역할
	: 역직렬화 >>  parse 를 이용한다
	:  직렬화 stringify >>> stringify 를 이용
	: 주의 > 

 const employeesWithoutQuotes = {
        employees: [
          { firstName: 'John', lastName: 'Doe' },
          { firstName: 'Anna', lastName: 'Smith' },
          { firstName: 'Peter', lastName: 'Jones' }
        ]
      }

      const employeesWithQuotes = {
        employees: [
          { 'firstName': 'John', 'lastName': 'Doe' },
          { 'firstName': 'Anna', 'lastName': 'Smith' },
          { 'firstName': 'Peter', 'lastName': 'Jones' }
        ]
      }


에서 첫번쨰 처럼하면 안되고 두번쨰처럼 항상 속성에 ' 붙여야된다
	: js 에서는 직접 붙이건 안붙이건 알아서 붙여주지만 json 은 그렇지 않다

pretty 적용하려면 

 JSON.parse(employeesJsonString),
        null,
        2
      )

null 자리는 어떤 속성을 보여줄지 설정해주는거다
숫자는 pretty 적용 즉 들여쓰기, 띄어쓰기를 어느정도로 할 건지 정해주는거다

왜 String 만 전송 가능한가? 
	: 객체를 나타내는 표현 방식이 다 다르기 떄문에 


sessionStorage : 한 세션 안에서만 살아있는 스토리지
localStorage : 내가 지우기 전까지는 살아있는 스토리지

쿠키와 세션은 application 에서 볼 수 있다

파일 API ; 로컬 파일에 접근하는거
	: 

        if (!window.File || !window.FileReader) {
          alert('File API가 지원되지 않습니다.')
          return
        }

		: 브라우저가 다 파일 API 를 지원해주는건 아니다

	: 이 과정 개중요
	        let reader = new FileReader() // 파일 읽는 것을 생성한다. 파일 포인터를 생성한다. cpu 작업이다
        reader.onload = function () { // onload 라는 속성에 해당 함수를 넣어준다. reader 가 다 로드되면 해당 함수를 실행할 수 있게 한다
	// 이것도 콜백 함수이다.
          document.getElementById('result').value = reader.result
        }
        reader.readAsText(file, 'euc-kr') // io 작업
      }



동기(synchronous)란, 어떤 작업을 실행할 때 그 작업이 끝나기를 기다리는 방식
비동기(asynchronous)란, 어떤 작업을 실행할 때 그 작업이 완료되지 않더라도 다음 코드를 실행하는 방식


비동기 프로그램. aync >> 시간이 걸리는 작업을 수행하는 동안 다른 작업을 계속할 수 있도록 하는 프로그래밍 방식
	; CPU작업과 I/O 작업의 속도 차이는? >> 100 만배
	: ex ) onload
	: 구현 방법
		1. callback : 비동기 작업 완료시 호출되는 함수
			: 단점 >> 중첩된 구조

	: fetch >> 데이터를 가져오는 것. >> 갖고 오라는 것이므로 i/o 이다.

function fetchData(callback) { // arg 는 1개 이고 그 타입은 "함수형".
  setTimeout(() => { // 
    callback("data");
  }, 1000); // setTimeout( ) 의 파라미터는 2개인거다. 2번째 arg 시간 만큼  다음에 첫번쨰 arg 로 들어왔던 함수를 실행시킨다. 
	// 그러니까 fetch 작업을 수행하는데 얼마나 걸렸는지 알 수 있게 해준다.
}

fetchData((data) => {
  console.log(data);
});


		2. promise : then 과 catch 사용
			: promise 함수는 resolve 와 reject 를 arg 로 받는다
				: 함수 내부서 작업이 성공적으로끝나면 resolve 를 , 실패하면 reject 를 호출한다
			;  
		3. async , await
			: 선언은 async 로 하고, 활용할 떈 await 를 한다.
			: await 를 내부에 쓰기 위해서 함수를 async 로 선언한다고 보면 된다
			: async 함수는 항상 프라미스를 반환. 
			: syntatic sugar >> 복잡한 코드를 쉽게 할 수 있게 해준다



AJAX Asynchronous JavaScript and XML >> 전체 페이지 리로드 하지 않고 일부분만 업데이트 하는 것.
	: 브라우저가 직접 비동기 방식으로 HTTP 통신을 하여 서버와 XML 혹은 JSON 형식의 데이터를 교환하는 기술
		: 요즘엔 Xml 보다는 Json 을 더 자주 쓴다
		: 이름이 xml 이라고 무저건 xml 만 쓸 수 있는게 아니다 
	: 새로운 htlm 을 response 받으면 이전에 받았던 html 에 저장되었던 js 정보들. 데이터들은 다 삭제된다 ( stateless )

	: xml 메세지만 response 하는거라서 html 페이지가 reload 되지 않아 그전의 정보가 날라가지 않는다. 단순 dom 의 구조만 바꾼다.
		 : 그러니까 보여지는 화면은 달라지는거다
	: 검색어 쳤을 ㄸㅐ 밑에 뜨는 추천 검색어들도 ajax 이다


Ajax는 Asynchronous JavaScript and XML의 약자입니다.

Ajax는 동적인 대화형 웹페이지를 만듭니다.

내용의 파일은 저장되어있는 것


<!DOCTYPE html>
<html>
<head>
    <script>
        function getFromServer() {
            let req = new XMLHttpRequest();// 웹 서버에서 가져오기 위해서 XMLHttpRequest(); 를 사용한다
            req.onload = function () { // 비동기 방식 중 콜백 방식.
                document.getElementById("target").innerHTML =
                    this.responseText;
            }
            req.open("GET", "testfile.txt", true);
            req.send(); // request 를 보낸다. 오래걸린다. i/o 를 읽는거니까.
        }
    </script>
</head>
<body>
    <div id="target"style="width: 300px; height: 60px; border: solid 1px black;">
    </div>
    <button type="button" onclick="getFromServer()">GET DATA</button>
</body>
</html>



fetch API : 
	: 표준이고 built in 되어있어 별도의 설치가 필요없다
		: axios 는 비표준이다 ! ( axios 가 더 좋긴 하다. )
	: fetch API는 AJAX 기술을 응용한 것
	: Promise 타입의 객체를 반환한다.
	; 'https://jsonplaceholder.typicode.com/todos/1' >> 연습 사이트 . 서버 제공


  fetch('https://jsonplaceholder.typicode.com/posts', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }

	: 디퐅트는 get 방식이다
	: 옵션을 주면 get 방식 이외의 방식도 채택 가능하다.
	: body 에는 stringify 를 하여 request 를 한다

	: 


mpa , spa 
	spa 장점
		1. 세션 정보 즉 state를 유지
		2. 성능 높아짐
		3. 

	mpa 는 서버에서 ui 까지 처리 다 해주는거다

	: mpa 와 spa 를 섞어서 쓸수도 있다




메멘토처럼 쿠키를 쓰는거다





 
--------------------------------------------------------------------------------------------------------------------
REST..
	:  테이블이 10개인 경우 40개 ~ 100개의 요청 처리
		: crud + 조건 따른 + join 그런거 다 고려해서

	: State >> 정보
	: Representational >> 표현적이다
	: 

Stateless 인 이유 >> 서버의 성능 저하 방지목적
Layered System >> 계층 구조
Self-descriptiveness  >>  쉽게 이해할 수 있도록 자체 표현 구조를 지녀야

객체를 자원이라고 하기도 한다

 url 
	>> 소문자로만
	>> 테이블 조회시 복수형으로
	>> 리소스를 쓸떄는 - 를 , 쿼리스트링의 파라미터명은 _ 를 사용해라
	>> 메서드 처럼 쓰지 말고 객체명처럼 써라


소스코드 보기해서 copy 해도 못알아보게 보호해주는 툴  : 모든 변수명을 알아보지 못하게 무작위로 바꿔준다

	

/api/1/vehicles/{id}/wake_up >> 1 은 버전을 의미

 bearer는 토큰 type에 해당합

-----------------------------------------------------------------------------------------------------------------------------------------

setInterval(function () {
        let sec = document.getElementById('sec');
        let d = new Date();
        let deg = 6 * d.getSeconds();
        sec.setAttribute('transform', 'rotate(' + deg + ' 50 50)');
      }, 1000);

▲ 콜백함수



드래그 따라 발생하는 이벤트
	: 드래그 시작하면 >> 드래그 소스
	: 놓으면 >> 드롭 타겟

dragstart 
	: 이 이벤트 사용하려면 해당 객체에 draggable="true" 해놔야된다
******: 여기서 해야 하는 가장 중요한 작업은 dataTransfer 객체에 setData() 호출을 통하여 어떤 데이터를 보낼지를 설정
        e.dataTransfer.setData('Text', e.target.id)
	: 잡는 순간이 start 인 것 .


drop 이벤트
	: 놓는 순간이 drop 인 것
******: dataTransfer 객체에서 getData() 메소드를 이용하여서 필요한 데이터를 꺼내면 된다.


  e.dataTransfer.effectAllowed = 'move' 해줘야 움직일 수 있다


e.preventDefault() : 고려하지 못한. 예상치 못한 일 일어날까봐 미리 쳐두는거다


드래그 게임 만들기
	: 드래그 할 수 있는 대상 >> 3개
	: drop 당 할 수 있는 위치 >> 4개
	: <body onload="init()">
		: 이것도 콜백이다
		: 전체 페이지 + 이미지가 다 로드 되면
	: 바로 위의 사진 드래그 하기 예제에서보다(그러니까 인라인으로 일일이 바인딩해주는것보다 ) 이 예제에서 하는 것처럼 자바스크립트로 객체 뽑아서 이벤트 핸들러 바인딩하는게 좋다 >>> js 와 html 의 분리


navigator >> 브라우저의 옛날 이름. 브라우저의 위치 정보
	: getCurrentPosition( ) >> 현재 위치를 얻어온다	
	:  geolocation.getCurrentPosition(showLocation, errorHandler); 에서 arg 의 타입은 함수이다. arg 로 함수를 받을때 대부분의 그 용도는 콜백 함수이다. 여기서 gps 는 io 고(?) 비동기 작업이기 떄문에 콜백 함수를 쓴거다


이동하면서 위치 정보를 얻는 방법 >> 이건 진짜 컴터 들고 움직여야 작동한다
	:  watchPosition( )


웹에 지도를 표시하는 방법
	: 움직이고 나서 빈 공간이 새로 채워진다
	: 지도의 똥글뱅이 마크를 '마커' 라고 한다
	: 우리가 직접 구현하진 않고 api 가져다 쓴다. 일종의 라이브러리다.
		: 설치를 하게 하면 반환되는 페이지에 다운 받아져 보내지는거고, 설치를 하지 않게 하는 경우는 ??? 
		: 여러 사람들이 해당 라이브러리에 한꺼번에 접근해버리면 엄청나게 많은 서버가 필요하게 된다. 그 회사가 직접 나라마다 서버를 두는건 아니고, 전문 업체에 그렇게 두게 해주는 회사가 있다. (캐싱만 해주는 회사가 있다)
			: 이러한 회사를 CDN 이라고 한다 Content Delivery Network

https://unpkg.com/leaflet@1.8.0/dist/leaflet.css"
dist >> 배포 라는 뜻


let mapOptions = {
        center: [37.562, 126.9793],// 지도의 센터 위치
        zoom: 10 // zoom 레벨 
      }

TileLayer >> 타일 처럼 지도를 조각 조각 받는다
	
http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'
	s : 서버 를 여러 군데에서 받을 수 있게
	z : zoom 의 정도
	x , y : 위치



웹 워커
	: 기존 쓰레드에 쓰레드를 덧붙인다  
	: 필요할 때마다 이벤트를 줘서 추가한 쓰레드에서 작업이 얼마나 진행되었는지 확인이 가능하다
	: 소수 구하기 예제
		: worker.js
			: 원래는 continue 시 가장 가까운 loop 로 간다. 그런데 앞에 search 와 같은 이름을 줌으로써 while 로 가게 한다

		: webworker.html
		******:   w = new Worker("worker.js"); >> 쓰레드를 생성한다
			:   w.onmessage = function (event) {
                    document.getElementById("result").innerHTML = event.data;
				: 콜백이다




