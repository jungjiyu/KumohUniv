연산자 우선순위
	(1) -> .  멤버접근연산자 와 도트연산자
	(2) &  * 앰퍼샌드와 역참조연산자

------------------------------------------------------------------------------------------------------------------------------

Call By Value  << 암기 : C Val 씨 발

------------------------------------------------------------------------------------------------------------------------------
	
scanf( "형식지정자" , 주소 );
	: 2번째 arg가 주소
		>> 일반적인 변수의 경우 는 '&변수' 꼴
		>> 주소값저장변수의 경우는 '변수' 꼴 그 자체

------------------------------------------------------------------------------------------------------------------------------

%s 
	: 입력 받을 때 , 출력할 때 모두 주소를 대상으로 함 >> printf 할때도  주소값저장변수의 경우 '변수' 꼴 그 자체로 활용한다 >> 포인터명과 배열명 그대로 쓴다.

------------------------------------------------------------------------------------------------------------------------------

포인터 변수
	: 단순 포인터 변수 그 자체 == 변수 가리킬 수 있는 포인터 >> 배열의 기능 수행 불가
	: 동적할당된 포인터 변수 >> 배열의 기능 수행 가능

------------------------------------------------------------------------------------------------------------------------------
	
0. 문자열	
	: "문자열 리터럴" 저장하기
		: 문자열 리터럴은 끝에 '\0' null 문자 붙은 형태이고, 읽기 전용 메모리에 저장된다
		case1. 단순 char *포인터명 = "hell"
			: 읽기 전용 메모리를 가리키고 있어, 해당 위치에서 값의 수정( 복사 . 문자 수정 . )은 불가
				
		case 2. 동적할당된 공간에 strcpy 사용
			: 값의 수정이 가능하다.
			: 여기서 문자열 리터럴 할당하면, (값의 복사가 일어나는게 아니라) 동적할당한거 다 물거품되고, 그 문자열 리터럴 참조하는 걸로 끝나는거 주의.
			step 1 >>  char *포인터명 = (char* )malloc(sizeof( 문자열길이 ));
			step 2 >> strcpy( 포인터명 , 문자열저장변수혹은문자열리터럴)  


		case3. char 배열명[ ] = "hell" ;
			: 배열명이 문자열 배열을 가리키는게 아니라, 문자열 리터럴의 문자 하나하나 단위로 배열의 요소로 저장되는 거라 값의 수정이 가능하다.
			: 문자열 할당하고 남는 칸은 자동으로 NULL 문자 로 채워진다.
			: 선언 이후에는 적용 불가하다.
			: 사이즈 생략 가능하다


		case4. 배열에 strcpy
			: 선언 이후에도 가능하고, 값의 수정도 자유롭다


		: https://dojang.io/mod/page/view.php?id=1785




	: 문자열 입력 받는 방법
		(1) scanf("%s" , 문자배열명 );
		(2) scanf("%s" , 동적할당완료된문자포인터명 );


	:  <string.h> 의 문자열 관련 함수
  		(1) strcpy( 적용대상주소 , 당할대상주소 )
	 	(2) strcat( )
------------------------------------------------------------------------------------------------------------------------------


1. 배열	
	배열끼리의 복사 : 직접 for 문으로 일일이 복사하는 방법 밖에 없다
		: 배열명은 포인터 상수라서 " 배열명1 = 배열명2; " 는 불가하다. 		

	배열명에 포인터 할당은 불가하지만 , 포인터에 배열명은 할당 가능
		: 포인터는 다른 대상을 가리킬 수 있지만 , 배열명은 포인터 상수라서 불가

	문자 배열에 문자열 저장하기
		(1) 선언과 동시에 가능 << 사이즈 명시 불필요
			1.중괄호 이용 할당  {  'h', 'e' , 'l' , 'l'  ,'\0' };
			2. 문자열리터럴 할당
		
		(2) 선언 이후에도 가능 : 인덱스 단위 저장
	 

------------------------------------------------------------------------------------------------------------------------------


2. 포인터
	포인터 상수
		: 가리키는 대상을 변경할 수 없지만, 가리키는 대상의 값의 수정은 가능하다
		: 배열명도 포인터 상수이기 때문에
			: 배열명 자체로는 값의 수정이 불가
			: 역참조연산자 쓰는 경우 거기에 저장하고 있는 값을 바꾸는 거라 수정이 가능
			: 앰퍼샌드 써서, 해당 위치에 입력 값을 저장 가능

	void 포인터
		: 변수의 자료형을 고려하지 않고 주소값만 저장
			: 이 상태로 void 포인터가 가리키는 대상을 수정할 수 있다. 포인터니까.
			: 이 상태론 읽지 못한다. 타입이 미정인 상태이기 때문.
		: 값을 읽기 직전까지만 형변환 제대로 해주면 된다.
		: https://reakwon.tistory.com/19

	다중포인터

	포인터변수를 배열명처럼 활용


------------------------------------------------------------------------------------------------------------------------------

4. 동적할당 - malloc , realloc , calloc
	: sizeof내부변수타입의포인터레벨 - " 1 "  == 동적할당받는변수타입의포인터레벨 == malloc 강제형변환레벨 
		:  특정타입* 변수명 = (특정타입*) malloc ( sizeof( 특정타입 )* n );

	(1) void * malloc( n * sizeof( 변수 ) ) >> 초기화 x + 동적할당
	(2) void * calloc( n ,  sizeof( 변수 ) ) >> 초기화 0 + 동적할당
		: 통상적으로 n 을 더 먼저쓰긴 해도, n (요소갯수) 와 sizeof 의 순서는 딱히 중요하지 않다. 어차피 n*sizeof(변수) 로 계산됨.


	(3) void * realloc(  메모리공간수정대상포인터변수 ,   n * sizeof( 변수 ) ) >>  기존값을 가지면서 크기가 바뀐 메모리를 "반환"

		: 주의 >>  기존 영역이 아닌 아예 새로운 영역에 메모리가 잡힐 수도 있어서, 반환값 받아서 업데이트까지 해줘야된다

		: 크기를 늘리는 경우  >> 기존 메모리 영역의 뒷 부분의 사이즈를 늘리거나, 아예 다른 곳에 해당 크기의 영역이 새로 잡힌다
		: 크기를 줄이는 경우 >>  기존 메모리 영역에서 뒷 부분이 줄어든다

 
	: https://untitle-ssu.tistory.com/69
			: https://thinkpro.tistory.com/66
			: 동적할당 받았던 메모리의 크기를 변경한다. 

			: 첫 arg 로는 이미 동적할당된 부분을 참조하고 있는 포인터, 두번째 arg 로는 변경될 사이즈를 할당한다
			: 주의 ) 
				1. 그냥 arg 로 해당 포인터를 대입하는걸로 끝내면 안되고, 다시 재할당받아야된다.
					: 메모리 위치가 유지되는건 보장 못한다
						: 참고로 realloc 로 인해 쓸모없게된 메모리영역은 자동으로 반환되므로 노상관.
					: ex) 
						int *p = (int *)malloc(6*sizeof(int));
						p = (int *)realloc(p,8*sizeof(int)); // arg 로 대입하고, 다시 반환 받는다

				2. 반환타입이 void* 이므로 재할당할때 강제형변환 필수
				3. 두번째 arg 는 단순 요소 개수가 아니라 "사이즈"( 개수 * sizeof(타입)) 임을 주의

	: 동적할당메모리반환 )  메모리 공간을 공용 메모리로 돌리는 작업
		memory leak >> 더이상 사용하지 않는 메모리를 계속 붙잡고 있어서 과부하 걸리는것
			: memory leak 을 방지하기 위하여 더이상 사용하지 않는 얘들은 바로바로 반납하자

		댕글링 포인터(Dangling Pointer) >>  해제된 메모리 영역을 여전히 가리키고 있는 포인터
			: https://thinkpro.tistory.com/67
			: 요약하자면, free(특정포인터) 한 후에 바로 특정포인터=null; 해주는게 좋다
			: 동적할당 메모리를 반환하면,  거기에 저장한 값은 날라가고 쓰레기 값으로 채워지는게 맞다. 그런데 반환된 공간을 사용한다고 해서 에러가 나지도 않고, 대부분 값이 제대로 나온다. 하지만 해당 메모리는 공용 메모리로 돌려진 상태라 어떤 상황이 발생할지 예측불가하므로, 해제된 메모리에 값 저장하지 말자. 할거면 새로 공간을 할당하여 사용하자
				: 댕글링 포인터 ex)
 					int *p2 = (int*)malloc(sizeof(int));
					*p2 = 10;
					printf("동적할당된상태에서의 값: %d \n",*p2);
					free(p2);
					printf("메모리 해제된 상태에서의 쓰레기값: %d \n", *p2);
					*p2 = 10;
					printf("메모리 해제된 상태에서 값(10) 넣었을때: %d ", *p2);


		: free( 포인터 ) 를 사용해서 한다
		: 주의 
			1. 일차원 가변적 배열로 사용한 포인터의 경우 걍 그 포인터만 free 시키면 되지만, 이차원 가변젹 배열로 사용한 포인터의 경우 일단 "요소단위로 free 한 다음에" , 마지막으로 "이차원가변포인터를 free" 시켜야된다
			2. 이미 free 한 메모리를 또 free 하면 에러난다


------------------------------------------------------------------------------------------------------------------------------
5. 구조체
	: 선언 형식
		struct 구조체명{
			타입1 멤버명1;
			타입2 멤버명2;
			. . . 
		}

	: typedef 
		: 기본 사용법 >> typedef 이전이름 수정이름
			ex) typedef struct Node Node // 마지막 토큰인 Node 로 저장됨

		: 숏컷 사용법 >> typedef 구조체선언부 수정이름
			ex) typedef struct 쏼라{
 				. . .
			     } 수정이름;			

	: 구조체 변수 
		(1) 구조체 타입 
			:변수 생성 >> 구조체명 변수명;
			: 일반 타입 멤버 활용 
				값 사용 및 수정 >> 변수명.멤버명
				입력 받기 >> &변수명.멤버명 

			: 포인터 타입 멤버 활용 <---  변수명.멤버명 자체가 포인터.
				값 사용 및 수정 >> *변수명.멤버명
				입력 받기 >> 변수명.멤버명 

		(2) 구조체 포인터 타입 
			: 변수 생성 >> 구조체명* 변수명 = ( 구조체명 *)malloc( sizeof( 구조체명 ) );
			: 일반 타입 멤버 활용
				값 사용 및 수정>> 
					1. 변수명 -> 멤버명
					2. ( *변수명 ).멤버명
						: 참조연산자가 도트 연산자보다 우선순위 낮아서 필수적으로 괄호 표기 필요
	
				입력 받기 >> 
					1. &변수명->멤버명 
					2. &( *변수명 ).멤버명

		******: 포인터 타입 멤버 활용 <---  (*변수명).멤버명 과 변수명->멤버명 자체가 포인터.
				값 사용 및 수정 >> 
					1. *(*변수명).멤버명
					2. * 변수명->멤버명 

				입력 받기 >> 변수명.멤버명 
					1. (*변수명).멤버명
					2. 변수명->멤버명 


							

------------------------------------------------------------------------------------------------------------------------------
