0.
함수 내부서 수정되게 할 때 규칙
	0. arg : &변경대상
	1. 대상주소를 받는 param
		: 선언 >> 변경대상보다 * 하나 더 붙여서
		: 함수 내부서 활용 >> 파라미터 변수에 * 딱 하나만 붙여서
			: 파라미터가 변경 대상의 주소이므로 , * 를 하나만 씀면 변경 대상의 값에 참조할 수 있다

	2. tmp 변수
		: 선언 >> 파라미터변수 선언할때보다 * 하나 "덜" 붙여서
		: tmp 변수 활용  >> * 아예 안붙여서


	// 단일 포인터 간의 값을 swap
	void swapS(char**c1, char**c2) { // c1 == &arg , *c1 == arg
		char* temp = *c1;  // temp == *c1 
		*c1 = *c2;
		*c2 = temp;
	}


2. 포인터 배열은 이중 포인터로 받아서 쓸 수 있다. 단일배열을 '&' 연산자 없이 쌩 포인터로 받는 것처럼 , 포인터 배열명에도 안 붙이고 하는거다
	: 포인터 배열명이 이미 포인터인 0번째 요소의 주소니까 ** 타입.
	int * pA[8];
	int **pP = pA;

3. 이차원 배열을 수정하는 함수
	: 매개변수 >> 이차원배열의 요소사이즈단위 로 포인터 연산하게 된다
		1. int p[ ][사이즈] <-- 가까운거 생략하는거임 주의
		2. int (*p)[사이즈] <-- 괄호 생략하면 안되는거 주의





