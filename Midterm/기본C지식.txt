연산자 우선순위
	(1) -> .  멤버접근연산자 와 도트연산자
	(2) &  * 앰퍼샌드와 역참조연산자

------------------------------------------------------------------------------------------------------------------------------

Call By Value  << 암기 : C Val 씨 발

------------------------------------------------------------------------------------------------------------------------------
	
scanf( "형식지정자" , 주소 );
	: 2번째 arg가 주소
		>> 일반적인 변수의 경우 는 '&변수' 꼴
		>> 주소값저장변수의 경우는 '변수' 꼴 그 자체

------------------------------------------------------------------------------------------------------------------------------

%s 
	: 입력 받을 때 , 출력할 때 모두 주소를 대상으로 함 >> printf 할때도  주소값저장변수의 경우 '변수' 꼴 그 자체로 활용한다 >> 포인터명과 배열명 그대로 쓴다.

------------------------------------------------------------------------------------------------------------------------------

포인터 변수
	: 단순 포인터 변수 그 자체 == 변수 가리킬 수 있는 포인터 >> 배열의 기능 수행 불가
	: 동적할당된 포인터 변수 >> 배열의 기능 수행 가능

------------------------------------------------------------------------------------------------------------------------------
	
0. 문자열	
	: "문자열 리터럴" 저장하기
		: 문자열 리터럴은 끝에 '\0' null 문자 붙은 형태이고, 읽기 전용 메모리에 저장된다
		case1. 단순 char *포인터명 = "hell"
			: 읽기 전용 메모리를 가리키고 있어, 해당 위치에서 값의 수정( 복사 . 문자 수정 . )은 불가
				
		case 2. 동적할당된 공간에 strcpy 사용
			: 값의 수정이 가능하다.
			: 여기서 문자열 리터럴 할당하면, (값의 복사가 일어나는게 아니라) 동적할당한거 다 물거품되고, 그 문자열 리터럴 참조하는 걸로 끝나는거 주의.
			step 1 >>  char *포인터명 = (char* )malloc(sizeof( 문자열길이 ));
			step 2 >> strcpy( 포인터명 , 문자열저장변수혹은문자열리터럴)  


		case3. char 배열명[ ] = "hell" ;
			: 배열명이 문자열 배열을 가리키는게 아니라, 문자열 리터럴의 문자 하나하나 단위로 배열의 요소로 저장되는 거라 값의 수정이 가능하다.
			: 문자열 할당하고 남는 칸은 자동으로 NULL 문자 로 채워진다.
			: 선언 이후에는 적용 불가하다.
			: 사이즈 생략 가능하다


		case4. 배열에 strcpy
			: 선언 이후에도 가능하고, 값의 수정도 자유롭다


		: https://dojang.io/mod/page/view.php?id=1785




	: 문자열 입력 받는 방법
		(1) scanf("%s" , 문자배열명 );
		(2) scanf("%s" , 동적할당완료된문자포인터명 );


	:  <string.h> 의 문자열 관련 함수
  		(1) strcpy( 적용대상주소 , 당할대상주소 )
	 	(2) strcat( )
------------------------------------------------------------------------------------------------------------------------------


1. 배열	
	(0) sizeof(배열명)/sizeof(배열명[0]) == 배열 사이즈
	(1) 배열끼리의 복사 : 직접 for 문으로 일일이 복사하는 방법 밖에 없다
	(2) 배열명은 포인터 상수
		: 배열명 + i 는 가능하지만 배열명++ 는 불가
		: " 배열명1 = 배열명2; " 통한 복사 불가		
		: 포인터에 배열명은 할당 가능하지만, 배열명에 포인터 할당은 불가

	(3) 문자 배열에 문자열 저장하기
		(1) 선언과 동시에 가능 << 사이즈 명시 불필요
			1.중괄호 이용 할당  {  'h', 'e' , 'l' , 'l'  ,'\0' };
			2. 문자열리터럴 할당
		
		(2) 선언 이후에도 가능 : 인덱스 단위 저장
	
	(4) 배열에서 " 배열명 == &배열명 " 인 이유  
		: 배열의 0 번째 요소의 주소 == 배열자체의 (시작) 주소 이기 떄문


	(5) 1차원 배열을 수정하는 함수
		:  매개변수 >> 단일 포인터

		: 사이즈를 따로 받아야한다
			: 파라미터의 arg 로 배열을 받는다 해도, 파라미터 자체는 포인터 타입이라서 sizeof( 배열받은파라미터 ) 하면 무조건 4 밖에 안나와서 못구하기 때문
			: 그렇다고 인수부분에서도 sizeof 를 못쓰는거 아니다
				: 원본이 있는 영역에서 그 배열명은 배열명으로썽의 ㅇ역할을 하기 때문에 sizeof()을 통해 정상적으로 사이즈를 구할 수 ㅇ있다.

 
	(6)  ary[ i ] == *(ary+i) 
		: ary+i == i 번째 요소의 주소
		: *( ary + i ) == i 번째 요소의 값

			
2. 이차원배열
	(1) 배열표현을 포인터 표현화  ary[ i ][ k ] ==  *( *(ary+i) + k ) 
		: ary + i == i 번쨰 요소의 주소  ==  i번쨰 1차원배열의 주소 ==    &( i번쨰1차원배열명 ) 
		: *( ary + i ) ==  i 번쨰 요소의 값   ==  i번쨰1차원배열명 
			: 이떄 ary + i 값과 *( ary + i ) 값이 같게 나오는 것은 , 배열명값 ==  배열자체의주소값이라서.

		:  *(ary+i) + k  == i 번쨰 1차원 배열의 k 번쨰 요소의 주소
		: *( *(ary+i) + k )== i 번쨰 1차원 배열의 k 번쨰 요소의 값


	(2) 이차원 배열을 수정하는 함수
		: 매개변수 >>  단순 **p 가 아님을 주의
			1. int p[ ][사이즈] 혹은  int (*p)[사이즈]
				: p 를 걍 2차원 배열명처럼 활용 가능
				: int [ 사이즈 ]  단위로 연산함.
				int ary[ i ][ k ] vs int p[ ][ k ]  와  int (*p)[ k ] 
					: 다른점>> ary 는 int [k] 타입 요소를 i 개 제한해서 가지지만 , p 는 딱히 제한이 없음
					: int ary[n] 과 int *p 관계와 비슷한거임

			2. int *p   <--별도로 i 에 조작질해줘야됨









------------------------------------------------------------------------------------------------------------------------------


2. 포인터

	(1) 선언 : 자료형 * 포인터명;
		: 선언할때 쓰이는 * 은 간접참조연산자가 아닌 그냥 일반적인 변수와 포인터 변수의 선언을 구분하기 위한 기호

		: 가리킬변수의자료형== 포인터명 앞의 선언용 * 하나 때고 남은 형태
			: 이 타입으로 포인터연산을 하게 된다.

		: 포인터의 자료형 == 포인터명 앞 전체부분
			ex) int **b ; // int * == 가리킬변수의 자료형 , int ** == 포인터의 자료형


	(2) 초기화 >> 변수의 주소나 동적할당결과의 주소값으로 초기화한다.
		: 포인터는 반드시 초기화 한 이후에 활용가능하다.
			


	(3) 포인터의 크기 
		: 포인터들끼리 자료형이 다르더라도 포인터의 크기가 같다
			: 32비트 운영 체제 기준 4바이트
			: 포인터들끼리 크기가 같은데도 가리킬변수의 자료형을 명시하며 선언하는 이유는 참조단위, 포인터 연산단위를 결정하기 위함이다.



	(4) 포인터 연산
		:주소가 정수값이긴 해도 일반적인 정수와 다르게 다루어진다.
		:주소 + 정수 == 주소 +  (정수*변수크기)
		: ex)
			int a = 10;
			int *p = &a; // &a ==0 일때
			printf("걍p: %d , p+1 = %d", p , (p+1));  //p == 0 이고 , p+1 == 4 이다


	(5) 이중포인터: 포인터의 주소를 값으로 하는 변수
		선언형식
			자료형* * 이중포인터명;
				: 가리키는 단위는 (자료형*) 
				: 이중포인터의 자료형은 (자료형**) 

		초기화형식
			이중포인터명=&포인터명;

		헷갈정리
			이중포인터명 == 단일포인터주소
			*이중포인터명 == 단일포인터값==단일포인터가참조하는변수주소
			**이중포인터명 == 변수값 == 단일포인터가참조하는변수의값

		활용
			1. 포인터값을 바꿀때(포인터가 어떤 변수를 가리킬지를 바꿀때) 매개변수로 사용
			
			2. 포인터배열을 매개변수로 받는 함수
				배열명 == '0번째 요소의 주소' 이므로 배열명도 일종의 포인터라고 할 수 있다(변경이 불가한 것 뿐)
				따라서 포인터배열명 == '0번째 요소의 주소' == '포인터의주소' == '이중포인터명'


	(6) 포인터 배열과 배열 포인터
		포인터 배열 : 타입 * 포인터명[ n ]  >> n개의 포인터를 요소로 하는 배열
			: char *배열명[ ] : 문자열 저장에 유리
			ex) char *array[ ]={"apple","pie","yummy"};


		배열 포인터 : 타입 (* 포인터명) [ n ] >> n 사이즈 배열을 가리키는 포인터 하나
 			: int p[ ][사이즈]  ==   int (*p)[사이즈] 는 이차원 배열을 할당받을 수 있다
				: 가까운 [ ]  하나를 * 화 할 수 있다 <-- 암기 tip  귀찮으니 가까운 옷 입는다.



	(7 )포인터 상수
		: 가리키는 대상을 변경할 수 없지만, 가리키는 대상의 값의 수정은 가능하다
		: 배열명도 포인터 상수이기 때문에
			: 배열명 자체로는 값의 수정이 불가
			: 역참조연산자 쓰는 경우 거기에 저장하고 있는 값을 바꾸는 거라 수정이 가능
			: 앰퍼샌드 써서, 해당 위치에 입력 값을 저장 가능

	(8)void 포인터
		: 변수의 자료형을 고려하지 않고 주소값만 저장
			: 이 상태로 void 포인터가 가리키는 대상을 수정할 수 있다. 포인터니까.
			: 이 상태론 읽지 못한다. 타입이 미정인 상태이기 때문.
		: 값을 읽기 직전까지만 형변환 제대로 해주면 된다.
		: https://reakwon.tistory.com/19



	(9) 함수 내부서 수정되게 할 때 규칙
		0. arg : &변경대상
		1. 대상주소를 받는 param
			: 선언 >> 변경대상보다 * 하나 더 붙여서
			: 함수 내부서 활용 >> 파라미터 변수에 * 딱 하나만 붙여서
				: 파라미터가 변경 대상의 주소이므로 , * 를 하나만 씀면 변경 대상의 값에 참조할 수 있다

		2. tmp 변수
			: 선언 >> 파라미터변수 선언할때보다 * 하나 "덜" 붙여서
			: tmp 변수 활용  >> * 아예 안붙여서
		






------------------------------------------------------------------------------------------------------------------------------

동적할당 - malloc , realloc , calloc
	: sizeof내부변수타입의포인터레벨 - " 1 "  == 동적할당받는변수타입의포인터레벨 == malloc 강제형변환레벨 
		:  특정타입* 변수명 = (특정타입*) malloc ( sizeof( 특정타입 )* n );
	
	: 사실 malloc, calloc 로 할당한 메모리 초과해서 써도 당장은 적용잘 되고, 문제가 드러나지 않는다. 그런데 realloc 같은거 적용하면서 저장 위치가 바뀔때 메모리 초과 부분의 값까진 복사 안해가기 때문에 문제가 생긴다.
		int* i = (int*)malloc(sizeof(int)*10);
		for (int j = 0; j < 12; j++)
			i[j] = j;
		for (int j = 0; j < 12; j++) {
		printf("%d ", i[j]);
		printf("realloc 전 주소:%p\n",i+j); }
		printf("\n\n");
		i=realloc(i,150* sizeof(int));
		for (int j = 0; j < 12; j++) {
		printf("%d ", i[j]); printf("realloc 후 주소:%p\n", i + j); }

	(1) void * malloc( n * sizeof( 변수 ) ) >> 초기화 x + 동적할당
	(2) void * calloc( n ,  sizeof( 변수 ) ) >> 초기화 0 + 동적할당
		: 통상적으로 n 을 더 먼저쓰긴 해도, n (요소갯수) 와 sizeof 의 순서는 딱히 중요하지 않다. 어차피 n*sizeof(변수) 로 계산됨.


	(3) void * realloc(  메모리공간수정대상포인터변수 ,   n * sizeof( 변수 ) ) >>  기존값을 유지하며 메모리의 사이즈를 변경

		: 주의 
			0. 2번째 arg 는 malloc 의 arg 처럼 사이즈 표현한다.
			1. 기존 영역이 아닌 아예 새로운 영역에 메모리가 잡힐 수도 있어서, 반환값 받아서 업데이트까지 해줘야된다
			2. realloc 로 쓸모 없어지는 메모리는 자동 수거되기 때문에 직접 free 하지 않는다

		: 크기를 늘리는 경우  >> 기존 메모리 영역의 뒷 부분의 사이즈를 늘리거나, 아예 다른 곳에 해당 크기의 영역이 새로 잡힌다
		: 크기를 줄이는 경우 >>  기존 메모리 영역에서 뒷 부분이 줄어든다

 
		: https://untitle-ssu.tistory.com/69
		: https://thinkpro.tistory.com/66




메모리반환 : 메모리 누수를 방지하고자 메모리 공간을 공용 메모리로 돌리는 작업
******memory leak >> 더이상 사용하지 않는 메모리를 계속 붙잡고 있어서 과부하 걸리는것
	free( 포인터 ) 
		: 주의 
			0. 메모리 해제 후 해당 메모리를 사용한다고 해서 에러가 나진 않으며, ( free 직후 값은 쓰레기 값으로 채워져있지만 ) 해당 메모리에 값을 저장했을 때 웬만하면 값이 잘 저장된다.
				: 그런데도 사용을 금하는 이유는 이 메모리는 현재 프로그램의 것이 아니라 침범 당할 수 있기 때문.
			1. 이미 free 한 메모리를 또 free 하면 에러난다
			2. 일차원 가변적 배열로 사용한 포인터의 경우 걍 그 포인터만 free 시키면 되지만, 이차원 가변젹 배열로 사용한 포인터의 경우 일단 "요소단위로 free 한 다음에" , 마지막으로 "이차원가변포인터를 free" 시켜야된다


------------------------------------------------------------------------------------------------------------------------------
5. 구조체
	: 선언 형식
		struct 구조체명{
			타입1 멤버명1;
			타입2 멤버명2;
			. . . 
		}

	: typedef 
		: 기본 사용법 >> typedef 이전이름 수정이름
			ex) typedef struct Node Node // 마지막 토큰인 Node 로 저장됨

		: 숏컷 사용법 >> typedef 구조체선언부 수정이름
			ex) typedef struct 쏼라{
 				. . .
			     } 수정이름;			

	: 구조체 변수 
		(1) 구조체 타입 
			:변수 생성 >> 구조체명 변수명;
			: 일반 타입 멤버 활용 
				값 사용 및 수정 >> 변수명.멤버명
				입력 받기 >> &변수명.멤버명 

			: 포인터 타입 멤버 활용 <---  변수명.멤버명 자체가 포인터.
				값 사용 및 수정 >> *변수명.멤버명
				입력 받기 >> 변수명.멤버명 

		(2) 구조체 포인터 타입 
			: 변수 생성 >> 구조체명* 변수명 = ( 구조체명 *)malloc( sizeof( 구조체명 ) );
			: 일반 타입 멤버 활용
				값 사용 및 수정>> 
					1. 변수명 -> 멤버명
					2. ( *변수명 ).멤버명
						: 참조연산자가 도트 연산자보다 우선순위 낮아서 필수적으로 괄호 표기 필요
	
				입력 받기 >> 
					1. &변수명->멤버명 
					2. &( *변수명 ).멤버명

		******: 포인터 타입 멤버 활용 <---  (*변수명).멤버명 과 변수명->멤버명 자체가 포인터.
				값 사용 및 수정 >> 
					1. *(*변수명).멤버명
					2. * 변수명->멤버명 

				입력 받기 >> 변수명.멤버명 
					1. (*변수명).멤버명
					2. 변수명->멤버명 


							

------------------------------------------------------------------------------------------------------------------------------
