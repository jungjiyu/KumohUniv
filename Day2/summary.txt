jdk 는 ide 가 아니다. 
사실 Eclipse 도 ide(Intergarted Development Enviorment 즉 통합개발환경) 는 아니다. jdk 를 따로 설치해야하기 때문
	: VS code 는 실제로 IDE 이다 << 설치할떄 컴파일러까지 한번에 설치된다.

자바의 특성
	1. 플랫폼 독립성 << 운영체제에 제한 받지 않는다
	2. 객체 지향 << 추상화 상속 캡슐화 다형성 의 특징을 가짐
	3. 클래스로 캡슐화 << 모든 내용은 클래스의 내부에 적어야됨
	4. 소스코드(.java) 를 컴파일하면 바이트코드(.class)파일 이 만들어짐
		: .java 파일
			: 파일명은 내부의 "public" 클래스 명과 같음
			: 하나의 소스 파일에 여러개의 클래스를 작성 가능하지만 public 클래스는 하나만 가능(더도 덜도 안됨)
				: public class 는 해당 소스파일을 대표하는 클래슨데 모든 클래스가 .java 파일을 대표할 순 없기 떄문


			: main 메서드
				: 실행할 내용을 적음
				: arg 로 String[] args 주는 의미
					: 명령 프롬프트(명령 라인)에서 입력 받을 수 있게 함
					: 입력하면 띄어쓰기를 기준으로 입력된 내용을 문자열 타입으로 args 배열에 저장함
					: 별로 안중요해보이나 궁금하면 혼공자p.186 참고
				: 클래스 별로 하나 가질 순 있긴 하는데 보통 전체 애플리케이션에 한개 두는 편

 

		:클래스 파일
			: 프로젝트 폴더의 bin 폴더 들어가면 확인 가능하다
			: 클래스 파일에는 하나의 클래스만 존재
				.java 파일 단위로 class 파일 이 만들어지는게 아니라 '클래스' 별로 클래스 파일이 만들어짐
			: 클래스 파일명
				: 그냥 (바깥) 클래스 (public 이건 default 이건)
				: (중첩클래스의) inner 클래스
					: 중첩 클래스도 하나의 클래스 이기 때문에 컴파일하면 바이트코드파일(.class) 가 별도로 생성됨
					: 종류
						: 멤버 클래스일 경우 바이트 코드 파일명) 바깥클래스$멤버클래스.class
						: 로컬 클래스일 경우 바이트 코드 파일명) 바깥클래스$1로컬클래스.class


				

	5. 여러 클래스를 패키지로 묶어 관리
	6. 멀티스레드지원
		: "운영체제"의 도움 없이 자체적으로 멀티스레드를 지원한다
	***7. 가비지 컬렉션
		: 자바 언어는 메모리 할당 기능은 있어도 메모리 반환 기능은 없다
			: 아무한테도 참조당하지 않는 데이터는 GC 에 의해 자동 반환 된다

	8. 포인터 개념이 없음
	9. 타입 체크가 엄격
	10. 자바는 바이트 코드를 인터프리터 방식으로 실행
		: 주의 ) 소스 코드 자체는 바이트 코드로 '컴파일'하는거고, 바이트코드는 '인터프리터' 방식으로 번역하는거다
		: https://hyeinisfree.tistory.com/26
		: https://velog.io/@bcj0114/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EC%99%80-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-JIT-%EC%BB%B4%ED%8C%8C%EC%9D%BC
		: JDK 의 javac 컴파일러(==자바 컴파일러)로는 소스코드(.java)를 바이트코드(.class)로 컴파일하는거고, JVM의 JIT 인터프리터로는 바이트코드(.class) 를 바이너리코드로 핝줄씩 번역하여 실행하게된다.

		: 인터프리터를 사용하는 이유
			1. 운영체제 종속성을 가지지 않게 하기 위하여 >> JVM 만 바꾸면 운영체제 상관없이 바이트 파일 돌릴 수 있음
			2. 초기 실행 속도를 빠르게 하기 위해
				: 매번 실행할때마다 바이트 코드 전체를 읽어 컴파일하게 되면 초



모듈 기능 해제하고 프로젝트 만들어라

자바의 경우는 역컴파일이 가능하다
	: 컴파일된 바이트 코드로 소스 코드를 쉽게 만들 수 있다
		: 편하긴 한건데 보안에 취약하다
