
vanilla JavaScript :  프레임워크 또는 라이브러리가 적용되지 않은 순수한 자바스크립트

cascading : 폭포, 계곡 같은거. 
	: 쥴쥴이 흐르는거
	: 스타일이 한군데서 나오는게 아니라 줄줄이 적용이 되서 최종스타일이 나오는거다

선택자 : 특정 요소들에 대한 스타일 규칙을 정의
	: 종류
		1. 타입선택자 >> 특정 태그
			: html , body 같은 것도 선택자로 사용 가능
		2. 전체 선택자(universal selector) >> *
			: 해당 페이지 내의 모든 요소를 선
		3. 클래스 선택자(class selector) >> .클래스
			: 해당 페이지서 여러 요소에 적용 가능하능
			: 클래스 선택자로 정의된 스타일 규칙을 쓰기 위해선 해당 요소의 태그에 class="클래스명" 를 명시하면됨
				: 한 요소에 여러개의 클래스 스타일을 적용 가능하고 이 경우 각 클래스는 띄어쓰기로 구분하여 class="클래스명1 클래스명2 클래스명3.. " 이런식으로 쓴다
				: .클래스명이 아님을 주의

		4. 아이디 선택자(id selector)>> #id
			: 해당 페이지서 특정 요소 하나에만 적용 가능
			: 아이디 선택자로 정의된 스타일 규칙을 쓰기 위해선 해당 요소의 태그에 id="아이디명" 를 명시하면됨
				: #id 명이 아님을 주의

		4. 후손 선택자 (desendent selector) >> 조상태그명 후손태그명
			: 띄어쓰기로 구분하여 태그명을 2개 명시한다
			: 후손 관게) 그냥 대상 태그를 포함하고 있기만 하면 된다. 직접적으로 포함하고 있지 않아도 된다
			: https://aboooks.tistory.com/286#google_vignette
		5. 자식 선택자 (child selector)>> 부모태그명 > 직계자식태그명
			: 자 관게)  직접적으로 대상 태그를 포함하고 있어야된다

		5. 의사 선택자(pseudo-class) >> 
			: 없는데 있는것처럼 해주는거

선택자 그룹 >> 여러 선택자를 , 로 구분 하여 한번에 스타일 규칙을 적용하는것


후손, 자식 선택자
s1 s2 >> s1 요소에 포함된 요소
s1 > s2   >> s1 요소의 직계 자식 요소

클래스 >> 부류
뇌피셜 >> # == 뭔가 순서적 . == 뭔가 객체 접근적

UI는 일관성을 지켜야 한다. >> 페이지 이동할때마다 폰트 바뀌면 ㅈㄴ 이상
스타일 시트를 통해 유지보수성을 높일 수 있따. 컨텐트와 스타일을 분리할 수 있다

: 주석 헷갈려하지 말라


jQuery : 표준 코드를 좀더 간결하게 표현할 수 있게 해주는 라이브러리
	: 예전엔 썼지만 요즘엔 안쓴다. 

자바스크립트에서는 이름이 $로 시작 가능하다(다른 언어에서는 _ 는 되도 $는 안된다 ) 	

Bootstrap 
	: vanila javascript 많이 좋아졌다. 
	: Bootstrap 5 has switched to vanilla JavaScript instead of jQuery. 
		: jQuery 안쓰는거 보고 vanila  javascript 라고 한다. 그러니까 jQuery 가 안들어간 순수한 이란 뜻이다
 
Pseudo class != Pseudo element 
	: 의사 클래스가 특정 상태나 조건을 만족하는 요소를 선택하기 위해 사용하는 키워드라면, 의사 요소는 문서 내에서 기본 선택자로 선택하기 어려운 부분에 스타일을 지정하거나 가상의 요소를 만들어 추가하기 위해 사용하는 키워드

	' :: ' >> element
	' : ' >> class
:before >> 해당 태그 사이의 모든 앞부분에 뭔갈 붙여준다
:before >> 해당 태그 사이의 모든 앞부분에 뭔갈 붙여준다

:link >> 아직 방문전인 하이퍼링크
:visited >>  방문된하이퍼링크


부모, 자식 앨리먼트
	: 바깥쪽 감싸는 엘리먼트 == 부모
	: 안쪽에 감쌈 당하는 엘리먼트 == 자식

css 의 상속
	: 부모 엘리먼트의 속성이 자식 엘리먼트에도 적용되는 것
	: 자식 엘리먼트에서 직접 지정한 스타일은 부모의 스타일에 대하여 우선순위를 가진다
	: 속성 중에는 상속이 안되는 것도 있는데, 강제 상속할 수도 있다
		: "자식" 앨리먼트에 style 속성에서 해당 속성명을 명시하고, 실제 값대신 inherit 를 대입함 된다
		: 뇌피셜이지만 편의성에 의해 상속 여부가 갈리는 것 같다

캐스캐이딩
	: 엘리먼트 간 css의 충돌을 피하기 위해 도입한 우선순위. 질서	
	: 기준
		1. 중요도 : css 가 선언된 위치가 어디인가
			(1) 브라우저의 css >> 별도로 css 를 설정 안했을때 브라우져서 설정한 기본적으로 적용되는 스타일
			(2) 저작자 css 일반선언 >> 그냥 개발자가 important 없이 선언한 스타일
				: 저작자 >> 게빌자

			(3) 저작자 css 의 important >> 개발자가 important 와 함께 선언한 스타일

		2. 명시도: 대상을 얼마나 명확하게 특정하ㅕㅆ는가
			(1) 타입 
			(2) 클레스
			(3) id
			(4) 인라인으로 직접 기술

		3. 소스 순서: css 선언을 나중에 할수록 우선순위가 높아짐
			: ex) 아래에서 p 태그에는 color = black 이 적용된다
				p{ color: green; }
				p{ color: black; }



https://www.w3schools.com/cssref/trysel.php
+ == next
~ == siblling. 같은 부모를 공유하는
태그명.클래스명 >> 특정 태그중 그 클래스를 갖는
[id] >> id 가 정해진 얘들ㄹ
ㅔ[


외부 스타일 시트: 많은 페이지에 동일한 스타일을 적용하려고 할 때 좋은 방법
	: import 하는 법
  <link type="text/css" rel="stylesheet" href="경로">

인라인 스타일 시트: 2개 이상의 선언이 있다면 반드시 끝에 ;을 적어 준다.

크롬 개발자 도구 쓰면 스타일이 뭐가 적용됬는지 알수 0

F2 >> 해당 이름을 한꺼번에 바꿔줌

