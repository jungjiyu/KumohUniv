문서의 콘텐츠는 HTML 로 정의하고, 문서의 스타일은 CSS 를 이용하여 지정한다

CSS Cascading Style Sheet 
	: html 의 스타일을 정의하는 시트
	: 왜 필요한가? >>
		1. 컨텐츠와 스타일을 분리하여 관리할 수 있다
		2. 재사용하기 쉽다
		3. 유지 보수가 쉽다. 하나만 수정하면 되니까.

	: CSS를 추가하는 방법
		1. 인라인 스타일 시트 : 태그 내부에 직접 표기
		2. 내부 스타일 시트:  html 문서의 style 태그 안에 명시
		3. 외부 스타일 시트:  .css 확장자의 파일에 작성하고, 이를 html 파일 내부의 <link> 태그로 연결하여 사용
			<link type="text/css" rel="stylesheet" href="파일명.css">
	: 문법
		선택자 { 
			속성1:값1;
			속성2:값2;
			. . .
			} 

	: 선택자 >> 말 그대로 html 요소를 선택하는 부분
		: 왜 유용한가? >> 여러 요소에 한번에 스타일의 지정이 가능
		: 종류
			: 섞어쓰는거 tip
				(1) 부모태그 * == 해당 부모 태그 내의 모든 후손 태그들
				(2) 특정태그.클래스명 == 특정태그가 해당 클래스인 경우
				(3) 의사 클래스, 요소는 여러개 연속으로 쓸  수 있다
				(4) 의사클래스,요소를 연달아 쓴 경우 and 연산자 처럼 작동한다고 봄 된다.
				(5) 자식/후손 선택자와 의사선택자는 분배법칙처럼 사용할 수 없다. 
					: 앞에 부모 선택자 하나 쓰고 그 뒤에 자식들을 콤마로 구분하여 쓴다고 그 자식들을 자식들로 인식하는게 아니다. 
						
					: 그룹 선택자 쓰고 맨 뒤에 의사클래스.요소 쓴다고 각각의 선택자에 적용되는게 아니다. 
						
					:실제로 그룹 선택자를 이용하여 각각 적용시키고 싶담 각각의 선택자에 일일이 적어줘야된다
						ex) div p,a >> div 의 후손 p 태그 와 그냥 a 첫번째 a 태그
						ex) div p , div a >> div 의 후손 p 태그 와 div의 후손 a 태그
						ex) div p,a:first-child >> div 의 후손 p 태그 와 그냥 a 첫번째 a 태그								ex) div p:first-child  , div a:first-child  >> div 의 첫번째 후손 p 태그와 div의 첫번째 후손 a 태그

			1. 아이디 선택자 : "#아이디명"
			2. 클래스 선택자: ".클래스명"
			3. 타입 선택자 : "HTML요소명"
			4. 전체 선택자 : "*"
			5. 속성 선택자 
				(1)  "HTML요소명[특정속성명]" : 해당 HTML 요소가 특정속성을 가지기만 하면 해당 스타일을 적용시킨다
				(2) "HTML요소명[특정속성명=특정속성값]" : 해당 HTML 요소가 특정속성을 가지고, 특정속성값을 만족할떄 해당 스타일을 적용시킨다.

			6. 선택자 그룹 : 여러 선택자를 콤마로 나열하여 한꺼번에 지정하는 것

			7. 후손, 자식 , 형제 선택자 
				: 부모가 자식보다 앞에 오는거 , 형이 동생보다 앞에 오는거 주의
				(1) "s1 s2" : 후손 관계 >> s1 요소 내부에(바로 아래든 그그그그 아래든 ) 포함된 s2 요소를 "모두" 선택(최초만 선택이 아님)

				(2) "s1 > s2" : 자식 관계 >> s1 요소 바로 한단계 아래에 포함된 s2 요소를 "모두" 선택(최초만 선택이 아님) 
					: 기호 암기 tip >> 자식보다 부모가 더 크니까 "부모 > 자식"
			
				(3) s1 + s2 : 인접 형제 선택자 >> 같은 부모를 가지면서 s1 의 "바로" 뒤에 오는  (s1 바로 뒤에 연속으로 s2 가 오더라도) 최초의 "s2" 에 대하여만 적용한다
		
				(4) s1 ~ s2 : 일반 형제 선택자 >> 같은 부모를 가지면서 s1 의 뒤에 오는 모든 s2 에 대하여 적용한다. (최초만 선택이 아님) 
					: 기호 암기 tip >> ~ 는 좀 널널한 느낌.. + 는 좀 깐깐한 느낌. (교수님한테 + 달아달라고 하기 좀 까다로우니까)

			8. 의사 선택자 :
				: 의사 클래스, 의사 요소는 다른 선택자의 뒤에 명시하여 사용한다
					: 의사클래스, 의사 요소를 단독으로 선택자로 사용하여 스타일 규칙을 정의할순없다

				: 기호 암기 tip >> 요소 -->효소 -- >가루 많이 날린다. :: 이다.
 				(1) 의사 클래스 Pseudo Class : 기존 요소가 특정한 상태를 만족할떄만 발현되는 스타일 규칙을 정의한다
					형태) 앞에 : 가 붙은 형태
						1. 자식 관련
							: 주의 ) "부모선택자 :first-child"  ,  "부모선택자 :only-child" ,"부모선택자 :nth-child(n)" 이런식으로 부모 선택자만 단독으로 쓰면 각각 첫번째, n 번째로 등장한 "부모"선택자에 대해서 해당 스타일이 적용되지, 해당 선택자의 n번째 자식에게 적용되는게 아니다. 이름에 "child" 가 들어간건, 보통 "부모선택자 자식선택자:first-child", "부모선택자 자식선택자:nth-child(n)" 이런 식으로 부모와 자식 관계를 형성하는데 많이 사용해서 그런거다.
								: 보통  "부모선택자 자식선택자:first-child" , "부모선택자 자식선택자:nth-child(n)" 으로 쓰지,  "부모선택자>자식선택자:nth-child(n)"  으로 쓰진 않는 것 같다.

							(1) :first-child << 해당 자식 태그가 부모태그의 "첫번째" 자식 태그일때 발현되게 한다
								: 단순히 해당 부모태그 내부에서 해당 종류의 태그들 중에서 첫번째이기만 하면 적용된다는게 아니라, 실제로 그 자식 태그가 "통틀어" 첫번째여야 적용된다.
							(2) :last-child << 마지막 자식 요소에 한하여 발현되게 한다
							(3) :only-child << 부모가 해당 자식 요소 딱 하나만 가질때 발현되게 한다
								: 단순히 해당 부모태그 내부에서 해당 종류의 태그가 하나만 존재하 면 적용된다는게 아니라, 실제로 그 자식 태그가 "통틀어" 딱 하나여야 적용된다.

							(4) :nth-child(n) << 요소의 n번째 자식에 한하여 발현되게 한다
								: 괄호 내부에 대입 가능한 값
									(1) 숫자 >> 1 부터 사용 가능하다
									(2) n을 이용한식
										: 어떤 형태의 식을 쓰느냐 따라 n 의 시작범위가 다르니 주의 >> 상수 부분 있을땐 n=0부터 시작, 상수 부분 없을떈 1 부터 시작. 
										1. kn >> k 번째 자식요소마다
											: 이때는 n=1,2,3 .. 이라고 봄 된다
										2. n + k >> k번째 자식 요소부터 쭉
											: 이때는 n =0,1,2,3 .. 이라고 봄 된다
										3. an + b>> b번째부터 a개 마다 선택
											: 이때는 n =0,1,2,3 .. 이라고 봄 된다
											: a 는 음수면  b 번째 부터 앞방향으로 a개 마다 이고, a가 양수면 b 번째부터 뒷 방향으로 a개마다 이다.

									(3) 키워드 
										1. odd >> 홀수 번째 자식 요소마다 적용
										2. even >> 짝수 번쨰 자식 요소마다 적용

						2. 해당 요소의 상태 관련
							: ㅈㄴ 주의 ) 덮어쓰임 당하지 앟기 위해 정의 순서는 link ->visited ->hover -> active 로 해야됨
								: https://webstandards.tistory.com/5

							(1) :hover >> 마우스 오버 됬을떄 발현할 스타일 정의
							(2) :active >> 마우스 클릭했을때 발현할 스타일 정의
							(3) :link >> 방문 전인 하이퍼링크에 적용할 스타일 정의
							(4) :visited >> 방문된 하이퍼링크에 적용할 스타일 정의


				(2) 의사 요소 Pseudo element : 기존 요소에 특정 컨텐츠, 스타일을 추가한다
					형태 ) 앞에 :: 가 붙은 형태
						1. ::before , ::after << 요소의 앞, 뒤 부분에 특정 컨텐츠 추가 + 그 컨텐츠의 스타일 정의
							: content 속성을 명시하고, 특정 컨텐츠를 할당한다. 그리고 이와 함께 정의된 스타일은 해당 content 부분에만 적용된다.

						2. ::first-letter << 요소의 앞 글자의 스타일 정의
							: 따로 content 를 할당하는것 없이 첫 글자에 대한 스타일만 정의한다
					

	: 스타일 우선순위
		1. 중요도
			(1) 개발자가 !import로 선언
			(2) 개발자가 그냥 선언
			(3) 브라우져의 기본 선언

		2. 명시도 : 대상을 얼마나 명확히 특정했는가
			(1) 인라인으로 직접 기술
			(2) id
			(3) 클래스
				: 개발자가 아무리 클래스에 대한 정의를 먽저하고, 타입에 대한 정의를 더 나중에 했더라도 명시도 측면에선 클래스가 타입보다 더 우선이기 떄문에, 공통된 스타일 속성에 대한 정의는 클래스의 정의를 따라가게 된다.
			(4) 타입

		3. 순서 : 개발자가 더 나중에 선언할 수록

	:f12 에서 적용된 스타일과 적용되지 않은 스타일
		: 더 위에 있을 수록 나중에 정의 된거
		: 흐린 글자는 지정은 됬으나 적용되지 않은 스타일
		: 취소줄이 들어간 것은 (F12의) 하단에 지정하였으나, (F12)의 상단에서 재정의하여 취소된 스타일이다.

	: 스타일의 상속
		: 스타일을 위에서 아래로. 즉 부모 요소의 스타일을 자식 요소에게 전달한다. 해당 자식 요소에 별다른 스타일 지정이 없으면 부모의 스타일이 적용되게 된다
			: 상속이 안되는 일브 스타일도 있다.


	: 사용 가능한 값의 단위
		: html5 부터는 단위를 명시하지 않으면 오류난다. 반드시 단위를 써줘야 된다.
		절대 단위
			1. px : 픽셀 << 사용 개추
			2. pt : 포인트 << 사용 비추
			
		상대 단위
			 % : 부모 element 를 기준으로 함
			em : 부모 element 를 기준으로 함 >> 비추
			rem : root element 를 기준으로 함 >> 개추

	: 배경 관련 속성
		background-color: 배경색
		background-image : 배경 이미지

	: 폰트 관련 속성
		font: 한 줄에서 모든 폰트 속성 설정 가능
			: "폰트스타일 글자두께 글자크기 글꼴" 값 할당 가능
				: 암기 tip ) swf 스위프트
			: 꼭 다 명시하지 않아도 문제 없지만, 없는걸 명시하면 오류난다.

		font-family: 폰트의 스타일 설정 
			: 할당 가능한 값의 형태의 종류
				1. 쌩폰트명
				2. "폰트명"
				3. '폰트명'
			: 여러 폰트명을 , 다양한 형태로 할당 가능 ex) font-family: "맑은 고딕체", 'times' ,serif
			: font-family 를 통한 폰트의 종류는 어차피 1개 밖에 설정 안되는데 굳이  여러개 쓰는 이유
				: 해당 폰트가 사용 불가능한 경우를 대비하는 것.
				: 마지막에는 항상 일반적인 폰트를 지정하도록 한다.

		font-weight : 텍스트 굵기
			: bold, bolder 와 같이 글자를 할당할 수도 있고, 단위를 써서 명확히 할 수도 있다

		font-size: 텍스트 크기
	******font-style:italic 이텔릭체 설정
			: 기본값은 normal 이고, 이탤릭체 쓰려면 italic 을 할당해야된다.

	: 텍스트(인라인 콘텐츠) 관련 설정
		color : 텍스트 색상

		text-decoration: 텍스트 밑의 밑줄 설정
			: text-decoration으로 한꺼번에 "줄위치 색깔 스타일 굵기" 설정 가능
				: 암기 tip ) lcst 라코스테
			: 세분화 속성 ) 
				: text-decoration-line >> none, underline, overline, line-through (줄의 위치 설정)
					: 암기 tip- location 이니까, l로 시작하니까 style 이 아닌 line
				: text-decoration-color 
				: text-decoration-style >>  solid dotted wavy double(줄의 모양 결정)
				: text-decoration-thickness	

		text-align : 텍스트 "정렬"
			: https://codingeverybody.kr/css-text-align-%EC%86%8D%EC%84%B1/
			1. justify : 양쪽으로 정렬. 그러니까 보기좋게(?) 해당 라인 박스를 꽉 채움
				: 주의 
					(1) 텍스트 사이에 간격이 하나라도 있어야 적용 가능
					(2) 블럭 태그 처럼 해당 라인 자체를 꽉 채운단 말은 아님 (물론 라인 박스의 사이즈가 100% 라면 그렇게 되긴 하겠지만.)

			2. start : 시작하는 지점에 찰싹 붙는다
				: direction 의 속성 값이
					ltr 인 경우 >> left 값과 동일
					rtl 인 경우 >> right 값과 동일

			3. end : 끝나는 지점에 찰싹 붙는다
				: direction 의 속성 값이
					ltr 인 경우 >> right 값과 동일
					rtl 인 경우 >> left 값과 동일

			4. left : 왼쪽 정렬
			5. right ; 오른쪽 정렬
			6. center : 중앙 정렬


		direction : 텍스트 "작성" 방향 설정
			1. ltr >> 디폴트 값
			2. rtl : 오른쪽에서 왼쪽으로 쓰여지고, 오른쪽에 붙는다.
				: 주의!!! ) 한글이나 영어처럼 왼쪽에서 오른쪽으로 쓰는 언어는 rtl 을 입력하면 단순 오른쪽에 붙는것처럼 보이지만, 아랍어와 같이 오른쪽에서 왼쪽으로 쓰여지는 글자는 오른쪽으로 붙을 뿐 아니라 글자가 거꾸로(?) 쓰여진다.
				: https://mine002.tistory.com/116

		letter-spacing : 글자 간 간격 설정
		line-height: 텍스트 줄의 높이 설정
		
	: 리스트 관련 설정
		list-style : 리스트 스타일 지정
		
	: 레이아웃 관련 설정
		padding: 요소의 border 과 content 영역 사이의 간격을 조정
		border : 경계선 결정


: 색상의 표현
	: 색상은 숫자가 더 클수록 "밝은"색을 나타낸다.
	1. 16진수코드 >> #XX XX XX 
		: 두개마다 차례대로 R G B 를 나타내게 된다
		: X 는 0~F
		: 항상 # 로 시작한다.

	2. 10진수 (rgb) 표현 >> RGB( n , n , n )
		: 0 <= n <= 255
	3. 퍼센트 (rgb) 표현 >> RGB( 몇% , 몇% , 몇% )
	4. 이름으로 표현 >> "red" , "springgreen" , .. 
		
 
