문서의 콘텐츠는 HTML 로 정의하고, 문서의 스타일은 CSS 를 이용하여 지정한다

CSS Cascading Style Sheet 
	: html 의 스타일을 정의하는 시트
	: 왜 필요한가? >>
		1. 컨텐츠와 스타일을 분리하여 관리할 수 있다
		2. 재사용하기 쉽다
		3. 유지 보수가 쉽다. 하나만 수정하면 되니까.

	: CSS를 추가하는 방법
		1. 인라인 스타일 시트 : 태그 내부에 직접 표기
		2. 내부 스타일 시트:  html 문서의 style 태그 안에 명시
		3. 외부 스타일 시트:  .css 확장자의 파일에 작성하고, 이를 html 파일 내부의 <link> 태그로 연결하여 사용
			<link type="text/css" rel="stylesheet" href="파일명.css">
	: 문법
		선택자 { 
			속성1:값1;
			속성2:값2;
			. . .
			} 

	: 선택자 >> 말 그대로 html 요소를 선택하는 부분
		: 왜 유용한가? >> 여러 요소에 한번에 스타일의 지정이 가능
		: 종류
			: 섞어쓰는거 tip
				(1) 부모태그 * == 해당 부모 태그 내의 모든 후손 태그들
				(2) 특정태그.클래스명 == 특정태그가 해당 클래스인 경우
				(3) 의사 클래스, 요소는 여러개 연속으로 쓸  수 있다
				(4) 의사클래스,요소를 연달아 쓴 경우 and 연산자 처럼 작동한다고 봄 된다.
				(5) 자식/후손 선택자와 의사선택자는 분배법칙처럼 사용할 수 없다. 
					: 앞에 부모 선택자 하나 쓰고 그 뒤에 자식들을 콤마로 구분하여 쓴다고 그 자식들을 자식들로 인식하는게 아니다. 
						
					: 그룹 선택자 쓰고 맨 뒤에 의사클래스.요소 쓴다고 각각의 선택자에 적용되는게 아니다. 
						
					:실제로 그룹 선택자를 이용하여 각각 적용시키고 싶담 각각의 선택자에 일일이 적어줘야된다
						ex) div p,a >> div 의 후손 p 태그 와 그냥 a 첫번째 a 태그
						ex) div p , div a >> div 의 후손 p 태그 와 div의 후손 a 태그
						ex) div p,a:first-child >> div 의 후손 p 태그 와 그냥 a 첫번째 a 태그								ex) div p:first-child  , div a:first-child  >> div 의 첫번째 후손 p 태그와 div의 첫번째 후손 a 태그

			1. 아이디 선택자 : "#아이디명"
			2. 클래스 선택자: ".클래스명"
			3. 타입 선택자 : "HTML요소명"
			4. 전체 선택자 : "*"
			5. 속성 선택자  
				: 특히 input 태그에 많이 적용하는 편
				(1)  "HTML요소명[특정속성명]" : 해당 HTML 요소가 특정속성을 가지기만 하면 해당 스타일을 적용시킨다
				(2) "HTML요소명[특정속성명=특정속성값]" : 해당 HTML 요소가 특정속성을 가지고, 특정속성값을 만족할떄 해당 스타일을 적용시킨다.

			6. 선택자 그룹 : 여러 선택자를 콤마로 나열하여 한꺼번에 지정하는 것

			7. 후손, 자식 , 형제 선택자 
				: 부모가 자식보다 앞에 오는거 , 형이 동생보다 앞에 오는거 주의
				(1) "s1 s2" : 후손 관계 >> s1 요소 내부에(바로 아래든 그그그그 아래든 ) 포함된 s2 요소를 "모두" 선택(최초만 선택이 아님)

				(2) "s1 > s2" : 자식 관계 >> s1 요소 바로 한단계 아래에 포함된 s2 요소를 "모두" 선택(최초만 선택이 아님) 
					: 기호 암기 tip >> 자식보다 부모가 더 크니까 "부모 > 자식"
			
				(3) s1 + s2 : 인접 형제 선택자 >> 같은 부모를 가지면서 s1 의 "바로" 뒤에 오는  (s1 바로 뒤에 연속으로 s2 가 오더라도) 최초의 "s2" 에 대하여만 적용한다
		
				(4) s1 ~ s2 : 일반 형제 선택자 >> 같은 부모를 가지면서 s1 의 뒤에 오는 모든 s2 에 대하여 적용한다. (최초만 선택이 아님) 
					: 기호 암기 tip >> ~ 는 좀 널널한 느낌.. + 는 좀 깐깐한 느낌. (교수님한테 + 달아달라고 하기 좀 까다로우니까)

			8. 의사 선택자 :
				: 의사 클래스, 의사 요소는 다른 선택자의 뒤에 명시하여 사용한다
					: 의사클래스, 의사 요소를 단독으로 선택자로 사용하여 스타일 규칙을 정의할순없다

				: 기호 암기 tip >> 요소 -->효소 -- >가루 많이 날린다. :: 이다.
 				(1) 의사 클래스 Pseudo Class : 기존 요소가 특정한 상태를 만족할떄만 발현되는 스타일 규칙을 정의한다
					형태) 앞에 : 가 붙은 형태
						1. 자식 관련
							: 주의 ) "부모선택자 :first-child"  ,  "부모선택자 :only-child" ,"부모선택자 :nth-child(n)" 이런식으로 부모 선택자만 단독으로 쓰면 각각 첫번째, n 번째로 등장한 "부모"선택자에 대해서 해당 스타일이 적용되지, 해당 선택자의 n번째 자식에게 적용되는게 아니다. 이름에 "child" 가 들어간건, 보통 "부모선택자 자식선택자:first-child", "부모선택자 자식선택자:nth-child(n)" 이런 식으로 부모와 자식 관계를 형성하는데 많이 사용해서 그런거다.
								: 보통  "부모선택자 자식선택자:first-child" , "부모선택자 자식선택자:nth-child(n)" 으로 쓰지,  "부모선택자>자식선택자:nth-child(n)"  으로 쓰진 않는 것 같다.

							(1) :first-child << 해당 자식 태그가 부모태그의 "첫번째" 자식 태그일때 발현되게 한다
								: 단순히 해당 부모태그 내부에서 해당 종류의 태그들 중에서 첫번째이기만 하면 적용된다는게 아니라, 실제로 그 자식 태그가 "통틀어" 첫번째여야 적용된다.
							(2) :last-child << 마지막 자식 요소에 한하여 발현되게 한다
							(3) :only-child << 부모가 해당 자식 요소 딱 하나만 가질때 발현되게 한다
								: 단순히 해당 부모태그 내부에서 해당 종류의 태그가 하나만 존재하 면 적용된다는게 아니라, 실제로 그 자식 태그가 "통틀어" 딱 하나여야 적용된다.

							(4) :nth-child(n) << 요소의 n번째 자식에 한하여 발현되게 한다
								: 괄호 내부에 대입 가능한 값
									(1) 숫자 >> 1 부터 사용 가능하다
									(2) n을 이용한식
										: 어떤 형태의 식을 쓰느냐 따라 n 의 시작범위가 다르니 주의 >> 상수 부분 있을땐 n=0부터 시작, 상수 부분 없을떈 1 부터 시작. 
										1. kn >> k 번째 자식요소마다
											: 이때는 n=1,2,3 .. 이라고 봄 된다
										2. n + k >> k번째 자식 요소부터 쭉
											: 이때는 n =0,1,2,3 .. 이라고 봄 된다
										3. an + b>> b번째부터 a개 마다 선택
											: 이때는 n =0,1,2,3 .. 이라고 봄 된다
											: a 는 음수면  b 번째 부터 앞방향으로 a개 마다 이고, a가 양수면 b 번째부터 뒷 방향으로 a개마다 이다.

									(3) 키워드 
										1. odd >> 홀수 번째 자식 요소마다 적용
										2. even >> 짝수 번쨰 자식 요소마다 적용

						2. 해당 요소의 상태 관련
							: ㅈㄴ 주의 ) 덮어쓰임 당하지 앟기 위해 정의 순서는 link ->visited ->hover -> active 로 해야됨
								: https://webstandards.tistory.com/5

							(1) :hover >> 마우스 오버 됬을떄 발현할 스타일 정의
							(2) :active >> 마우스 클릭했을때 발현할 스타일 정의
							(3) :link >> 방문 전인 하이퍼링크에 적용할 스타일 정의
							(4) :visited >> 방문된 하이퍼링크에 적용할 스타일 정의


				(2) 의사 요소 Pseudo element : 기존 요소에 특정 컨텐츠, 스타일을 추가한다
					형태 ) 앞에 :: 가 붙은 형태
						1. ::before , ::after << 요소의 앞, 뒤 부분에 특정 컨텐츠 추가 + 그 컨텐츠의 스타일 정의
							: content 속성을 명시하고, 특정 컨텐츠를 할당한다. 그리고 이와 함께 정의된 스타일은 해당 content 부분에만 적용된다.

						2. ::first-letter << 요소의 앞 글자의 스타일 정의
							: 따로 content 를 할당하는것 없이 첫 글자에 대한 스타일만 정의한다
					

	: 스타일 우선순위
		1. 중요도
			(1) 개발자가 !import로 선언
			(2) 개발자가 그냥 선언
			(3) 브라우져의 기본 선언

		2. 명시도 : 대상을 얼마나 명확히 특정했는가
			(1) 인라인으로 직접 기술
			(2) id
			(3) 클래스
				: 개발자가 아무리 클래스에 대한 정의를 먽저하고, 타입에 대한 정의를 더 나중에 했더라도 명시도 측면에선 클래스가 타입보다 더 우선이기 떄문에, 공통된 스타일 속성에 대한 정의는 클래스의 정의를 따라가게 된다.
			(4) 타입

		3. 순서 : 개발자가 더 나중에 선언할 수록

	:f12 에서 적용된 스타일과 적용되지 않은 스타일
		: 더 위에 있을 수록 나중에 정의 된거
		: 흐린 글자는 지정은 됬으나 적용되지 않은 스타일
		: 취소줄이 들어간 것은 (F12의) 하단에 지정하였으나, (F12)의 상단에서 재정의하여 취소된 스타일이다.

	: 스타일의 상속
		: 스타일을 위에서 아래로. 즉 부모 요소의 스타일을 자식 요소에게 전달한다. 해당 자식 요소에 별다른 스타일 지정이 없으면 부모의 스타일이 적용되게 된다
			: 상속이 안되는 일브 스타일도 있다.


	: 사용 가능한 값의 단위
		: html5 부터는 단위를 명시하지 않으면 오류난다. 반드시 단위를 써줘야 된다.
		절대 단위
			1. px : 픽셀 << 사용 개추
			2. pt : 포인트 << 사용 비추
			
		상대 단위
			 % : 부모 element 를 기준으로 함
			em : 부모 element 혹은 현재 폰트사이즈를 기준으로 함
			rem : root element 를 기준으로 함 >> 개추

	: 스타일 속성값으로 url 할당하는 법 ) url("경로") 로 할당한다.



	: 폰트 관련 속성
		font: 한 줄에서 모든 폰트 속성 설정 가능
			: "폰트스타일 글자두께 글자크기 글꼴" 값 할당 가능
				: 암기 tip ) swf 스위프트
			: 꼭 다 명시하지 않아도 문제 없지만, 없는걸 명시하면 오류난다.

		font-family: 폰트의 스타일 설정 
			: 할당 가능한 값의 형태의 종류
				1. 쌩폰트명
				2. "폰트명"
				3. '폰트명'
			: 여러 폰트명을 , 다양한 형태로 할당 가능 ex) font-family: "맑은 고딕체", 'times' ,serif
			: font-family 를 통한 폰트의 종류는 어차피 1개 밖에 설정 안되는데 굳이  여러개 쓰는 이유
				: 해당 폰트가 사용 불가능한 경우를 대비하는 것.
				: 마지막에는 항상 일반적인 폰트를 지정하도록 한다.

		font-weight : 텍스트 굵기
			: bold, bolder 와 같이 글자를 할당할 수도 있고, 단위를 써서 명확히 할 수도 있다

		font-size: 텍스트 크기
	******font-style:italic 이텔릭체 설정
			: 기본값은 normal 이고, 이탤릭체 쓰려면 italic 을 할당해야된다.

	: 텍스트(인라인 콘텐츠) 관련 설정
		color : 텍스트 색상

		text-decoration: 텍스트 밑의 밑줄 설정
			: text-decoration으로 한꺼번에 "줄위치 색깔 스타일 굵기" 설정 가능
				: 암기 tip ) lcst 라코스테
			: 세분화 속성 ) 
				: text-decoration-line >> none, underline, overline, line-through (줄의 위치 설정)
					: 암기 tip- location 이니까, l로 시작하니까 style 이 아닌 line
				: text-decoration-color 
				: text-decoration-style >>  solid dotted wavy double(줄의 모양 결정)
				: text-decoration-thickness	

		text-align : 텍스트 "정렬"
			: 주의) 인라인 태그의 스타일로만 적용 가능한게 아니다. 블록 태그의 스타일로 정의할 시 블럭 태그 내부의 인라인 태그들에 대해 해당 스타일을 적용시킬 수 있다
			: https://codingeverybody.kr/css-text-align-%EC%86%8D%EC%84%B1/
			1. justify : 양쪽으로 정렬. 
				: 양쪽으로 띠엄띠엄 쓰고 싶어서 그러는거면 보통 letter-spacing 을 쓰지, text-align:justify 는 잘 안쓰는 듯.
				: 주의 
					(1) 텍스트 사이에 간격이 하나라도 있어야 적용 가능
					(2) (박스 내부에서) 항상 그 라인을 꽉 채우는 형태는 아님. 해당 라인이 꽉 차서 줄바꿈 해야되는 경우만 그렇게 띠엄띠엄 나타나는거고, 줄바꿈 안일어난 부분은 그대로임
					(3) div 같은 block 태그에는 적용 안되고 inline 태그나 inline-block 태그여야 적용되는거임.

			2. start : 시작하는 지점에 찰싹 붙는다
				: direction 의 속성 값이
					ltr 인 경우 >> left 값과 동일
					rtl 인 경우 >> right 값과 동일

			3. end : 끝나는 지점에 찰싹 붙는다
				: direction 의 속성 값이
					ltr 인 경우 >> right 값과 동일
					rtl 인 경우 >> left 값과 동일

			4. left : 왼쪽 정렬
			5. right ; 오른쪽 정렬
			6. center : 중앙 정렬


		direction : 텍스트 "작성" 방향 설정
			1. ltr >> 디폴트 값
			2. rtl : 오른쪽에서 왼쪽으로 쓰여지고, 오른쪽에 붙는다.
				: 주의!!! ) 한글이나 영어처럼 왼쪽에서 오른쪽으로 쓰는 언어는 rtl 을 입력하면 단순 오른쪽에 붙는것처럼 보이지만, 아랍어와 같이 오른쪽에서 왼쪽으로 쓰여지는 글자는 오른쪽으로 붙을 뿐 아니라 글자가 거꾸로(?) 쓰여진다.
				: https://mine002.tistory.com/116

		letter-spacing : 자간 설정
			: 음수값을 주면 겹치게 할 수 있다
		
		text-indent : 들여쓰기 설정	
			: 음수값을 주면 내어쓰기( 컨텐츠 영역 "밖"으로 튀어나오게 하게) 할 수 있다.
			: ㅈㄴ 주의할 것은 명색이 "text" 임에도 불구하고 block 혹은 inline block 요소에 한하여 적용 가능하다! (inline 요소에는 적용 불가)

		line-height: 텍스트 줄의 높이 설정
			: 인라인 요소에서의 일종의 height 설정이라고 보면 된다.
			: line-height 값에 따라서 텍스트 위 아래의 leading 영역이 증감된다. 이때 line-height 값은 텍스트의 높이 포함에서 할당하는 것임을 주의.
		
		text-transform : 대소문자 변환 지정
			(1) none : 미지정<< 디폴트.
			(2) capitalize : (문장이 아니라)"단어"의 첫번째 글자를 대문자로 
			(3) uppercase: 모든 글자를 대문자로
			(4) lowercase: 모든 글자를 소문자로

		text-shadow : 텍스트 그림자 설정
			: "값1 값2 값3 색" 
				: 주의 ) 값을 4개 쓰는게 아니라 3개 쓰는거다

		word-break 
			: 암기 tip >> 일단 다 꺠부순다.
			: https://que-n-a.tistory.com/entry/%EC%A4%84%EB%B0%94%EA%BF%88-word-break-%EA%B8%80%EC%9E%90-%ED%9D%98%EB%9F%AC%EB%84%98%EC%B9%A8-Word-wrap-%EC%86%8D%EC%84%B1-%EC%A0%95%EB%A6%AC
			: 아시아 언어에 한하여 줄바꿈의 기준을 설정할 수 있음
			: 블럭, 인라인 블럭 요소에 적용 가능
			: 할당 가능한 값
				(1) normal << 디폴트: 브라우져의 기본 값에 따라 줄바꿈이 일어난다
				(2) break-all >>텍스트가 문자 단위로 잘려 아래로 줄바꿈된다
				(3) keep-all >> 단어 단위로 잘려서 아래로 줄바꿈 된다
					: 암기 tip ) break는 완전 절단 나는거고, keep 는 좀 가져가는 느낌
			

		word-wrap
			: 암기 tip >> 둘둘 둘러싼다
			: 비아시아언어 텍스트가 박스로 삐져나오지 않게 하기 위한 속성
				: 왠진 몰라도 아시아 언어의 경우 딱히 이거 설정 안해줘도 텍스트가 밖으로 삐져나오지 않는다
			: 블럭, 인라인 블럭 요소에 적용 가능
			: 할당 가능한 값
				(1) normal << 디폴트:줄바꿈이 일어나지 않고 걍 박스 밖으로 길게 빠져나온다
				(2) break-word >> 텍스트가 박스 밖으로 빠져나오지 않게 줄바꿈을 적용한다
 					: 미국은 bbw 좋아하니까 bw

	: column 관련 설정
		column-count : 구획 영역의 개수 설정
			: 주의 ) 구획 선이 n 개 생기는게 아니라 구획 영역이 n 개 생기는 거임
				ex) column-count:3 >> 구획 영역은 3개, 구획선은 2개

		column-rule: 구획선의 스타일 설정
			: "구획선의굵기 구획선스타일 구획선색깔" 형태의 값 할당
				; font 에 값 할당하는 형식에서 앞에 선의위치만 빠진 형태. 생각해보면 column 의 경우 column 의 용도로 사용하겠다고 한 이상 위치가 걍 정해졌다고 봄 되니까.
	
		column-gap : 구획선과 컨텐츠 간의 간격을 결정
			
			
	: 리스트 관련 설정
		: tip >>  '불릿' 이란건 단순 숫자나 알파벳 같은게 아닌 기호 같은거만 쓰는 말이고, 마커는 두루두루 쓰일 수 있는 용어이다.
		
		: ol, ul 에 하는 설정
			list-style : 리스트 속성을 한줄로 정의
				: "모양 위치 이미지" 값을 할당 가능

			list-style-image: 리스트 마커를 이미지로 지정
				: 할당 가능한 값 >> url("경로")

			list-style-position: 리스트 마커의 위치 결정
				inside : 문단 안쪽에
				outside : 문단 바깥쪽에

			list-style-type: 리스트 요소의 마커를 설정
				(1) none : 불릿이 없음
				(2) circle : 꽉찬 불릿	
				(3) disc : 텅빈 불릿
				(4) square: 사각형
				(5) decimal : 10진수
				(6) lower-roman : 소문자 로마자
				(7) upper-roman : 대문자 로마자
				(8) lower-alpha : 알파벳 소문자 
				(9) upper-alpha : 알파벳 대문자 

		: li 에 하는 설정 
			: 특별히 li 만을 위한 설정은 없고, 종종 li 의 줄바꿈 효과를 없애기 위해 display:inline 으로 바꿔준다.


	: 배경 관련 속성
		: background 관련 설정은 border 영역 까지 적용된다.
		: background-color 가 background-image 보다 더 밑에 깔린다.

		1. background-color
			: 배경색설정	
			: 색깔 값을 준다

		2. background-image 
			: 배경 이미지설정
			: " url("경로") " 값을 준다
			: 기본적으로 
				(1) 이미지의 크기가 유지된다 (화면에 꽉 채우게 변형되진 않는다)
				(2) 이미지의 크기가 border 보다 작을 경우 ( 크기를 유지하면서) 바둑판처럼 반복되어 나온다


		3. background-attachment
			: 스크롤로 이동할 시 배경화면의 움직임을 설정한다.
			(1) scroll << 스크롤로 이동시 배경화면도 같이 이동. 
			(2) fixed << 스크롤로 이동해도 배경화면 고정

		4. background-repeat
			: 이미지의 크기가 border 보다 작을 시 어떻게 처리할 건지 설정한다
			(1) no-repeat:  border 보다 더 작더라도  이미지 크기를 "유지하면서" , 반복하지 않는다.
			(2) repeat-x : x 방향으로 반복
			(3) repeat-y: y 방향으로 반복
			(4) repeat: x,y 방향으로 반복 << 디폴트

		5. backgorund-position
			: 이미지의 위치 지정
			(1) 키워드 >> 아래의 키워드들을 단독으로 쓸 수도 있고, 조합해서(left top, right center 처럼) 쓸 수 도 있다.
				1. top
				2. bottom
				3. left 
				4. right
				5. center

			(2) 실제값
				: "x축위치 y축위치" 의 형태로 할당한다

		6. background-size
			: 배경이미지의 크기를 설정
			(1) cover : 주어진 영역을 완전히 덮을 수 있도록 최대한 작게, 이미지를 크기를 맞춰줌. 일부분이 짤려서 나타날 수도 있음
			(2) auto: 원본 크기 이미지  << 기본값
			(3) contain : 잘리는 부분 없이 최대한 크게 덮게 함. 



		7. background
			: "배경색 배경이미지 반복여부 위치" 를  한번에 할당 가능하다 

















: 박스 모델
	: 웹 브라우저가 각 요소들을 화면에 렌더링(그릴땐) 무조건 사각형으로 간주한다. 그리고 그 사각형 내부의 구성은 다음과 같다
		1. 콘텐츠 영역
		2. 패딩 영역 << 패딩 영역은 투명하다
		3. 보더 영역 
		4. 마진 영역 << 마진 영역은 투명하다



	(1) 인라인 요소
		: margin, padding 의 경우 좌우 방향으로만 가능하고 top, bottom 방향으로는 설정 못한다.
			: border 은 모든 방향으로 다 된다
		: 인라인 요소를 (자식요소로써) 수평 정렬 >> text-align : center
		: 인라인 요소를 (자식요소로써) 수직 정렬 
			sol1 : 자식의 line-height 값을 부모의 "content 영역"의 height 값과 같게 한다
				: 자식이 들어가는 영역은 content  영역이지, border 내부의 영역 그 자체가 아니라서 그렇다.
				if ) 부모 블록 요소가 box-sizing:border-box 일 경우 >>  line-height 값을  " 부모의 height - (padding-top + padding-bottom) " 으로 해줘야됨
					
				if ) 부모 블록 요소가 box-sizing:content-box 일 경우 >>  line-height 를 부모 블록 요소의 height 값 그 자체로 하면 됨.


	(2) 블럭 요소 
		: 모든 방향으로 margin, padding 적용가능하다
		: 주의 ) 
			1. auto 는 margin-right, margin-left 에만 적용 가능하고 margin-top ,margin-bottom 에는 적용이 안된다
				: margin-top, bottom 에 auto 값을 할당한다고 에러가 나지 않지만 실질적으로 이때 auto 값은 0과 같다고 한다

			2 auto != 50%
				: 50% 는 말 그대로 부모 사이즈의 절반이 되는거고, auto 는 알잘딱깔센으로 해당 자식 요소를 배치했을때 남게되는 사이즈를 절반으로 나눈거다.
					: n% 는 border 영역의 n%이고, 이는 자식 border 의 값으로 결정되는거다. content 영역이 아니라
						: ex) 부모가 500

			3. block 요소라고, 무조건 다른 block 요소가 해당 줄을 침범할 수 없는게 아니다. 해당 block 요소의 자식 요소라면 해당 줄을 공유할 수 있다. (물론 해당 block 요소와 형제 레벨이라면 , 서로 다른 라인에 위치한다)

		: 블럭 요소를 (자식요소로써) 수평 정렬 >> margin-left:auto; margin-right:auto;
		: 블럭 요소를 (자식요소로써) 수직 정렬 >> margin-top: 직접계산한값; margin-bottom: 직접계산한값;
			: 직접 계산한 값 = " (부모 content 영역의 height - 자식 border 영역의 height) /2 "
 
		: 블럭 요소를 (자식요소로써) 정중앙에 정렬 >> margin: 어떤값 auto;


	(3) 인라인 블럭 요소
		: 외적으로는 인라인 요소를 따르지만 내적으로는 블럭 요소를 따른다.
			: 한 줄을 다 차지하진 않지만 height 를 설정할 수 있다

: 대체 박스 모델
	: 요소의 width, height 가 border 영역의 너비, 높이 인 것. 즉 width, height 가 padding 과 border 를 포함하게 되는것






레이아웃 >> "배치".  웹페이지에서 HTML 요소의 위치, 크기 등을 결정하는 것. 
	: 페이지 레이아웃 추천 방식 
		(1) div 요소 사용
		(2) 시맨틱 요소 사용 << 웹 표준

	: 페이지 "레이아웃"으로써의 table 사용은 비추
			: https://ilmol.com/2005/06/%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%80-%EC%9D%B4%EC%A0%9C-%EA%B7%B8%EB%A7%8C-%EC%89%AC%EC%96%B4%EC%95%BC-%ED%95%A0-%EB%95%8C.html
			1. 의미론적(시멘틱 적이지)이지 않다, 테이블의 원래 용도에 어긋난다.
			2. 속도가 느리다.
			3. 트렌드가 안쓰는 추세.	
			4. 유지보수가 어렵다.
			: 주의) 웹 접근성을 지키기 위해 사용을 비추하는 거지, 웹 표준지키기 위해 그러는게 아님.


	: 박스 모델 관련 설정
		padding: 요소의 border 과 content 영역 사이의 간격을 조정
			: 주의 
				1. padding 에는 음수값, auto 값을 줄 수 없다
				2. padding 이 늘고 줄으면
					: 콘텐츠영역은 줄고 늘어난다 >> content-box 일떄 width, height 가 padding 의 영향 받는다
					: border 영역의 사이즈가 변경되진 않는다 >> border-box 일때 width, height 가 padding의 영향 안받는다

			: 세분화) padding-top,  padding-right,  padding-bottom, padding-left
 			: padding) 
				1. " padding 위 오른 바닥 왼" 으로 한꺼번에 설정 가능
				2. " padding 위/바닥 오/왼" 으로 한꺼번에 설정 가능

		margin : 요소의 border바깥 영역의 크기를 조절 
			: 주의 >>  margin 에는 음수값, auto 값을 줄 수 "있"다

			: 세분화) margin-top,  margin-right,  margin-bottom, margin-left
 			: margin) 
				1. " margin 위 오른 바닥 왼" 으로 한꺼번에 설정 가능
				2. " margin 위/바닥  오/왼" 으로 한꺼번에 설정 가능

		border : 경계선 결정
			1. border-top,  border-right,  border-bottom, border-left
				: 각각 "두께 스타일 색" 의 값 부여 가능
			2. border
				:  "두께 스타일 색"  으로 모든 방향의 경계 설정 가능
				: 주의 ) "위두께 오두께 아래두꼐 왼두께 스타일 색" 처럼 각 변을 한꺼번에 커스터마이징 할 순 없다
			3. border-radius
				: 경계 모서리의 둥근 정도 설정

		box-sizing 
			: width 와 height 를 어떻게 구할지 결정한다
			: 이러나 저러나 margin 영역은 border-box 에 포함되지 않는다!
			: width, height 값을 상대 단위값으로 할때 , box-sizing 속성값은 width, height 속성에 실제로 할당되어지는 값에 영향을 주진 않는다! 
				: 그렇게 구해진 width, height 를 border 의 크기로 설정하느냐, content 의 크기로 설정하느냐 따라서 해당 요소의 크기가 차이가 나는거지 width, height 자체에 할당된 값이 달라서 차이가 나는게 아니다.

			(1) border-box : "border 영역"을 기준으로 width, heigth 가 구해진다
				: 그러니까 길이 == 콘텐츠영역+ 패딩영역
				: padding 값이 바뀌면 요소의 width, height 도 변한다 >> padding 값 따라서 contnet 여영의 사이즈가 변하기 때문이다

			(2) content-box : 콘텐츠 영역을 기준으로 width, height 가 구해진다 
				: padding 값이 바뀌어도 요소의 width, height 가 유지된다 >> padding 값과 상관없이 border 영역의 사이즈는 유지되기 때문이다




	: 위치 설정 관련
		(1) top, left, bottom, right
			: offset 을 결정하는데 사용
				: offset >> 기준점으로부터 얼마나 떨어졌는가 나타내는 것.
				: position 속성을 쓸 때 쓰이는 속성들로, positino 에서 기준잡은 위치를 기준으로 얼마나 떨어질지 결정
			: 주의
				1. position:static 일때는 효력이 없음
				2. left, right , top, bottom 한꺼번에 다 쓰는게 아니라 보통 left 와 top 의 조합으로 쓰는 편
					:  left, right 속성 둘 다 썼을 떄 width 가 정해져있지 않으면 두 속성이 모두 반영되어 그에 따라 width 가 확장되고 축소되지만, width 가 정해져 있는 경우 left 혹은 right 속성 둘 중 하나만 적용된다. (문서의 흐름이 왼->오 로 일반적일 경우는 left 가 , 그렇지 않은 경우엔 right 가 채택된다.)

					: top, bottom 속성 둘 다 썼을 떄 height 가 정해져 있지 않으면 두 속성이 모두 반영되어 그에 따라 height 가 확장되고 축소되지만, height 가 정해져있지 않은 경우 "top" 만 적용된다.

					: https://penguingoon.tistory.com/269


		(2) position
			: https://creamilk88.tistory.com/197
			: 요소의 위치 지정 방법의 기준을 설정한다.
			: 주의
				: (static 을 제외하고) 단순 position 값을 부여했다고해서 마법처럼 원하는 위치에 배치되는게 아니라 left, top 속성으로 해당 위치를 기준으로 이동하게 해야된다

			: 할당 가능한 값
				(1) static  정적 위치 설정 << 기본값
					: 본래 성질대로 배치. ( 블럭은 한줄 꽉 차지하면서 차곡차곡 ,인라인은 옆으로 따라 붙으면서 촙촙)
					: postition 값이 static 일때는 top, left , bottom, right 속성이 무시된다.
						: 본래 성질 그대로 쓰겠단 말이니까
					: float 속성은 효력이 있다.

				(2) relative 상대 위치 설정
					: 요소 자신(=원래 있어야할 위치)을 기준으로 배치.
						: 내 주변에 있는 다른 요소와 지금 나의 위치를 파악하고 지금 내가 존재하는 곳에서 움직인다.
					: 일단 원래있어야할 위치의 자리를 먼저 차지한 후, 그 위치를 기준으로 움직이다.
					: 일반적인 레이아웃 흐름을 벗어나지 않는다.
						: 그러니까 block 은 block 처럼, inline 은 inline 처럼 동작한단 말이다.
						: https://velog.io/@cheal3/HTML-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83
				(3) absolute 절대 위치 설정
					: (relative, fixed , absolute 중 하나의) position 속성을 가진 가장 가장 가까운 "조상"요소(=컨테이너의 원점)를 기준으로 배치. 만약 조상 요소 중 position 속성을 가진 요소가 없다면, body 요소(그러니까 근본적인(?) 전체 페이지 )를 기준점으로 삼게 된다.
						: ppt  에서는 헷갈리게 absolute 를 단순 전체 페이지를 기준으로 배치하는 방법이라고 정의해놨다.
						: 조상은 대부분 relaitve 값을 가지게 하는 편이다. 
							: position 속성 중 relative 속성만이 기존 레이아웃 흐름에서 벗어나지 않아서 안정적이기 떄문.
							: https://kin.naver.com/qna/detail.naver?d1id=1&dirId=10402&docId=468362938&scrollTo=answer1#
						
					: !! absolute 으로 지정된 요소는 유령처럼 취급 되어 자리를 차지하는 것 없이, 다음에 오는 요소가 바로 온다. 그냥 조상 요소를 기준으로 위치가 잡힌다.
						: 다른 요소를 무시한다. 다른 요소도 나를 무시한다. 내가 공중에 존재한다고 보면된다. 그래서 다른요소가 내가 없다고 생각하고 내 위치에 오면서 빈자리를 채우는 것. 나는 유령과 같다.
						: https://velog.io/@yhko1992/relative-VS-absolute
					: 일반적인 레이아웃 흐름을 "완전" 벗어난다.

				(4) fixed 고정 위치 설정
					: 브라우저화면(=윈도우의 원점=뷰포트)를 기준으로 배치. 스크롤과 상관 없이 화면에 고정되어 나타난다. 
						: 뷰포트 >> 사용자에게 보여질 "전체적"인 영역. (스크롤 따라서 그떄 그때 보여질 화면은 아니다)

				(5) sticky 
					: ppt 에서 따로 안다룸
					: 스크롤영역 기준으로 배치.  "직계 부모 영역 내에서" fixed 처럼 동작한다.
						: 그러니까  부모 영역이 뷰포트에 보일 때부터 사라질 떄까지, 해당 sticky 자식 요소는 스크롤을 아무리 해도 뷰포트와 left, top 만큼 떨어진 위치에 고정된다.
						: 부모 영역에 별 다른 position 속성 같은거 설정하지 않아도 자동적으로 부모 영역 내에서만 움직인다.
						: 한자리 차지한다. (absolute 처럼 자기 자리가 없진 않다.)
						: 주의  
							1.적어도 하나의 offset 을 지정해야 효력이 있다.
							2. 부모가 overflow 속성 있으면 적용 안된다.
					: https://inpa.tistory.com/entry/CSS-%F0%9F%93%9A-%EC%9C%84%EC%97%90-%ED%97%A4%EB%8D%94%EB%A5%BC-%EA%B3%A0%EC%A0%95%ED%95%98%EC%9E%90-%F0%9F%8E%A8-sticky-position




normal flow, BFC, IFC
	: Normal Flow  >>  일반적인  레이아웃 방식. 
		: block 레벨 요소가 block 레벨 요소처럼(수직 배치). inline 레벨 요소가 inline 레벨 요소처럼(수평 배치) 작동함.

	:  Block Formatting Context(BFC)  >> Normal flow 의 방식 중 block 요소를 배치하는 방식.  
		: 작은 독자적인 레이아웃 .
		: 영역에 포함된 요소들을 세로로 배치할 수 있도록 도와주는 역할
		: block 요소 자체는 아니다!
		: 효과
			1. 내부에 있는 모든 요소를 인지 가능하다.
				: 내부의 flloat 요소까지 인지 가능하다.
			2.  마진 병합(margin collapsion) 방지 
				 마진 병합(margin collapsion) : 요소들의 마진 값이 겹칠 경우 더 큰 마진만 적용되는 현상


 		: BFC가 생성되는 경우
			(1) root 요소 (body 태그는 만들어지지 않는다)
			(2) none 값이 아닌 float 속성 가지는 요소 
			(3) visible 값이 아닌 overflow 속성 가지는 요소
			(4) relative, static 값이 아닌 position 속성 가지는 요소	
				: relative, static 값은 normal flow
			(5) inline-block, flex, grid 값"인" display 속성 가지는 요소


	: Inline Formatting Context(IFC)  >>  Normal flow 의 방식 중 inline 요소를 배치하는 방식. 
		:  영역에 포함된 요소들을  가로로 배치할수  있도록 도와줌


	: https://mingeesuh.tistory.com/entry/Block-Formatting-Context-BFC
	: https://velog.io/@nalsae/%EB%82%B4%EB%B3%B4%EC%A0%95CSS-float-%EB%94%A5-%EB%8B%A4%EC%9D%B4%EB%B8%8C



	: 요소의 스택 순서 관련
		: 스택 순서 == 쌓이는 순서
		: z-index 가 젹용되지 않은 일반적인 스택순서
			 root 요소 --> 더 먼저 나온 자식 요소 --> 더 나중에 나온 자식 요소 
			
		z-index
			: https://abcdqbbq.tistory.com/39
			: 요소의 스택 순서를 지정한다.
			: 주의 
				1. position:static 인 요소에는 적용 불가하다!!!
					: static인 요소는 z-index 속성이 0으로 고정되어 있다
				2. 해당 요소는 형제 요소 혹은 "자신"의 후손 요소 에 대하여 z-index 가 비교 될 수 있다
					: 형제 요소의 후손 요소까지는 인식 못한다. 
						: 그러니까 아무리 높은 z-index 의 후손을 가진 형제 있어도, 그 형제 자체의 z-index 가 낮으면 해당 후손까지 조상님 떄문에 짓밟히게 된다
				3. z-index 값으로 마이너스 값을 줄 수 있지만, 마이너스 값을 줄 경우 background 보다 밑에 깔리게되어 (background 가 투명한 색이 아닐 경우) 보이지 않게 될 수도 있따.


	: 넘치는거 관련
		(1) overflow
			: 요소 내의 컨텐츠가 요소보다 커서 넘칠 때 어떻게 보여줄지 정하는 속성
			: 할당 가능한 값
				1. visible: 넘치는 부분이 상자 밖으로 보여진다<< 디폴트값
				2. hidden : 넘치는 부분은 잘려서 보이지 않는다
				3. scroll : 무조건 스크롤 바를 생성하고, 그 스크롤 바를 통하여 박스내에서 넘치는 부분을 볼 수 있게 한다.
				4. auto : 넘치는 부분이 없으면 스크롤 바를 생성하지 않고, 넘치는 부분이 있으면 스크롤 바를 생성시켜 박스내에서 넘치는 부분을 볼 수 있게 한다.
			: https://xxvigrufv.tistory.com/15

		(2) overflow-x : x 방향으로 넘치는 경우만 설정한다
		(3) overflow-y :  y 방향으로 넘치는 경우만 설정한다



	: 부유 관련
		(1) float
			: 해당 요소가 해당 요소의 "이후"에 등장하는 "모든" 요소에 대해 특정 방향에 배치되게 한다.
			: 원래는 이미지를 텍스트와 함께 효과적으로 배치하기 위해 사용되었으나 요즘엔 "레이아웃"(가로 정렬)을 잡는데 사용된다.
				: 근데 요즘엔 float 보다도 flex 를 더 많이 쓴다.
		
			: 할당 가능한 값
				1. none << 기본값
					: 해당 요소를 부유시키지 않음
				2. right
					: "해당 요소"를 "다음 요소"의 "오른쪽"에 부유하게 한다
					: "다음요소들"을 "해당 요소"의 "왼쪽"에 배치되게 한다

				3. left
					: "해당 요소"를 "다음 요소"의 "왼쪽"에 부유하게 한다
					: "다음요소들"을 "해당 요소"의 "오른쪽"에 배치되게 한다
			: 주의/특징
				: https://luckyjek.tistory.com/74
				: https://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo

				1.(none 값 제외) float 이 적용된된 요소는 display: block 이 된다. 
					: 그렇다고 정상적인 block 처럼 작동하진 않는다. (그렇다고 inline-block 인건 아니다 ) 예를 들어 한 줄을 다 차지 하지 않는다.

				2. float된 요소는 집을 나가버린다. 자신이 속해있는 부모요소안에 자식요소로 존재하는 것이 아니라 독립적인 존재로 바뀌게 되어, 부모 요소 내에서 원래 자기 영역을 확보하지 않는다.
					: 부모의 콘텐츠 영역 사이즈를 확인해보면 float 요소 사이즈는 카운트 되지 않음을 확인할 수 있다.
					: 그렇다고 position: absolute 처럼 모두에게 유령 취급 되는게 아니다 (3번에서 계속)

				3. 해당 부모 블럭 밖의 요소들도 때로는 float 의 영향을 받을 수 있다.
					: height 가 설정되있지 않은 부모가  float 자식 요소들로만 채워진다면, 실제로 그 부모는 height 가 0이게 된다. 그 부모 뒤의 요소가 block 요소라면, 그 자식들을 인지하지 못하고 쳐들어오게 된다.
					: https://www.w3schools.com/css/tryit.asp?filename=trycss_layout_cols

				4.  float 이 적용된 요소의 이후 요소들은 인라인이냐 블럭에 따라서 효과가 다르게 적용된다.
					: 인라인 요소들 >> float 이 적용된 요소가 집을 나갔음에도 똑똑하게 해당 영역을 인식하고, 알아서 비켜서 배치된다.
					: 블럭 요소들 >>  float 이 적용된 요소를 인식하지 못하고 걍 해당 영역을 침범한다. 그러니까 유령 취급한다.
						: float 이 적용된 요소만 인식 못하는거지, 앞에 쌓인 inline, block 요소들은 잘 인식하는거다
					: float 이 적용된 요소들 >> float 이 적용된 요소들 끼리는 BFC라서, 서로를 잘 인식하는 것 "같다" (이전 영역을 침범하지 않고, 이쁘게 나열된다.)
						: https://www.w3schools.com/css/tryit.asp?filename=trycss_float5

				5.  position 속성값을 fixed 혹은 absolute로 가지는 요소에는 float 를 적용할 수 없다.
					: 절대적인 위치라서 그렇다고 한다. (w3c css 문서에서)
					: 그러니까 position 이 아예 지정되지 않았거나, position:relative 인 경우에만 가능한거다

				6.   더 이상 float 효과 적용시킬 필요없어졌을때, 요소들이 float 속성에 영향을 받지 않게 하는 법
					: 요소에 float 을 사용하면 그 요소 이후에 정의된 모든 요소들은 정확한 위치 잡기가 매우 힘들어진다. 더이상 float 의 영향을 받을 필요가 없어지면 그 효과가 더이상 적용되지 않게 clear 속성을 써주는게 좋다.


					sol 1) "부모 요소"에 overflow: hidden 값 주기
						: 부모가 root 요소처럼 BFC가 되어 float 된 자식까지 인식할 수 있게 된다.
							: 그러니까 overflow:hidden 의 본래 목적대로 해당 컨테이너를 넘는 요소를 자르고자 쓰는게 "아니라", overflow:hidden 의 특성상 해당 요소를  BFC 화하는 것을 이용하기 위해 사용하는 거다.				
					******: https://velog.io/@nalsae/%EB%82%B4%EB%B3%B4%EC%A0%95CSS-float-%EB%94%A5-%EB%8B%A4%EC%9D%B4%EB%B8%8C
						: https://mingeesuh.tistory.com/entry/Block-Formatting-Context-BFC


					sol 2) "뒷 요소"에 clear 속성 << 밑에 적음



		(2) clear
			: 해당 요소부터 더이상 float 속성에 영향을 받지 않게 하는 속성
			: 정확히 말하자면, 해당 요소에게 float된 요소를 인지할 수 있게 해주는 능력 부여하는 것이다. 
				: 주의 ) BFC화 했을때 부여되는 능력과 비슷하긴 해도,  BFC 화 하는건 아니다.	
			: !! clear 속성은 block 레벨 요소들에만 선언 가능하다
			: clearfix
				: CSS에 :after라는 가상요소를 사용해서 clear:both속성을 주어 해결하는 방법
			: 할당 가능한 값
				1. none )  clear 를 적용하지 않음 << 기본값
				2. right ) float : right 를 취소 시킨다
				3. left ) float : left 를 취소 시킨다
				4. both ) float : right,  float : left 를 둘 다 취소시킨다.
			: 깔끔한 코드 작성하는 tip >> clear 용도만을 위한 요소를 따로 만들 필요없이,  있는 요소에 ::before, ::after 붙여서 clear를 추가하면 더 깔끔하다. 
				: 주의 ) 
					1.  ::after, ::before 붙는 요소가 block 속성 요소가 아니라면,  "display:block;" 선언 도 같이 해줘야됨
					2. 딱히 쓸 내용 있어서 ::after, ::before 를 쓴 건 아니므로 'content:""; ' 로 빈 문자열 삽입하는걸 추천
				: https://luckyjek.tistory.com/74


: 브라우져 렌더링 과정 
	: DOM 트리 구축-> 렌더트리 구축 -> reflow -> repaint -> composite	
	: https://tacit.tistory.com/137

	: DOM tree >> html 을 구조화 한 것
	: Render Tree >> Dom tree 에서 페이지를 렌더링 하는데 필요한 노드만 남긴 것
	: reflow >> 레이아웃(위치, 크기)을 다시 결정하는 과정
	: repaint >>  요소를 화면에 다시 그림


	: opacity:0 vs visibility:hidden vs display:none;
		: https://dev.epiloum.net/834
		: https://velog.io/@kya754/no1
		: https://velog.io/@player1552/CSS-Visibility-hidden-display-none-opacity-0%EC%9D%98-%EC%B0%A8%EC%9D%B4
		: display:none >> 아예 영역 자체가 사라지고, 이벤트 또한 작동하지 않는다
			: DOM트리까지는 존재하는데 영역을 차지하지 않아 렌더 트리에서부터 제외되어 레이아웃이 안되고, 렌더링 또한 안된다. 

		: visibility:hidden >> 영역은 차지하고 있지만 이벤트(클릭 같은.. )가 작동하진 않는다. 해당 요소 밑에 깔려있는 요소는 클릭 가능하다.
			: 렌더 트리에 포함되어서 레이아웃에 포함되는데(= 자리는 차지 하는데) , 투명인간처럼 뻥뚤린박스로 재렌더링 시켜서 영역만 차지하고, 이벤트 같은것도 처리 못하고, 그 밑에 깔린 요소를 터치 가능한거다.

		: opacity:0 >> 보이지만 않을 뿐 영역을 차지하고 있고 이벤트 또한 작동한다. 해당 요소 밑에 깔려있는 요소는 클릭 "불"가능하다.
			: DOM 에 존재해서 레이아웃에 포함되고, 재렌더링한것도 아니라 걍 단순 색깔만 변경한거라 여전히 클릭 이벤트 적용하고, 그 밑에 있는 요소를 걍 뚫지는 못하는 것이다.


:웹브라우저 렌더링 엔진
	: HTML , CSS ,JS 같은 웹 요소를 렌더링 하는 역할을 함
	: https://xpmx
f4.tistory.com/19

	(1) webkit 
		: 애플에서 개발되어 사용되고 있고, 구버전 크롬에서 사용하던 엔진
		: 애플용 엔진과 구버전 크롬에서만 동작하지만 사용하는 걸 추천함.	

	(2) Blink
		: 구글이 크롬을 위해 개발한 렌더링 엔진
		: webkit 의 문제점을 개선하고 추가 기능을 구현함

	-webkit- , -moz- , , -ms- 와 같은 CSS 접두어
		: css 의 속성들이 모든 브라우저에서 호환되는 것은 아니라, 이와 같은 접두어를 붙여 모든 브라우저에서 똑같은 동작을 하도록 표준화 시켜주는것.
		: https://blog.naver.com/ghdcksgml2/222413054871





	: 레이아웃 설정
		: display
			: 요소의 레이아웃을 설정하는 속성. 그러니까 어떻게 자리를 차지할지 정한다.
			: 할당 가능한 값
				0. none
					: 아예 "없는" 것으로 간주되어, 자리도 차지하지 않는다. 
				1. inline 
				2. block 	
				3. inline-block 
	

	:투명도/ 가시성 설정 
		visibility
			: 요소의 가시성 설정.
			: 할당가능한 값
				1. visible : 보임 << default
				2. hidden: 숨김 
					: 자신의 영역은 유지하지만, 보이지 않게되며 , 클릭 이벤트가 발생하지 않는다.

		opacity
			: 요소의 투명도 관련 설정. 색 설정하는 거랑 비슷.
			: 0.0 ~ 1.0 값 할당 가능, 0 에 가까울 수록 더 투명한거임
				: 암기 tip ) 오빠는 작으면 안보인다
			: 0 이면 보이진 않지만, 자신의 영역을 유지하고, 클릭 ㅇ이벤트도 된다.



	: 애니메이션관련
		1. trantision 
			: 정해진 시간 동안 요소의 특정속성값을 부드럽게 변화시킬 수 있다.
			: transition 자체로는 최종 상태가 유지되진 않고, 잠시 다른 상태로 변화 시켰다가 다시  원상태로 돌아온다.
			: 전환될 속성이 transform 으로 정의되었느냐 아니냐 따라서 다른 요소에게 까지 영향이 미치기도 하고 안미치기도 한다
				if ) transform 으로 정의 안되어있으면( 그냥 스타일 속성 그 자체로 정의되있으면)
					: 해당 요소 뒤의 요소들은 가만히 있고 , 해당 요소만 왔다리 갔다리

				if ) transform 으로 정의되어있으면
					: 해당 요소가 왔다리 갔다리 함에 따라 뒤의 요소도 그에 맞춰 뒤로밀려나고 앞당겨진다.

			: transition 속성을 명시하는 대상은 "초기 요소"이건 "이후 요소" 이건 상관없는 듯.
	
			(1) transition : 모든 transition 속성을 이용한 스타일을 한 줄에 설정 가능
				: 할당 가능 형태
					: 주의 ) transition-property 와는 다르게 property 들 자체를 콤마로 바로 구분하여 나타내진 못하고, 콤마를 사용하여 한번에 적용하려면 duration 과 쌍으로 구분해서 써야된다
					1.  "property duration function delay" 
					2. "property duration"
					3. "property1 duration1, property2 duration2 , ... "
 

			(2) transition-property : 요소에 추가할 전환 효과 설정
				: tip
					1. transition-property 에 명시되지 않는다고 해당 스타일 속성이 발현되지 않는게 아니다. 그냥 전환 효과가 적용되지 않을 뿐이다.

				: 할당가능한 값
					0. none : 모든 속성을 전환 효과 대상으로 안함
					1. all : 해당 요소의 모든 속성을 전환 효과 대상으로 함 << default
					2. 특정속성 : 특정 속성만을 전환 효과 대상으로 함
						: 콤마를 활용하여 여러 특정 속성을 대상으로 할 수도 있음

			(3) transition-duration : 전환하는데 걸리는 시간 설정
				: defalut >> 0s

			(4) transition-timing-function : 전환 효과의 "속도" 를 설정
				1. linear : 처음부터 끝까지 일정한 속도
 				2. ease : 천천--> 빠름 -->천천 << default 값
		 		3. ease-in : 천천 --> 보통
		 		3. ease-out : 보통 --> 천천
		 		4. ease-in-out : 천천 --> 보통 --> 천천
				5. cubic-bezier : 커스텀
					: 베지에 곡선 bezier curves
					: " cubic-bezier( x1, y1 , x2, y2) " 의 형태로 할당
						: 각 좌표값으로 0~1 값 할당 가능


			(5) transition-delay : 전환 효과가 나타나기 "전"까지 (지연) 시간을 설정
				: 0s 가 default


		: -webkit-transition 
			: webkit 기반 브라우저에서 호환성을 보장하기 위해 사용
			: 일반적으로 웹킷 접두사(-webkit-) 이 추가된 속성은 웹킷 기반의 브라우저 에서만 효력이 있으며, 다른 브라우저 에서는 무시됨.
			: 크롬에서는 별 소용 없지만 그래도 transition 뿐 아니라 -webkit-transition 도 함께 써주자.


		2. transform 
			: 꼴을 변형한다.
			: 메서드 꼴의 값을 할당한다	
			: tip
				skew >> 2d에서만 가능

			: 2d 관련  할당 가능 메서드 
				: 여러개 한번에 할당 가능하고, 콤마 띄어쓰기로 구분한다.
					: 주의 
						: 한꺼번에 쓸 경우 왼->오 방향으로 순차적으로 일어난다
						: transform 을 메서드 별로 선언한다고 해서 각각이 적용되는게 아니고, 그냥 젤 마지막 선언문만 적용된다
					
				-1. translateX(  n  )
					: 현재 위치에서 x 축 방향으로 n 만큼 이동시킨다
						: 현재 위치에서 해당  좌표로 이동하는게 아니다 !
					: 음수값을 주면 음의 방향으로 이동한다

				0. translateY(  n  )
					: 현재 위치에서 y 축 방향으로 n 만큼 이동시킨다

				1. translate(  x축거리 , y축거리 )
					: 현재 위치에서 x,y축 거리만큼 이동시킨다
	
				2. rotate( ndeg) 
					: n 도 만큼 (반)시계 방향 "회전"한다
						: n 이 음수>>  반시계 방향 회전
					: 단위 deg 쓰는 것 잊지 x && deg 는 공백 없이 숫자와 딱 붙여 써야됨
					: 360*n + k deg 일 경우 단순히 kdeg 만 도는걸로 끝나는게 아니라 n 바퀴를 실제로 회전한 다음에 마지막으로 k deg 만큼 추가적으로 회전한다

				3. skewX( n deg) 
					: n 도 만큼 x축 방향으로 비틀어 왜곡한다
						: n > 0 이면 왼쪽이 올라가고 오른쪽이 내려감
					: 그러니까 
						<-🫳
						🫴->  방향처럼 움직인다.

				4. skewY( n deg) 
					: n 도 만큼 y축 방향으로 비틀어 왜곡한다
						: n > 0 이면 오른쪽이 올라가고 왼쪽이 내려감
					: 그러니까 
						^✋
						   🤚v   방향으로 움직인다.
	
				5. skew( n deg , m deg) 
					: n 도 만큼 x축방향, m 도만큼 y축 방향으로 비틀어 왜곡한다
					: 참고로 skew(45deg, 45deg ) 하면 선(?) 이 된다
						: 또 참고로 skew(45deg, 45deg ) ! = skewX(45deg) skewY(45deg)
						: 생각해보면 x 쪽으로 절반, y 쪽으로 절반 접은거니까?

				6. skew( n deg , m deg) 
					: n 도 만큼 x축방향, m 도만큼 y축 방향으로 비틀어 왜곡한다

				7. scaleX( n )
					: 해당 배율 만큼 가로 사이즈를 늘리거나 줄인다 
						: 0.0 <  n <1.0 이면 줄임 
						: n = 1 이면 원본 사이즈 
						:  1 <  n 이면 늘림

				8. scaleY( n )
					: 해당 배율 만큼 세로 사이즈를 늘리거나 줄인다 

				9. scale( n , n )
					: 해당 배율 만큼 가로 세로를 늘리거나 줄인다 
 	
				10. matrix( n,n,n,n,n,n )
					: ( X, Y 방향을 따로 가지지 않는 rotate( ) 를 제외하곤 ) 2D transform 과 관련한 모든 메서드를 한번에 정의한다
						: 뭐 생각해보면 matirx 라는게, 차원. 좌표 같은 느낌이니까


		3. animation
			: 요소에 적용되는 스타일을 다른 스타일로 부드럽게 "전환"시키는 속성
			: transition 과 비슷한 역할을 하긴 하지만 규모가 더 크고,  더 정교한 조절이 가능하다.

			: transition vs animation
				: 공통점 >> js 없이도 직접 애니메이션 효과 적용 가능
				: transition >> 요소의 상태가 변해야 애니메이션 실행
				: animation >> 요소의 상태 변화와 상관 없이 애니메이션을 실행 + 요소의 동작을 키 프레임 단위로 변경 가능

			: 키프레임 Keyframe 
				: 애니메이션의 중간 프레임. animation 의 중간 상태를 정의한것. 
				: 정의 형식 
					:   0% 와 100% 는 각각 from , to 로 작성할 수 있고, 그 사이에 여러 개의 여러 % 값을 작성 가능하다.

					@keyframes 키프레임명{
						0%{  속성명1:값1 ; 속성명2:값2 ; ..  }
						n%{  속성명1:값1 ; 속성명2:값2 ; .. } 
						m%{  속성명1:값1 ; 속성명2:값2 ; .. } 
						.
						.
						.
						100%{   속성명1:값1 ; 속성명2:값2 ; ..  }
					}

				: 사용 방법 >> 해당 키프레임 애니메이션을 적용하고자하는 요소에 animation-name 속성의 값으로 그 키프레임명을 주면 된다.
					
					

			: 속기형 >> animation
				: 최소 animation-name 과 animation-duration 은 지정해야 애니메이션이 실행된다.
				: 할당 값 " name | duration | timing-function | delay | iteration-count | direction | fill-mode | play-state "
    
    
			: 단일 속성 >>
				(1) animation-name :  애니메이션의 중간 상태를 지정
					: 사용하고자 하는 키프레임명을 할당한다

				(2) animation-duration : 애니메이션  한 사이클 수행 시간 지정
					: 숫자, 단위값 을 할당 가능
						0 : 애니메이션 재생 안됨 << 디폴트 값
						음수값: 애니메이션이 재생 안됨

				(3) animation-delay : 애니메이션 시작을 지연시킬 시간 지정
					: 숫자, 단위값 을 할당 가능
						0 : 바로 시작<< 디폴트
						음수값 :  애니메이션이 바로 재생되는데, |음수값| 시간이 지난 뒤의 장면부터 시작한다. 
					
				(4) animation-direction : 애니메이션 재생방향 지정
					: 순방향 >> @keyframes 의 from 부터 to 순으로 재생
					: 역방향 >>  @keyframes 의 to 부터 from 순으로 재생
						: 주의 ) 역방향 재생시 animation-timing-function 값도 반대로 적용된다.

					: 할당 가능한 값
						1. normal : 순방향 재생  << 디폴트
							:한 사이클 끝나면 다시 첫 프레임부터 재생

						2. reverse : 역방향 재생
							:한 사이클 끝나면 다시 마지막 프레임부터 재생

						3. alternate : 순방향 --> 역방향 --> 순방향
							: 부메랑 처럼 재생

						4. alternate-reverse : 역방향 -->순방향 --> 역방향
							: 거꾸로 부메랑 처럼 재생

				(5) amimation-iteration-count 
					: 애니메이션이 몇 번 반복될지 지정
					: 할당 가능 한 값
						1. 숫자값 << 1 이 default
							: 소수값도 할당 가능하고, 실제로 그만큼 찔끔 더 반복한다.
 
						2. infinite : 무한 반복

				(6) animation-play-state : 애니메이션 재생 상태를 정의
					: 할당 가능한 값
						1. running : 재생  << 디폴트 값
						2. paused : 일시정지 

				(7) animation-timing-function : 애니메이션 진행 속도 설정
					: 할당 가능한 값				
 						1. linear : 처음부터 끝까지 일정한 속도
 						2. ease : 천천--> 빠름 -->천천 << default 값
				 		3. ease-in : 천천 --> 보통
		 				4. ease-out : 보통 --> 천천
		 				5. ease-in-out : 천천 --> 보통 --> 천천
		


				(8) animation-fill-mode : 애니메이션 재생 전 후의 상태를 지정한다.
					: 할당 가능한 값
						1. none: 요소의 본래 스타일을 유지  << 디폴트값
						2. forwards: 마지막 키프레임 스타일을 유지
						3. backwards : 첫 키프레임 스타일을 유지
						4. both: 재생 전에는 첫 키프레임 스타일을, 재생 후에는 마지막 키 프레임 스타일을 유지

		



	
	: 테이블 관련 
		: 태그에 따라서 쓸 수 있는 속성이 다른거 주의
		: https://m.blog.naver.com/kimnr123/221871986499
		부모 태그 <table> : 테이블을 정의한다
			:  속성 >> border : 테이블 "전반적"으로 경계를 표시할지 결정한다. 1 혹은 0 만 할당 가능하다.
				
			; 적용 가능한 스타일 속성
				1. border : 테이블 "자체"만의 경계를 설정한다. 
					: table 속성이 border="1" 인 경우 셀들에 경계모양, 경계굵기 까지는 적용되지 않지만, 경계색상은 스타일 속성 border 를 따르게된다.

				2. boder-collapse : 테이블의 테두리와 셀의 테두리 사이의 간격을 어떻게 처리할건지 결정
					: 할당가능값
						(1) collpase : 셀과 테이블 사이의 간격을 없앰. 겹치는 부분은 한 줄로 나타냄
							: 그러니까 border-spacing:0px 와 같은 효과이다. 

						(2) seperate : 셀, 테이블 사이에 간격을 둠 << 디폴트값


				3. border-spacing : 테이블의 테두리와 셀 테두리 사이의 간격을 얼마나 할건지 결정
					: "border-collapse:seperate" 일때만 사용 가능함 주의
					: 테이블 "셀"들의 margin 역할을 하게 된다
						: 테이블 자체에는 margin 줄 수 있다

				4. width, height : 크기 지정
				5. margin , padding : 마진과 패딩 지정


		자식태그 <tr> <th> <tr>, <caption>
			<tr> : 테이블의 row 를 정의한다
				적용 "불"가능한 스타일 속성 >> width 
				적용 가능한 스타일 속성 >> height : 해당 라인 셀들의 높이를 설정
					: 이외의 일반적인 속성 (color, border 등) 도 적용 잘 된다

			<th>,<td> : 테이블의 헤더 셀, 일반셀을 정의한다
				: 주의 ) 
					1. 모든 셀마다 제각각 width, rowspan, colspan 를 설정 가능한게 아니다. 해당 "column" 에서 가장 상위에 위치한 셀의 width 값이 채택된다
					2. 테이블 셀은 margin 설정이 안된다 (table 태그에서 border-spacing 으로 대신 설정 가능)
					3. 테이블 셀은 padding 설정은 된다
						: 뭐 어차피 셀 내부인데 그것까지 간섭하긴 좀 그렇잖아

					4. 한 행 마다 색상을 다르게 하려면 td, th 가 아니라 tr 의 background-color 을 바꿔야되는 것.

				속성 << 스타일 속성 아님을 주의 !! 
					: 다른 칸을 잡아먹는게 아니라 해당 칸이 그만큼 자리를 차지하는 거다. (다음칸은 단순히 뒤로 밀려나간다). 그러니까 칸이 생성되었다고 생각함 편하다
					2. rowspan : 아랫 행 방향으로 몇칸 차지할건지 결정
					3. colspan : 오른쪽 열 방향으로 몇칸 차지할건지 결정

				스타일 속성
					적용 "불"가능한 스타일 속성 >> height
					적용 가능한 스타일 속성 >> width : 크기 지정
						: 이외의 일반적인 속성 (color, border 등) 도 적용 잘 된다


	
			

: 색상의 표현
	: 색상은 숫자가 더 클수록 "밝은"색을 나타낸다.
	1. 16진수코드 
		: 항상 # 로 시작한다.
		: 한 자리 마다 0~F
		(1) RGB 
			#XX XX XX 
				: 두개마다 차례대로 R G B 를 나타내게 된다

		(2) RGBA 
			#XX XX XX  XX 
				: 두개마다 차례대로 R G B A를 나타내게 된다

	2. 10진수 
		: 0 <= n <= 255
		(1)  RGB 표현 >> RGB( n , n , n )
		(2) RGBA 표현 >>  RGBA( n , n , n, n )

	3. 퍼센트 표현 
		: 0~100%
		(1) RGB 표현 >> RGB( 몇% , 몇% , 몇% )
		(2) RGBA 표현 >> RGBA( 몇% , 몇% , 몇%, 몇% )

	4. 이름으로 표현  >> "red" , "springgreen" , .. 
		
 
: 리스트는 네비게이션 바를 만들때도 많이 사용한다
