문서의 콘텐츠는 HTML 로 정의하고, 문서의 스타일은 CSS 를 이용하여 지정한다

CSS Cascading Style Sheet 
	: html 의 스타일을 정의하는 시트
	: 왜 필요한가? >>
		1. 컨텐츠와 스타일을 분리하여 관리할 수 있다
		2. 재사용하기 쉽다
		3. 유지 보수가 쉽다. 하나만 수정하면 되니까.

	: CSS를 추가하는 방법
		1. 인라인 스타일 시트 : 태그 내부에 직접 표기
		2. 내부 스타일 시트:  html 문서의 style 태그 안에 명시
		3. 외부 스타일 시트:  .css 확장자의 파일에 작성하고, 이를 html 파일 내부의 <link> 태그로 연결하여 사용
			<link type="text/css" rel="stylesheet" href="파일명.css">
	: 문법
		선택자 { 
			속성1:값1;
			속성2:값2;
			. . .
			} 

	: 선택자 >> 말 그대로 html 요소를 선택하는 부분
		: 왜 유용한가? >> 여러 요소에 한번에 스타일의 지정이 가능
		: 종류
			: 섞어쓰는거 tip
				(1) 부모태그 * == 해당 부모 태그 내의 모든 후손 태그들
				(2) 특정태그.클래스명 == 특정태그가 해당 클래스인 경우
				(3) 의사 클래스, 요소는 여러개 연속으로 쓸  수 있다
				(4) 의사클래스,요소를 연달아 쓴 경우 and 연산자 처럼 작동한다고 봄 된다.
				(5) 자식/후손 선택자와 의사선택자는 분배법칙처럼 사용할 수 없다. 
					: 앞에 부모 선택자 하나 쓰고 그 뒤에 자식들을 콤마로 구분하여 쓴다고 그 자식들을 자식들로 인식하는게 아니다. 
						
					: 그룹 선택자 쓰고 맨 뒤에 의사클래스.요소 쓴다고 각각의 선택자에 적용되는게 아니다. 
						
					:실제로 그룹 선택자를 이용하여 각각 적용시키고 싶담 각각의 선택자에 일일이 적어줘야된다
						ex) div p,a >> div 의 후손 p 태그 와 그냥 a 첫번째 a 태그
						ex) div p , div a >> div 의 후손 p 태그 와 div의 후손 a 태그
						ex) div p,a:first-child >> div 의 후손 p 태그 와 그냥 a 첫번째 a 태그								ex) div p:first-child  , div a:first-child  >> div 의 첫번째 후손 p 태그와 div의 첫번째 후손 a 태그

			1. 아이디 선택자 : "#아이디명"
			2. 클래스 선택자: ".클래스명"
			3. 타입 선택자 : "HTML요소명"
			4. 전체 선택자 : "*"
			5. 속성 선택자 
				(1)  "HTML요소명[특정속성명]" : 해당 HTML 요소가 특정속성을 가지기만 하면 해당 스타일을 적용시킨다
				(2) "HTML요소명[특정속성명=특정속성값]" : 해당 HTML 요소가 특정속성을 가지고, 특정속성값을 만족할떄 해당 스타일을 적용시킨다.

			6. 선택자 그룹 : 여러 선택자를 콤마로 나열하여 한꺼번에 지정하는 것

			7. 후손, 자식 , 형제 선택자 
				: 부모가 자식보다 앞에 오는거 , 형이 동생보다 앞에 오는거 주의
				(1) "s1 s2" : 후손 관계 >> s1 요소 내부에(바로 아래든 그그그그 아래든 ) 포함된 s2 요소를 "모두" 선택(최초만 선택이 아님)

				(2) "s1 > s2" : 자식 관계 >> s1 요소 바로 한단계 아래에 포함된 s2 요소를 "모두" 선택(최초만 선택이 아님) 
					: 기호 암기 tip >> 자식보다 부모가 더 크니까 "부모 > 자식"
			
				(3) s1 + s2 : 인접 형제 선택자 >> 같은 부모를 가지면서 s1 의 "바로" 뒤에 오는  (s1 바로 뒤에 연속으로 s2 가 오더라도) 최초의 "s2" 에 대하여만 적용한다
		
				(4) s1 ~ s2 : 일반 형제 선택자 >> 같은 부모를 가지면서 s1 의 뒤에 오는 모든 s2 에 대하여 적용한다. (최초만 선택이 아님) 
					: 기호 암기 tip >> ~ 는 좀 널널한 느낌.. + 는 좀 깐깐한 느낌. (교수님한테 + 달아달라고 하기 좀 까다로우니까)

			8. 의사 선택자 :
				: 의사 클래스, 의사 요소는 다른 선택자의 뒤에 명시하여 사용한다
					: 의사클래스, 의사 요소를 단독으로 선택자로 사용하여 스타일 규칙을 정의할순없다

				: 기호 암기 tip >> 요소 -->효소 -- >가루 많이 날린다. :: 이다.
 				(1) 의사 클래스 Pseudo Class : 기존 요소가 특정한 상태를 만족할떄만 발현되는 스타일 규칙을 정의한다
					형태) 앞에 : 가 붙은 형태
						1. 자식 관련
							: 주의 ) "부모선택자 :first-child"  ,  "부모선택자 :only-child" ,"부모선택자 :nth-child(n)" 이런식으로 부모 선택자만 단독으로 쓰면 각각 첫번째, n 번째로 등장한 "부모"선택자에 대해서 해당 스타일이 적용되지, 해당 선택자의 n번째 자식에게 적용되는게 아니다. 이름에 "child" 가 들어간건, 보통 "부모선택자 자식선택자:first-child", "부모선택자 자식선택자:nth-child(n)" 이런 식으로 부모와 자식 관계를 형성하는데 많이 사용해서 그런거다.
								: 보통  "부모선택자 자식선택자:first-child" , "부모선택자 자식선택자:nth-child(n)" 으로 쓰지,  "부모선택자>자식선택자:nth-child(n)"  으로 쓰진 않는 것 같다.

							(1) :first-child << 해당 자식 태그가 부모태그의 "첫번째" 자식 태그일때 발현되게 한다
								: 단순히 해당 부모태그 내부에서 해당 종류의 태그들 중에서 첫번째이기만 하면 적용된다는게 아니라, 실제로 그 자식 태그가 "통틀어" 첫번째여야 적용된다.
							(2) :last-child << 마지막 자식 요소에 한하여 발현되게 한다
							(3) :only-child << 부모가 해당 자식 요소 딱 하나만 가질때 발현되게 한다
								: 단순히 해당 부모태그 내부에서 해당 종류의 태그가 하나만 존재하 면 적용된다는게 아니라, 실제로 그 자식 태그가 "통틀어" 딱 하나여야 적용된다.

							(4) :nth-child(n) << 요소의 n번째 자식에 한하여 발현되게 한다
								: 괄호 내부에 대입 가능한 값
									(1) 숫자 >> 1 부터 사용 가능하다
									(2) n을 이용한식
										: 어떤 형태의 식을 쓰느냐 따라 n 의 시작범위가 다르니 주의 >> 상수 부분 있을땐 n=0부터 시작, 상수 부분 없을떈 1 부터 시작. 
										1. kn >> k 번째 자식요소마다
											: 이때는 n=1,2,3 .. 이라고 봄 된다
										2. n + k >> k번째 자식 요소부터 쭉
											: 이때는 n =0,1,2,3 .. 이라고 봄 된다
										3. an + b>> b번째부터 a개 마다 선택
											: 이때는 n =0,1,2,3 .. 이라고 봄 된다
											: a 는 음수면  b 번째 부터 앞방향으로 a개 마다 이고, a가 양수면 b 번째부터 뒷 방향으로 a개마다 이다.

									(3) 키워드 
										1. odd >> 홀수 번째 자식 요소마다 적용
										2. even >> 짝수 번쨰 자식 요소마다 적용

						2. 해당 요소의 상태 관련
							: ㅈㄴ 주의 ) 덮어쓰임 당하지 앟기 위해 정의 순서는 link ->visited ->hover -> active 로 해야됨
								: https://webstandards.tistory.com/5

							(1) :hover >> 마우스 오버 됬을떄 발현할 스타일 정의
							(2) :active >> 마우스 클릭했을때 발현할 스타일 정의
							(3) :link >> 방문 전인 하이퍼링크에 적용할 스타일 정의
							(4) :visited >> 방문된 하이퍼링크에 적용할 스타일 정의


				(2) 의사 요소 Pseudo element : 기존 요소에 특정 컨텐츠, 스타일을 추가한다
					형태 ) 앞에 :: 가 붙은 형태
						1. ::before , ::after << 요소의 앞, 뒤 부분에 특정 컨텐츠 추가 + 그 컨텐츠의 스타일 정의
							: content 속성을 명시하고, 특정 컨텐츠를 할당한다. 그리고 이와 함께 정의된 스타일은 해당 content 부분에만 적용된다.

						2. ::first-letter << 요소의 앞 글자의 스타일 정의
							: 따로 content 를 할당하는것 없이 첫 글자에 대한 스타일만 정의한다
					

	: 스타일 우선순위
		1. 중요도
			(1) 개발자가 !import로 선언
			(2) 개발자가 그냥 선언
			(3) 브라우져의 기본 선언

		2. 명시도 : 대상을 얼마나 명확히 특정했는가
			(1) 인라인으로 직접 기술
			(2) id
			(3) 클래스
				: 개발자가 아무리 클래스에 대한 정의를 먽저하고, 타입에 대한 정의를 더 나중에 했더라도 명시도 측면에선 클래스가 타입보다 더 우선이기 떄문에, 공통된 스타일 속성에 대한 정의는 클래스의 정의를 따라가게 된다.
			(4) 타입

		3. 순서 : 개발자가 더 나중에 선언할 수록

	:f12 에서 적용된 스타일과 적용되지 않은 스타일
		: 더 위에 있을 수록 나중에 정의 된거
		: 흐린 글자는 지정은 됬으나 적용되지 않은 스타일
		: 취소줄이 들어간 것은 (F12의) 하단에 지정하였으나, (F12)의 상단에서 재정의하여 취소된 스타일이다.

	: 스타일의 상속
		: 스타일을 위에서 아래로. 즉 부모 요소의 스타일을 자식 요소에게 전달한다. 해당 자식 요소에 별다른 스타일 지정이 없으면 부모의 스타일이 적용되게 된다
			: 상속이 안되는 일브 스타일도 있다.


	: 사용 가능한 값의 단위
		: html5 부터는 단위를 명시하지 않으면 오류난다. 반드시 단위를 써줘야 된다.
		절대 단위
			1. px : 픽셀 << 사용 개추
			2. pt : 포인트 << 사용 비추
			
		상대 단위
			 % : 부모 element 를 기준으로 함
			em : 부모 element 혹은 현재 폰트사이즈를 기준으로 함
			rem : root element 를 기준으로 함 >> 개추

	: 스타일 속성값으로 url 할당하는 법 ) url("경로") 로 할당한다.

	: 폰트 관련 속성
		font: 한 줄에서 모든 폰트 속성 설정 가능
			: "폰트스타일 글자두께 글자크기 글꼴" 값 할당 가능
				: 암기 tip ) swf 스위프트
			: 꼭 다 명시하지 않아도 문제 없지만, 없는걸 명시하면 오류난다.

		font-family: 폰트의 스타일 설정 
			: 할당 가능한 값의 형태의 종류
				1. 쌩폰트명
				2. "폰트명"
				3. '폰트명'
			: 여러 폰트명을 , 다양한 형태로 할당 가능 ex) font-family: "맑은 고딕체", 'times' ,serif
			: font-family 를 통한 폰트의 종류는 어차피 1개 밖에 설정 안되는데 굳이  여러개 쓰는 이유
				: 해당 폰트가 사용 불가능한 경우를 대비하는 것.
				: 마지막에는 항상 일반적인 폰트를 지정하도록 한다.

		font-weight : 텍스트 굵기
			: bold, bolder 와 같이 글자를 할당할 수도 있고, 단위를 써서 명확히 할 수도 있다

		font-size: 텍스트 크기
	******font-style:italic 이텔릭체 설정
			: 기본값은 normal 이고, 이탤릭체 쓰려면 italic 을 할당해야된다.

	: 텍스트(인라인 콘텐츠) 관련 설정
		color : 텍스트 색상

		text-decoration: 텍스트 밑의 밑줄 설정
			: text-decoration으로 한꺼번에 "줄위치 색깔 스타일 굵기" 설정 가능
				: 암기 tip ) lcst 라코스테
			: 세분화 속성 ) 
				: text-decoration-line >> none, underline, overline, line-through (줄의 위치 설정)
					: 암기 tip- location 이니까, l로 시작하니까 style 이 아닌 line
				: text-decoration-color 
				: text-decoration-style >>  solid dotted wavy double(줄의 모양 결정)
				: text-decoration-thickness	

		text-align : 텍스트 "정렬"
			: 주의) 인라인 태그의 스타일로만 적용 가능한게 아니다. 블록 태그의 스타일로 정의할 시 블럭 태그 내부의 인라인 태그들에 대해 해당 스타일을 적용시킬 수 있다
			: https://codingeverybody.kr/css-text-align-%EC%86%8D%EC%84%B1/
			1. justify : 양쪽으로 정렬. 그러니까 보기좋게(?) 해당 라인 박스를 꽉 채움
				: 주의 
					(1) 텍스트 사이에 간격이 하나라도 있어야 적용 가능
					(2) 블럭 태그 처럼 해당 라인 자체를 꽉 채운단 말은 아님 (물론 라인 박스의 사이즈가 100% 라면 그렇게 되긴 하겠지만.)
					(3) div 같은 block 태그에는 적용 안되고 inline 태그나 inline-block 태그여야 적용되는거임.

			2. start : 시작하는 지점에 찰싹 붙는다
				: direction 의 속성 값이
					ltr 인 경우 >> left 값과 동일
					rtl 인 경우 >> right 값과 동일

			3. end : 끝나는 지점에 찰싹 붙는다
				: direction 의 속성 값이
					ltr 인 경우 >> right 값과 동일
					rtl 인 경우 >> left 값과 동일

			4. left : 왼쪽 정렬
			5. right ; 오른쪽 정렬
			6. center : 중앙 정렬


		direction : 텍스트 "작성" 방향 설정
			1. ltr >> 디폴트 값
			2. rtl : 오른쪽에서 왼쪽으로 쓰여지고, 오른쪽에 붙는다.
				: 주의!!! ) 한글이나 영어처럼 왼쪽에서 오른쪽으로 쓰는 언어는 rtl 을 입력하면 단순 오른쪽에 붙는것처럼 보이지만, 아랍어와 같이 오른쪽에서 왼쪽으로 쓰여지는 글자는 오른쪽으로 붙을 뿐 아니라 글자가 거꾸로(?) 쓰여진다.
				: https://mine002.tistory.com/116

		letter-spacing : 자간 설정
			: 음수값을 주면 겹치게 할 수 있다
		
		text-indent : 들여쓰기 설정	
			: 음수값을 주면 내어쓰기( 컨텐츠 영역 "밖"으로 튀어나오게 하게) 할 수 있다.
			: ㅈㄴ 주의할 것은 명색이 "text" 임에도 불구하고 block 혹은 inline block 요소에 한하여 적용 가능하다! (inline 요소에는 적용 불가)

		line-height: 텍스트 줄의 높이 설정
			: 인라인 요소에서의 일종의 height 설정이라고 보면 된다.
			: line-height 값에 따라서 텍스트 위 아래의 leading 영역이 증감된다. 이때 line-height 값은 텍스트의 높이 포함에서 할당하는 것임을 주의.
		
		text-transform : 대소문자 변환 지정
			(1) none : 미지정<< 디폴트.
			(2) capitalize : (문장이 아니라)"단어"의 첫번째 글자를 대문자로 
			(3) uppercase: 모든 글자를 대문자로
			(4) lowercase: 모든 글자를 소문자로

		text-shadow : 텍스트 그림자 설정
			: "값1 값2 값3 색" 
				: 주의 ) 값을 4개 쓰는게 아니라 3개 쓰는거다

		word-break 
			: 암기 tip >> 일단 다 꺠부순다.
			: https://que-n-a.tistory.com/entry/%EC%A4%84%EB%B0%94%EA%BF%88-word-break-%EA%B8%80%EC%9E%90-%ED%9D%98%EB%9F%AC%EB%84%98%EC%B9%A8-Word-wrap-%EC%86%8D%EC%84%B1-%EC%A0%95%EB%A6%AC
			: 아시아 언어에 한하여 줄바꿈의 기준을 설정할 수 있음
			: 블럭, 인라인 블럭 요소에 적용 가능
			: 할당 가능한 값
				(1) normal << 디폴트: 브라우져의 기본 값에 따라 줄바꿈이 일어난다
				(2) break-all >>텍스트가 문자 단위로 잘려 아래로 줄바꿈된다
				(3) keep-all >> 단어 단위로 잘려서 아래로 줄바꿈 된다
					: 암기 tip ) break는 완전 절단 나는거고, keep 는 좀 가져가는 느낌
			

		word-wrap
			: 암기 tip >> 둘둘 둘러싼다
			: 비아시아언어 텍스트가 박스로 삐져나오지 않게 하기 위한 속성
				: 왠진 몰라도 아시아 언어의 경우 딱히 이거 설정 안해줘도 텍스트가 밖으로 삐져나오지 않는다
			: 블럭, 인라인 블럭 요소에 적용 가능
			: 할당 가능한 값
				(1) normal << 디폴트:줄바꿈이 일어나지 않고 걍 박스 밖으로 길게 빠져나온다
				(2) break-word >> 텍스트가 박스 밖으로 빠져나오지 않게 줄바꿈을 적용한다
 					: 미국은 bbw 좋아하니까 bw

	: column 관련 설정
		column-count : 구획 영역의 개수 설정
			: 주의 ) 구획 선이 n 개 생기는게 아니라 구획 영역이 n 개 생기는 거임
				ex) column-count:3 >> 구획 영역은 3개, 구획선은 2개

		column-rule: 구획선의 스타일 설정
			: "구획선의굵기 구획선스타일 구획선색깔" 형태의 값 할당
				; font 에 값 할당하는 형식에서 앞에 선의위치만 빠진 형태. 생각해보면 column 의 경우 column 의 용도로 사용하겠다고 한 이상 위치가 걍 정해졌다고 봄 되니까.
	
		column-gap : 구획선과 컨텐츠 간의 간격을 결정
			
			
	: 리스트 관련 설정
		list-style-type: 리스트 요소의 마커를 설정
			(1) none : 불릿이 없음
			(2) circle : 꽉찬 불릿	
			(3) disc : 텅빈 불릿
			(4) square: 사각형
			(5) decimal : 10진수
			(6) lower-roman : 소문자 로마자
			(7) upper-roman : 대문자 로마자
			(8) lower-alpha : 알파벳 소문자 
			(9) upper-alpha : 알파벳 대문자 

	: 배경 관련 속성
		: background 관련 설정은 border 영역 까지 적용된다.
		: background-color 가 background-image 보다 더 밑에 깔린다.

		1. background-color
			: 배경색설정	
			: 색깔 값을 준다

		2. background-image 
			: 배경 이미지설정
			: " url("경로") " 값을 준다
			: 기본적으로 
				(1) 이미지의 크기가 유지된다 (화면에 꽉 채우게 변형되진 않는다)
				(2) 이미지의 크기가 border 보다 작을 경우 ( 크기를 유지하면서) 바둑판처럼 반복되어 나온다


		3. background-attachment
			: 스크롤로 이동할 시 배경화면의 움직임을 설정한다.
			(1) scroll << 스크롤로 이동시 배경화면도 같이 이동. 
			(2) fixed << 스크롤로 이동해도 배경화면 고정

		4. background-repeat
			: 이미지의 크기가 border 보다 작을 시 어떻게 처리할 건지 설정한다
			(1) no-repeat:  border 보다 더 작더라도  이미지 크기를 "유지하면서" , 반복하지 않는다.
			(2) repeat-x : x 방향으로 반복
			(3) repeat-y: y 방향으로 반복
			(4) repeat: x,y 방향으로 반복 << 디폴트

		5. backgorund-position
			: 이미지의 위치 지정
			(1) 키워드 >> 아래의 키워드들을 단독으로 쓸 수도 있고, 조합해서(left top, right center 처럼) 쓸 수 도 있다.
				1. top
				2. bottom
				3. left 
				4. right
				5. center

			(2) 실제값
				: "x축위치 y축위치" 의 형태로 할당한다

		6. background-sizecover
			: 배경이미지의 크기를 설정
			(1) cover : 주어진 영역을 완전히 덮을 수 있도록 최대한 작게, 이미지를 크기를 맞춰줌. 일부분이 짤려서 나타날 수도 있음
			(2) auto: 원본 크기 이미지  << 기본값
			(3) contain : 잘리는 부분 없이 최대한 크게 덮게 함. 




	: 레이아웃 관련 설정
		padding: 요소의 border 과 content 영역 사이의 간격을 조정
			: 주의 ) padding 에는 음수값, auto 값을 줄 수 없다
			: 세분화) padding-top,  padding-right,  padding-bottom, padding-left
 			: padding) 
				1. " padding 위 오른 바닥 왼" 으로 한꺼번에 설정 가능
				2. " padding 위/바닥 오/왼" 으로 한꺼번에 설정 가능

		margin : 요소의 border바깥 영역의 크기를 조절 
			: 주의 ) margin 에는 음수값, auto 값을 줄 수 "있"다
			: 세분화) margin-top,  margin-right,  margin-bottom, margin-left
 			: margin) 
				1. " margin 위 오른 바닥 왼" 으로 한꺼번에 설정 가능
				2. " margin 위/바닥  오/왼" 으로 한꺼번에 설정 가능

		border : 경계선 결정
			1. border-top,  border-right,  border-bottom, border-left
				: 각각 "두께 스타일 색" 의 값 부여 가능
			2. border
				:  "두께 스타일 색"  으로 모든 방향의 경계 설정 가능
				: 주의 ) "위두께 오두께 아래두꼐 왼두께 스타일 색" 처럼 각 변을 한꺼번에 커스터마이징 할 순 없다
			3. border-radius
				: 경계 모서리의 둥근 정도 설정

		box-sizing 
			: width 와 height 를 어떻게 구할지 결정한다
			: 이러나 저러나 margin 영역은 border-box 에 포함되지 않는다!
			(1) border-box : "border 영역"을 기준으로 width, heigth 가 구해진다
				: 그러니까 길이 == 콘텐츠영역+ 패딩영역
			(2) content-box : 콘텐츠 영역을 기준으로 width, height 가 구해진다 << 디폴트값

		width, height
			: "box-sizing:border-box;" 없이는 "컨텐츠 영역" 의 너비와 높이
			:  "box-sizing:border-box;" 있으면 "border 영역" 의 너비와 높이


: 박스 모델
	: html 요소들을 박스 형태로 그리는 것
	: 구성
		1. 콘텐츠 영역
		2. 패딩 영역 << 패딩 영역은 투명하다
		3. 보더 영역 
		4. 마진 영역 << 마진 영역은 투명하다

: 인라인 요소와 블럭 요소의 레이아웃
	: 인라인 요소
		: margin, padding 의 경우 좌우 방향으로만 가능하고 top, bottom 방향으로는 설정 못한다.
			: border 은 모든 방향으로 다 된다
		: 인라인 요소를 (자식요소로써) 수평 정렬 >> text-align : center
		: 인라인 요소를 (자식요소로써) 수직 정렬 
			sol1 : 자식의 line-height 값을 부모의 "content 영역"의 height 값과 같게 한다
				: 자식이 들어가는 영역은 content  영역이지, border 내부의 영역 그 자체가 아니라서 그렇다.
				if ) 부모 블록 요소가 box-sizing:border-box 일 경우 >>  line-height 값을  " 부모의 height - (padding-top + padding-bottom) " 으로 해줘야됨
					
				if ) 부모 블록 요소가 box-sizing:content-box 일 경우 >>  line-height 를 부모 블록 요소의 height 값 그 자체로 하면 됨.


	: 블럭 요소 
		: 모든 방향으로 margin, padding 적용가능하다
		: 주의 ) 
			1. auto 는 margin-right, margin-left 에만 적용 가능하고 margin-top ,margin-bottom 에는 적용이 안된다
				: margin-top, bottom 에 auto 값을 할당한다고 에러가 나지 않지만 실질적으로 이때 auto 값은 0과 같다고 한다

			2 auto != 50%
				: 50% 는 말 그대로 부모 사이즈의 절반이 되는거고, auto 는 알잘딱깔센으로 해당 자식 요소를 배치했을때 남게되는 사이즈를 절반으로 나눈거다.
				: 50% 는 부모의 컨텐츠 영역의 50% 인가 아니면 border 의 50%인가? 
			
		: 블럭 요소를 (자식요소로써) 수평 정렬 >> margin-left:auto; margin-right:auto;
		: 블럭 요소를 (자식요소로써) 수직 정렬 >> margin-top: 직접계산한값; margin-bottom: 직접계산한값;
			: 직접 계산한 값 = " (부모 content 영역의 height - 자식 border 영역의 height) /2 "
 
		: 블럭 요소를 (자식요소로써) 정중앙에 정렬 >> margin: 어떤값 auto;


			

: 색상의 표현
	: 색상은 숫자가 더 클수록 "밝은"색을 나타낸다.
	1. 16진수코드 
		: 항상 # 로 시작한다.
		: 한 자리 마다 0~F
		(1) RGB 
			#XX XX XX 
				: 두개마다 차례대로 R G B 를 나타내게 된다

		(2) RGBA 
			#XX XX XX  XX 
				: 두개마다 차례대로 R G B A를 나타내게 된다

	2. 10진수 
		: 0 <= n <= 255
		(1)  RGB 표현 >> RGB( n , n , n )
		(2) RGBA 표현 >>  RGBA( n , n , n, n )

	3. 퍼센트 표현 
		: 0~100%
		(1) RGB 표현 >> RGB( 몇% , 몇% , 몇% )
		(2) RGBA 표현 >> RGBA( 몇% , 몇% , 몇%, 몇% )

	4. 이름으로 표현  >> "red" , "springgreen" , .. 
		
 
