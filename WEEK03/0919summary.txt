명령어 파이프라인 : 동시에 명령어를 처리하는 기술
	- 가정 -> (그냥) 3개의 명령어를 실행하면 6개의 클럭 주기 필요
		인출 사이클이 클럭주기 1개
		실행 사이클 클럭주기 1개 

	- 문제 : 인출 사이클 동안 실행 사이클이 놀고, 실행 사이클동안 인출 사이클이 놀고 있다
	    - (cpu의 효율적인 동작을 위해 놀고있는 얘가 없도록) 동시에 소환할 순 없을까? 
		: 첫번쨰 명령어의 실행 사이클 도는동안, 두번쨰 명령어의 인출사이클을 돌리는 식으로 운영한다
		: 이렇게 수행하면 3개의 명령어를 수행하는데 4개의 클럭주기만 있으면된다
		: 이렇게 명령어를 동시에 실행하는 것을 명령어 파이프 라인이라고 한다

	- n 단계 명령어 파이프라인 >> n 개의 독립적인 파이프라인 모듈 분리
		- 이론적으로 k 단계 명령어 파이프라인 기법의 경우 이론적 속도향상 정도는 k 이다(단계수)
			: 그러니까 2단계 파이프라인 -> 2 배
		****** 실제로는 그것 보다 효율이 좋지 않ㄴ다
				why1. 모든 명령어들이 모두 해당 단계들을 거치지는 않는다
				why2.  파이프라인의 클럭은 처리 시간이 가장 오래 걸리는 단계를 기준으로 결정
					: 해결 방안 >> 슈퍼 파이프라이닝(super-pipelining): 명령어 파이프라인의 각 단계를 세분하여, 한 클럭 주기에 여러 단계를 수행하여 명령어를 처리하여 속도를 높이도록 설계
						: 그러니까 한 클럭 주기에 여러 단계를 수행하는 것

				why3.  3개의 장애(hazards)
					(1) 구조적 장애(structural hazards)>> 서로 다른 단계에서 동시에 실행되는 명령이 컴퓨터 내의 장치 하나를 동시에 사용하려고 할 때 발생
						: 충돌이 일어나면 지연이 발생한다

					(2) 데이터 장애(data hazards) >> 한 명령어 수행 결과가 다른 명령어의 연산에 사용될 때, 다른 명령어의 파이프라인의 단계가 지연되는 경우 발생. 
						: 그러니까 명령어 처리 결과 사이에 데이터 의존성(data dependency) 때문. 
							: 그러니까 최신 값이 아닐 수 있다. 특정 명령어가 처리된 결과를 입력으로 받아야되는데 특정 명령어가 다 실행되기 이전이면 처리전 값을 입력으로 받는 불상사가 있을 ㅅ도 ..

						: 해결방안 
							1. 지연 명령(stall)을 사이에 끼워 넣음
							2. 명령어 순서 조정

					(3) 제어 장애(control hazards)
						: "분기 명령어"의 경우 "미리 인출된 명령어"들이 쓸모 없어 진다.
						: ex ) 명령어 3: JUMP 12; jump(if zero) to address 12
						: 해결 방안
							1. 분기 예측(branch prediction)
							2. 분기 목적지 선인출(prefetch branch target)	
								: 레지스터가 추가로 필요 (동시에 인출하기 위해)
							3. 루프 버퍼(loop buffer) 사용
								: 분기가 반복문에 의해 발생하는 경우 가장 최근에 인출된 n개 명령어들이 저장이 되는데, 이러한 방식으로 좀 저장해둔다
							4. 지연 분기(delayed branch) 
								: 분기 명령어의 위치를 재배치



		- 2단계 명령어 파이프라인
			- 명령어가 증가할 수록 효율성은 2에 수렴하게 된다
			- 문제 : 두 단계의 처리 시간이 동일하지 않으면 파이프라인 속도
향상이 저하됨
				: ex ) 인출하는데 0.5, 실행하는데 1.5 가 걸리면 실행할때 인출하는 경우 노는 텀이 발생한다. 속도 향상이 별로 되지 않는다.
			- 해결 방법 >> 각 단계의 실행 시간을 동일하게 해줘야된다 >> 단계를 세분화 하자 (오래 걸리는건 좀 더 쪼개자)

		- 4단계 명령어 파이프라인 << 2단계 보다 세분화
			- 명령어가 증가할 수록 효율성은 4에 수렴하게 된다
			- 단계
				명령어 인출 단계 IF : 다음 명령어를 기억장치로부터 인출
				명령어 해독 단계 ID: 제어 유니트에서 해독기(decoder)를 이용
하여 명령어를 해석
				오퍼랜드 인출 단계 OF: 연산에 필요한 오퍼랜드의 데이터를
기억장치로부터 인출
				실행 단계 EX : 해독기에서 정해진 연산을 수행


			- 실행시간 : K + n-1 
				: why? >> 한 명령어 실행되는데 K 개 의 클럭주기가 소비되고, 1 단계가 지날때마다 명령어가 하나씩 실행되니까 ( 사진 참고 (그려봐라) )

			- 파이프라인에 의한 속도 향상(𝑆𝑝) 정도 >> (k*n) / (k + (N-1))



슈퍼스칼라 >> 파이프라인을 확장시킨 것	.  ()하나의 프로세서 안에) 2개이상의 파이프라인을 탑재시킨 것. 
	- 이론적으로는 프로그램 처리 속도가 파이프라인의 수만큼 향상 
	- 파이프라인이 m 개인 슈퍼스칼라 ==m-way 슈퍼스칼라
	- m-way 슈퍼스칼라에 의한 실행 시간 : k + (n-m)/m
		: why ? >> 사진 참고
	- 속도 향상 정도 : 
