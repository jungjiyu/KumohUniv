명령어 파이프라인 : 동시에 명령어를 처리하는 기술
	- 가정 -> (그냥) 3개의 명령어를 실행하면 6개의 클럭 주기 필요
		인출 사이클이 클럭주기 1개
		실행 사이클 클럭주기 1개 

	- 문제 : 인출 사이클 동안 실행 사이클이 놀고, 실행 사이클동안 인출 사이클이 놀고 있다
	    - (cpu의 효율적인 동작을 위해 놀고있는 얘가 없도록) 동시에 소환할 순 없을까? 
		: 첫번쨰 명령어의 실행 사이클 도는동안, 두번쨰 명령어의 인출사이클을 돌리는 식으로 운영한다
		: 이렇게 수행하면 3개의 명령어를 수행하는데 4개의 클럭주기만 있으면된다
		: 이렇게 명령어를 동시에 실행하는 것을 명령어 파이프 라인이라고 한다

	- n 단계 명령어 파이프라인 >> n 개의 독립적인 파이프라인 모듈 분리
		- 이론적으로 k 단계 명령어 파이프라인 기법의 경우 이론적 속도향상 정도는 k 이다(단계수)
			: 그러니까 2단계 파이프라인 -> 2 배
		****** 실제로는 그것 보다 효율이 좋지 않ㄴ다
				why1. 모든 명령어들이 모두 해당 단계들을 거치지는 않는다
				why2.  파이프라인의 클럭은 처리 시간이 가장 오래 걸리는 단계를 기준으로 결정
					: 해결 방안 >> 슈퍼 파이프라이닝(super-pipelining): 명령어 파이프라인의 각 단계를 세분하여, 한 클럭 주기에 여러 단계를 수행하여 명령어를 처리하여 속도를 높이도록 설계
						: 그러니까 한 클럭 주기에 여러 단계를 수행하는 것

				why3.  3개의 장애(hazards)
					(1) 구조적 장애(structural hazards)>> 서로 다른 단계에서 동시에 실행되는 명령이 컴퓨터 내의 장치 하나를 동시에 사용하려고 할 때 발생
						: 충돌이 일어나면 지연이 발생한다

					(2) 데이터 장애(data hazards) >> 한 명령어 수행 결과가 다른 명령어의 연산에 사용될 때, 다른 명령어의 파이프라인의 단계가 지연되는 경우 발생. 
						: 그러니까 명령어 처리 결과 사이에 데이터 의존성(data dependency) 때문. 
							: 그러니까 최신 값이 아닐 수 있다. 특정 명령어가 처리된 결과를 입력으로 받아야되는데 특정 명령어가 다 실행되기 이전이면 처리전 값을 입력으로 받는 불상사가 있을 ㅅ도 ..

						: 해결방안 
							1. 지연 명령(stall)을 사이에 끼워 넣음
							2. 명령어 순서 조정

					(3) 제어 장애(control hazards)
						: "분기 명령어"의 경우 "미리 인출된 명령어"들이 쓸모 없어 진다.
						: ex ) 명령어 3: JUMP 12; jump(if zero) to address 12
						: 해결 방안
							1. 분기 예측(branch prediction)
							2. 분기 목적지 선인출(prefetch branch target)	
								: 레지스터가 추가로 필요 (동시에 인출하기 위해)
							3. 루프 버퍼(loop buffer) 사용
								: 분기가 반복문에 의해 발생하는 경우 가장 최근에 인출된 n개 명령어들이 저장이 되는데, 이러한 방식으로 좀 저장해둔다
							4. 지연 분기(delayed branch) 
								: 분기 명령어의 위치를 재배치



		- 2단계 명령어 파이프라인
			- 명령어가 증가할 수록 효율성은 2에 수렴하게 된다
			- 문제 : 두 단계의 처리 시간이 동일하지 않으면 파이프라인 속도
향상이 저하됨
				: ex ) 인출하는데 0.5, 실행하는데 1.5 가 걸리면 실행할때 인출하는 경우 노는 텀이 발생한다. 속도 향상이 별로 되지 않는다.
			- 해결 방법 >> 각 단계의 실행 시간을 동일하게 해줘야된다 >> 단계를 세분화 하자 (오래 걸리는건 좀 더 쪼개자)

		- 4단계 명령어 파이프라인 << 2단계 보다 세분화
			- 명령어가 증가할 수록 효율성은 4에 수렴하게 된다
			- 단계
				명령어 인출 단계 IF : 다음 명령어를 기억장치로부터 인출
				명령어 해독 단계 ID: 제어 유니트에서 해독기(decoder)를 이용
하여 명령어를 해석
				오퍼랜드 인출 단계 OF: 연산에 필요한 오퍼랜드의 데이터를
기억장치로부터 인출
				실행 단계 EX : 해독기에서 정해진 연산을 수행


			- 실행시간 : K + n-1 
				: why? >> 한 명령어 실행되는데 K 개 의 클럭주기가 소비되고, 1 단계가 지날때마다 명령어가 하나씩 실행되니까 ( 사진 참고 (그려봐라) )

			- 파이프라인에 의한 속도 향상(𝑆𝑝) 정도 >> (k*n) / (k + (N-1))



슈퍼스칼라 >> 파이프라인을 확장시킨 것	.  ()하나의 프로세서 안에) 2개이상의 파이프라인을 탑재시킨 것. 
	- 이론적으로는 프로그램 처리 속도가 파이프라인의 수만큼 향상 
	- 파이프라인이 m 개인 슈퍼스칼라 ==m-way 슈퍼스칼라
	- m-way 슈퍼스칼라에 의한 실행 시간 : k + (n-m)/m
		: why ? >> 사진 참고
	- 속도 향상 정도 : 구체적인 식은 18p 에... 
		: "이론상" 최대 mk 배 성능 향상 가능
			: 실제로는 그것보다 효율 안나오는 이유
				why1. 명령어들 간의 데이터 의존성
				why2. 하드웨어(레지스터, 캐시, 기억장치 등) 이용에 대한 경합

			: 해결 방안 
				1. 명령어 실행 순서 재배치
				2. 하드웨어 추가(증복 설치) << 근데 이렇케 함 비용 추가


CPU 코어 >> 독립적으로 명령어를 실행시킬 수 있는 핵심 하드웨어 모듈
	: 슈퍼스칼라 H/W 모듈, 산술논리연산장치, 부동소수점연산장치(Floating Point Unit, FPU), 레지스터 세트, 제어장치, 온 칩 캐시(on-chai cache) 등
		: 참고로 부동소수점에 대한 연산을 수행하는 얘는 따로 있다 (ALU 와는 별개)


멀티-태스킹 : 여러 CPU 코어들을 사용하여 독립적인 프로세스를 동시에 실행하는 것
멀티 스레딩 : 하나의 CPU 코어가 여러 스레드를 동시에 실행
	프로세스 : 현재 실행중인 프로그램
		: 운영체제로부터 자원을 할당받는다
		: 프로세스는 1개 이상의 스레드로 구성되고, 각 스레드는 독립적이다
			ex ) 패킷을 보내는 스레드 , 노래를 듣는 스레드

	스레드 : 독립적으로 실행 가능한 최소 크기의 프로그램 단위. 
		: 단일-스레드 모델 >> 각 코dj가 스레드 하나만 처리. 각 코어에 RS가 하나씩만 있음
		: 멀티-스레드 모델 >> 각 코어는 두 개의 RS들을 포함하며, 스레드를 두 개씩 처리



듀얼 코어, 멀티 코어	
	듀얼 코어 >> 코어가 2개
		: 단일-코어 슈퍼스칼라 프로세서에 비하여 이론상 2배 속도 향상
		: 코어들은 내부 캐시와 시스템 버스 인터페이스만 공유
	쿼드-코어(quad-core) >>  네 개의 CPU 코어


명령어 세트 >>  CPU를 위하여 정의된 명령어들의 집합
	- 명령어 세트 설계를 위해 고려되어야 할 사항들
		1. 연산 종류(operation repertoire): CPU가 수행할 연산들의 수와 종류 및 복잡도
			(1) 데이터 전송: 레지스터와 레지스터 간, 레지스터와 기억장치 간, 혹은 기억장치와 기억장치 간에 데이터를 이동하는 동작
			(2) 산술 연산
			(3) 논리 연산
			(4) 입출력(I/O) << 7장서 ...
			(5) 프로그램 제어: 명령어 실행 순서를 변경하는 연산들

		2. 데이터 형태(data type) >> 3장서 배운다
		3. 주소지정 방식(addressing mode): 오퍼랜드의 주소를 지정하는 방식


명령어 구성 요소
	1. 연산 코드(Operation Code): 수행될 연산을 지정
	2. 오퍼랜드(Operand)	<< 피연산자
		: 각 연산은 한 개 혹은 두 개의 입력 오퍼랜드들과 한 개의 결과 오퍼랜드를 포함

	3. 다음 명령어 주소(Next Instruction Address)


명령어 형식 >> 필드들의 수와 비트 수 정의
	필드(field): 명령어의 각 구성 요소들에 소요되는 비트들의 그룹
		: 연산 코드 필드의 길이 >> 연산의 개수를 결정
		: 오퍼랜드 필드의 길이 >> 오퍼랜드의 범위(데이터, 기억장치 주소, 레지스터 번호) 결정

	명령어의 길이 = 단어(word) 길이
		: CPU 가 한번에 처리할 수 있는 량ㄴ
		[예] 세 개의 필드들로 구성된 16-비트 명령어


오퍼랜드 수(=피연산자 갯수)에 따른 명령어 분류 
	: 0-주소 명령어 >> 연산자는 있는데 오퍼랜드가 없는.. (op 코드만 있는_
		: 연산에 필요한 오퍼랜드 및 결과의 저장 장소가 묵시적으로 지정된 경우			
			: ex ) 스택에 대한 ... 
				: PUSH A, PUSH B , .. 들은 다 1 주소 명령어
					: 그러니까 오퍼랜드가 명시되면 0 주소는 아닌거다
				: 그런데 + , - , * 같은거 만나면, 자동으로 POP 적용해서 얻은 결과로  + , - , *  연산. 얘네가 0 주소.

	: 1-주소 명령어(one-address instruction): 오퍼랜드가 1개인 명령어
		: 이 경우 다른 한 오퍼랜드는 묵시적으로 AC 가 된다
		: ex ) ADD X // AC ← AC+M[X]

	: 2-주소 명령어(two-address instruction): 두 개의 오퍼랜드를 포함하는 명령어
		: 연산 후에도 입력 데이터가 그대로라는 보장은 없음
		: ex ) ADD R1, R2 // R1 ← R1+R2
		: ex ) MOV R1, R2 // R1 ← R2

	: 3-주소 명령어(three-address instruction): 세 개의 오퍼랜드들을 포함하는 명령어
		: 연산 후에도 입력 데이터 보존 (출력용 오퍼랜드를 따로 받은거니까)
		: ex )  ADD R1, R2, R3 // R1 ← R2+R3



35p 문제에서 "명령어의각 필드를 비트로 나타내라." 는 걍 무시해라
	: 필요한 연산의 종류는 12개 >> 2**3 은 8로 12 커버 못치므로 최소 2**4 해줘야되니까 연산코드 비트는 4 bit 필요


37p 문제 >> 
	: M[i] == 기억장치 i번지의 내용
	: STOR == 임시 저장
	: T == 기억장치 내 임시 저장 장소의 주소


38p 문제 >> 
	: R1, R2  >> 레지스터
	: A, B, C, .. 같은 >> 주소.


주소지정방식 : 오퍼오퍼랜드의 유효 주소를 결정하는 방싣
	: 유효 주소 == 실제 데이터가 저장된 주소
	: 주소지정방식의 종류는 CPU 마다 다르다. 다양한다
		: why 다양할까? >> 제한된 수의 명령어 비트들을 이용하여, 프로그래머가 다양한 방
법으로 오퍼랜드의 주소를 결정하도록 해주며, 더 큰 용량의 기억장치를 사용하기 위해
			: 간접 사이클.

		****종류 >> 
			▪직접 주소지정 방식
			▪간접 주소지정 방식
			▪묵시적 주소지정 방식
			▪즉시 주소지정 방식
			▪레지스터 주소지정 방식
			▪레지스터 간접 주소지정 방식
			▪변위 주소지정 방식
				- 상대 주소지정 방식
				- 인덱스 주소지정 방식
				- 베이스-레지스터 주소지정 방식


	: 명령어 내 오퍼랜드 필드의 내용
		1.기억장치 주소: 데이터가 저장된 기억장치의 위치를 지정
		2.레지스터 번호: 데이터가 저장된 레지스터를 지정
		3. 데이터: 명령어의 오퍼랜드 필드에 데이터가 포함

	: 기호
		EA: 데이터가 저장된 기억장치의 실제 주소(유효 주소, Effective Address)
		A: 명령어 내의 주소 필드 내용(오퍼랜드 필드의 내용이 기억장치 주소인경우)
			(A) :기억장치 A 번지의 내용
		R: 명령어 내의 레지스터 번호(오퍼랜드 필드의 내용이 레지스터 번호인
경우)
			(R): 레지스터 R의 내용
